// Generated by Haxe 3.3.0
(function ($hx_exports, $global) { "use strict";
$hx_exports["troshx"] = $hx_exports["troshx"] || {};
$hx_exports["troshx"]["util"] = $hx_exports["troshx"]["util"] || {};
;$hx_exports["troshx"]["tros"] = $hx_exports["troshx"]["tros"] || {};
$hx_exports["troshx"]["tros"]["ai"] = $hx_exports["troshx"]["tros"]["ai"] || {};
;$hx_exports["troshx"]["core"] = $hx_exports["troshx"]["core"] || {};
$hx_exports["tjson"] = $hx_exports["tjson"] || {};
$hx_exports["dat"] = $hx_exports["dat"] || {};
$hx_exports["dat"]["gui"] = $hx_exports["dat"]["gui"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = ["EReg"];
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,__class__: EReg
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = ["HxOverrides"];
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var List = function() {
	this.length = 0;
};
$hxClasses["List"] = List;
List.__name__ = ["List"];
List.prototype = {
	h: null
	,q: null
	,length: null
	,add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,iterator: function() {
		return new _$List_ListIterator(this.h);
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null?"null":"" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
	,map: function(f) {
		var b = new List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			b.add(f(v));
		}
		return b;
	}
	,__class__: List
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["_List.ListNode"] = _$List_ListNode;
_$List_ListNode.__name__ = ["_List","ListNode"];
_$List_ListNode.prototype = {
	item: null
	,next: null
	,__class__: _$List_ListNode
};
var _$List_ListIterator = function(head) {
	this.head = head;
};
$hxClasses["_List.ListIterator"] = _$List_ListIterator;
_$List_ListIterator.__name__ = ["_List","ListIterator"];
_$List_ListIterator.prototype = {
	head: null
	,hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
	,__class__: _$List_ListIterator
};
var Main = function() { };
$hxClasses["Main"] = Main;
Main.__name__ = ["Main"];
Main.main = function() {
};
Math.__name__ = ["Math"];
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = ["Reflect"];
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isObject = function(v) {
	if(v == null) {
		return false;
	}
	var t = typeof(v);
	if(!(t == "string" || t == "object" && v.__enum__ == null)) {
		if(t == "function") {
			return (v.__name__ || v.__ename__) != null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = ["Std"];
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = ["StringBuf"];
StringBuf.prototype = {
	b: null
	,__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = ["StringTools"];
StringTools.htmlEscape = function(s,quotes) {
	s = s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
	if(quotes) {
		return s.split("\"").join("&quot;").split("'").join("&#039;");
	} else {
		return s;
	}
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var ValueType = { __ename__ : true, __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"] };
ValueType.TNull = ["TNull",0];
ValueType.TNull.toString = $estr;
ValueType.TNull.__enum__ = ValueType;
ValueType.TInt = ["TInt",1];
ValueType.TInt.toString = $estr;
ValueType.TInt.__enum__ = ValueType;
ValueType.TFloat = ["TFloat",2];
ValueType.TFloat.toString = $estr;
ValueType.TFloat.__enum__ = ValueType;
ValueType.TBool = ["TBool",3];
ValueType.TBool.toString = $estr;
ValueType.TBool.__enum__ = ValueType;
ValueType.TObject = ["TObject",4];
ValueType.TObject.toString = $estr;
ValueType.TObject.__enum__ = ValueType;
ValueType.TFunction = ["TFunction",5];
ValueType.TFunction.toString = $estr;
ValueType.TFunction.__enum__ = ValueType;
ValueType.TClass = function(c) { var $x = ["TClass",6,c]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TEnum = function(e) { var $x = ["TEnum",7,e]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TUnknown = ["TUnknown",8];
ValueType.TUnknown.toString = $estr;
ValueType.TUnknown.__enum__ = ValueType;
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = ["Type"];
Type.getClassName = function(c) {
	var a = c.__name__;
	if(a == null) {
		return null;
	}
	return a.join(".");
};
Type.resolveClass = function(name) {
	var cl = $hxClasses[name];
	if(cl == null || !cl.__name__) {
		return null;
	}
	return cl;
};
Type.createInstance = function(cl,args) {
	var _g = args.length;
	switch(_g) {
	case 0:
		return new cl();
	case 1:
		return new cl(args[0]);
	case 2:
		return new cl(args[0],args[1]);
	case 3:
		return new cl(args[0],args[1],args[2]);
	case 4:
		return new cl(args[0],args[1],args[2],args[3]);
	case 5:
		return new cl(args[0],args[1],args[2],args[3],args[4]);
	case 6:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5]);
	case 7:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	case 8:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	case 9:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);
	case 10:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
	case 11:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10]);
	case 12:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11]);
	case 13:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12]);
	case 14:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13]);
	default:
		throw new js__$Boot_HaxeError("Too many arguments");
	}
};
Type.createEmptyInstance = function(cl) {
	function empty() {}; empty.prototype = cl.prototype;
	return new empty();
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type["typeof"] = function(v) {
	var _g = typeof(v);
	switch(_g) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum(e);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
$hxClasses["Xml"] = Xml;
Xml.__name__ = ["Xml"];
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + xml.nodeType);
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	nodeType: null
	,nodeName: null
	,nodeValue: null
	,parent: null
	,children: null
	,attributeMap: null
	,get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		return __map_reserved[att] != null?_this.getReserved(att):_this.h[att];
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		if(__map_reserved[att] != null) {
			_this.setReserved(att,value);
		} else {
			_this.h[att] = value;
		}
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		if(__map_reserved[att] != null) {
			return _this.existsReserved(att);
		} else {
			return _this.h.hasOwnProperty(att);
		}
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		return this.attributeMap.keys();
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		return HxOverrides.iter(_g);
	}
	,elementsNamed: function(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			var tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + child.nodeType);
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		return HxOverrides.iter(_g);
	}
	,firstElement: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,__class__: Xml
};
var dat_gui_DatUtil = $hx_exports["dat"]["gui"]["DatUtil"] = function() { };
$hxClasses["dat.gui.DatUtil"] = dat_gui_DatUtil;
dat_gui_DatUtil.__name__ = ["dat","gui","DatUtil"];
dat_gui_DatUtil._concatDyn = function(a1,a2) {
	return a1.concat(a2);
};
dat_gui_DatUtil.setup = function(instance,classe,options,dotPath,funcToInspect) {
	if(dotPath == null) {
		dotPath = "";
	}
	var typeStr;
	if(classe == null) {
		var o = instance;
		if(o == null) {
			classe = null;
		} else {
			classe = js_Boot.getClass(o);
		}
	}
	if(options == null) {
		options = { };
	}
	var ignoreInspectMeta = Reflect.field(options,"ignoreInspectMeta");
	var useStatic = Reflect.field(options,"isStatic");
	var rtti = haxe_rtti_Rtti.getRtti(classe);
	var meta = funcToInspect != null?funcToInspect.meta:useStatic?haxe_rtti_Meta.getStatics(classe):haxe_rtti_Meta.getFields(classe);
	if(funcToInspect != null) {
		instance = funcToInspect.instance;
	}
	var fieldHash = { };
	var fields = funcToInspect != null?funcToInspect.fields:useStatic?rtti.statics:rtti.fields;
	var funcFolder = null;
	var cur;
	var curVal;
	var frStatics;
	var frParams;
	var frValue;
	var frPrefix = null;
	var frI;
	var _g_head = fields.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var f = val;
		var fieldMeta = Reflect.field(meta,f.name);
		var isVar = haxe_rtti_TypeApi.isVar(f.type);
		if(isVar && (ignoreInspectMeta || fieldMeta != null && Object.prototype.hasOwnProperty.call(fieldMeta,"inspect"))) {
			cur = Reflect.field(fieldMeta,"inspect");
			if(cur == null) {
				cur = { };
			} else {
				cur = cur[0];
			}
			if(cur == null) {
				cur = { };
			}
			if(Object.prototype.hasOwnProperty.call(cur,"value")) {
				curVal = Reflect.field(cur,"value");
			} else {
				var field = f.name;
				var tmp;
				if(instance == null) {
					curVal = null;
				} else {
					var tmp1;
					if(instance.__properties__) {
						tmp = instance.__properties__["get_" + field];
						tmp1 = tmp;
					} else {
						tmp1 = false;
					}
					if(tmp1) {
						curVal = instance[tmp]();
					} else {
						curVal = instance[field];
					}
				}
			}
			typeStr = haxe_rtti_CTypeTools.toString(f.type);
			if(typeStr == "Int" || typeStr == "UInt" || typeStr == "Float") {
				if(curVal == null) {
					curVal = 0;
				}
				cur.value = curVal;
				if(typeStr == "Int" || typeStr == "UInt") {
					if(Object.prototype.hasOwnProperty.call(fieldMeta,"bitmask")) {
						var bitMaskFolder = { _classes : Object.prototype.hasOwnProperty.call(cur,"_classes")?dat_gui_DatUtil._concatDyn(["bitmask"],Reflect.field(cur,"_classes")):["bitmask"]};
						var gotBits = false;
						var bitFieldMeta = Reflect.field(fieldMeta,"bitmask")[0];
						if(typeof(bitFieldMeta) == "string") {
							frValue = bitFieldMeta;
							frStatics = new _$List_ListIterator(rtti.statics.h);
							var _g = frStatics;
							while(_g.head != null) {
								var val1 = _g.head.item;
								_g.head = _g.head.next;
								var f1 = val1;
								frI = f1.name.indexOf("_");
								if(frI >= 0) {
									gotBits = true;
									frPrefix = f1.name.substring(0,frI);
									if(frPrefix == frValue) {
										bitMaskFolder[f1.name.substring(frI + 1)] = { _bit : Reflect.field(classe,f1.name), value : (curVal & Reflect.field(classe,f1.name)) != 0};
									}
								}
							}
						} else {
							var _g1 = 0;
							while(_g1 < 32) {
								var i = _g1++;
								bitMaskFolder["b" + (i == null?"null":"" + i)] = { _bit : 1 << i, value : (curVal & 1 << i) != 0};
							}
							gotBits = true;
						}
						if(gotBits) {
							fieldHash[f.name] = bitMaskFolder;
							var _g2 = 0;
							var _g11 = Reflect.fields(cur);
							while(_g2 < _g11.length) {
								var p = _g11[_g2];
								++_g2;
								if(p.charAt(0) != "_") {
									continue;
								}
								bitMaskFolder[p] = Reflect.field(cur,p);
							}
							bitMaskFolder._subProxy = "bitmask";
							bitMaskFolder._value = curVal;
						}
					} else {
						if(!Object.prototype.hasOwnProperty.call(cur,"step")) {
							cur.step = 1;
						}
						if(typeStr == "UInt" && !Object.prototype.hasOwnProperty.call(cur,"min")) {
							cur.min = 0;
						}
						fieldHash[f.name] = cur;
						cur._isLeaf = true;
					}
				} else {
					if(dat_gui_DatUtil.DEFAULT_FLOAT_STEP > 0 && !Object.prototype.hasOwnProperty.call(cur,"step")) {
						cur.step = dat_gui_DatUtil.DEFAULT_FLOAT_STEP;
					}
					fieldHash[f.name] = cur;
					cur._isLeaf = true;
				}
			} else if(typeStr == "String") {
				if(curVal == null) {
					curVal = "";
				}
				cur.value = curVal;
				fieldHash[f.name] = cur;
				cur._isLeaf = true;
			} else if(typeStr == "Bool") {
				if(curVal == null) {
					curVal = false;
				}
				cur.value = curVal;
				fieldHash[f.name] = cur;
				cur._isLeaf = true;
			} else {
				var field1 = f.name;
				var tmp2;
				var tryInstance;
				if(instance == null) {
					tryInstance = null;
				} else {
					var tmp3;
					if(instance.__properties__) {
						tmp2 = instance.__properties__["get_" + field1];
						tmp3 = tmp2;
					} else {
						tmp3 = false;
					}
					if(tmp3) {
						tryInstance = instance[tmp2]();
					} else {
						tryInstance = instance[field1];
					}
				}
				var instanceAvailable = true;
				if(tryInstance == null) {
					instanceAvailable = false;
					tryInstance = Type.createInstance(Type.resolveClass(typeStr),[]);
				}
				var nested;
				nested = dat_gui_DatUtil.setup(tryInstance,Type.resolveClass(typeStr),f.type,(dotPath != ""?dotPath + ".":"") + f.name);
				fieldHash[f.name] = nested;
				var _g3 = 0;
				var _g12 = Reflect.fields(cur);
				while(_g3 < _g12.length) {
					var p1 = _g12[_g3];
					++_g3;
					if(p1.charAt(0) != "_") {
						continue;
					}
					nested[p1] = Reflect.field(cur,p1);
				}
				nested._folded = instanceAvailable?false:true;
				nested._classes = Object.prototype.hasOwnProperty.call(cur,"_classes")?dat_gui_DatUtil._concatDyn(["instance"],Reflect.field(cur,"_classes")):["instance"];
			}
			if(Object.prototype.hasOwnProperty.call(fieldMeta,"range")) {
				frParams = Reflect.field(fieldMeta,"range");
				if(frParams != null && frParams.length > 0) {
					frValue = frParams[0];
					if(typeof(frValue) == "string") {
						var frEnum = { };
						var min = 1e20;
						var max = -1e20;
						frStatics = new _$List_ListIterator(rtti.statics.h);
						var _g4 = frStatics;
						while(_g4.head != null) {
							var val2 = _g4.head.item;
							_g4.head = _g4.head.next;
							var f2 = val2;
							frI = f2.name.indexOf("_");
							if(frI >= 0) {
								frPrefix = f2.name.substring(0,frI);
								if(frPrefix == frValue) {
									var v = Reflect.field(classe,f2.name);
									if(v > max) {
										max = v;
									}
									if(v < min) {
										min = v;
									}
									frEnum[f2.name.substring(frI + 1)] = v;
								}
							}
						}
						cur.enumeration = frEnum;
						cur.min = min;
						cur.max = max;
					} else {
						cur.min = Object.prototype.hasOwnProperty.call(frValue,"min")?Reflect.field(frValue,"min"):0;
						cur.max = Object.prototype.hasOwnProperty.call(frValue,"max")?Reflect.field(frValue,"max"):Reflect.field(frValue,"min") + 1;
					}
				}
			}
			if(Object.prototype.hasOwnProperty.call(fieldMeta,"choices")) {
				frParams = Reflect.field(fieldMeta,"choices");
				if(frParams != null && frParams.length > 0) {
					frValue = frParams[0];
					if(typeof(frValue) == "string") {
						var frChoices = { };
						frStatics = new _$List_ListIterator(rtti.statics.h);
						var _g5 = frStatics;
						while(_g5.head != null) {
							var val3 = _g5.head.item;
							_g5.head = _g5.head.next;
							var f3 = val3;
							frI = f3.name.indexOf("_");
							if(frI >= 0) {
								frPrefix = f3.name.substring(0,frI);
								if(frPrefix == frValue) {
									frChoices[f3.name.substring(frI + 1)] = Reflect.field(classe,f3.name);
								}
							}
						}
						cur.choices = frChoices;
					} else {
						cur.choices = frValue;
					}
				}
			}
		} else if(!isVar && fieldMeta != null && Object.prototype.hasOwnProperty.call(fieldMeta,"inspect")) {
			cur = Reflect.field(fieldMeta,"inspect");
			if(cur == null) {
				cur = [];
			} else {
				cur = cur[0];
				if(!((cur instanceof Array) && cur.__enum__ == null)) {
					cur = [cur];
				}
			}
			var _g6 = f.type;
			if(_g6[1] == 4) {
				var ret = _g6[3];
				if(funcFolder == null) {
					funcFolder = { };
				}
				var funcDep = { meta : { }, instance : { }, fields : new List()};
				var count = 0;
				var _g_head1 = _g6[2].h;
				while(_g_head1 != null) {
					var val4 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var funcArg = val4;
					funcDep.fields.add({ name : funcArg.name, type : funcArg.t, isPublic : true, isOverride : false, doc : null, get : null, set : null, params : null, platforms : null, meta : null, line : null, overloads : null, expr : null});
					var paramsObj = count < cur.length?cur[count]:{ };
					var newObj = { inspect : null};
					var _g7 = 0;
					var _g13 = Reflect.fields(paramsObj);
					while(_g7 < _g13.length) {
						var r = _g13[_g7];
						++_g7;
						newObj[r] = [Reflect.field(paramsObj,r)];
					}
					funcDep.meta[funcArg.name] = newObj;
					funcDep.instance[funcArg.name] = funcArg.opt?dat_gui_DatUtil.parseOptStringParam(funcArg.value,haxe_rtti_CTypeTools.toString(funcArg.t),classe):dat_gui_DatUtil.parseDefaultTypeParamValue(haxe_rtti_CTypeTools.toString(funcArg.t),classe);
					++count;
				}
				funcFolder[f.name] = funcDep;
			}
		}
	}
	if(funcFolder != null) {
		fieldHash._functions = funcFolder;
	}
	fieldHash._dotPath = dotPath;
	fieldHash._hxclass = Type.getClassName(classe);
	return fieldHash;
};
dat_gui_DatUtil.parseOptStringParam = function(str,type,classe) {
	switch(type) {
	case "Bool":
		if(str == "true") {
			return true;
		} else if(str == "false") {
			return false;
		} else {
			return Reflect.field(classe,str);
		}
		break;
	case "Float":
		var f = parseFloat(str);
		if(!isNaN(f)) {
			return parseFloat(str);
		} else {
			return Reflect.field(classe,str);
		}
		break;
	case "Int":
		var f1 = parseFloat(str);
		if(!isNaN(f1)) {
			return parseFloat(str) | 0;
		} else {
			return Reflect.field(classe,str);
		}
		break;
	case "String":
		if(str.charAt(0) == "\"" || str.charAt(0) == "'") {
			return str.substring(1,str.length - 1);
		} else {
			return Reflect.field(classe,str);
		}
		break;
	case "UInt":
		var f2 = Std.parseInt(str);
		if(!isNaN(f2)) {
			return Std.parseInt(str);
		} else {
			return Reflect.field(classe,str);
		}
		break;
	default:
		return null;
	}
};
dat_gui_DatUtil.parseDefaultTypeParamValue = function(type,classe) {
	switch(type) {
	case "Bool":
		return false;
	case "Float":
		return 0;
	case "Int":
		return 0;
	case "String":
		return "";
	case "UInt":
		return 0;
	default:
		return Type.createEmptyInstance(classe);
	}
};
dat_gui_DatUtil.getDummyClassFieldForFuncParam = function(name,type) {
	return { name : name, type : type, isPublic : true, isOverride : false, doc : null, get : null, set : null, params : null, platforms : null, meta : null, line : null, overloads : null, expr : null};
};
dat_gui_DatUtil.callMethod = function(scope,func,params,funcDep) {
	var arr = [];
	var _g_head = funcDep.fields.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		arr.push(Reflect.field(params,val.name));
	}
	return func.apply(scope,arr);
};
dat_gui_DatUtil.callInstanceMethodWithPacket = function(instance,funcCallPacket) {
	return dat_gui_DatUtil.callMethod(instance,Reflect.field(instance,funcCallPacket.name),funcCallPacket.params,funcCallPacket.func);
};
dat_gui_DatUtil.setupGUIForFunctionCall = function(folder,p,handler,func,instance,classe,options,guiOptions) {
	var guiGlueMethod = window.guiGlueRender;
	var guiSetup = dat_gui_DatUtil.setup(instance,classe,options,"",func);
	var untypedGUI = guiGlueMethod(guiSetup,null,null,folder);
	var str = "";
	var i = func.fields.length;
	while(--i > -1) str += ".";
	var packet = { handler : handler, params : untypedGUI._guiGlueParams, func : func, guiGlue : untypedGUI._guiGlue, name : p};
	folder.add(packet,"handler").name("Execute(" + str + ")");
	return null;
};
dat_gui_DatUtil.createFunctionLibraryForGUI = function(gui,funcGuiMap,instance,classe,options,guiOptions) {
	var funcMap = { };
	var handler = options != null && Object.prototype.hasOwnProperty.call(options,"handler")?Reflect.field(options,"handler"):dat_gui_DatUtil.emptyFunction;
	var _g = 0;
	var _g1 = Reflect.fields(funcGuiMap);
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var func = Reflect.field(funcGuiMap,p);
		var folder = gui.addFolder(p);
		folder.close();
		var untypedGUI = window.guiGlueRender(dat_gui_DatUtil.setup(instance,classe,options,"",func),null,null,folder);
		var str = "";
		var i = func.fields.length;
		while(--i > -1) str += ".";
		folder.add({ handler : handler, params : untypedGUI._guiGlueParams, func : func, guiGlue : untypedGUI._guiGlue, name : p},"handler").name("Execute(" + str + ")");
		funcMap[p] = null;
	}
	return funcMap;
};
dat_gui_DatUtil.createFunctionButtonsForGUI = function(gui,funcGuiMap,instance,classe,options,guiOptions) {
	var guiGlueMethod = window.guiGlueRender;
	var funcMap = { };
	var handler = options != null && Object.prototype.hasOwnProperty.call(options,"handler")?Reflect.field(options,"handler"):dat_gui_DatUtil.emptyFunction;
	var _g = 0;
	var _g1 = Reflect.fields(funcGuiMap);
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var func = Reflect.field(funcGuiMap,p);
		var trigger = { handler : handler, func : func, name : p};
		funcMap[p] = trigger;
		gui.add(trigger,"handler").name(p + "(" + (func.fields.length > 0?"...":"") + ")");
	}
	return funcMap;
};
dat_gui_DatUtil.emptyFunction = function() {
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = ["haxe","IMap"];
haxe_IMap.prototype = {
	get: null
	,keys: null
	,__class__: haxe_IMap
};
var haxe_Utf8 = function(size) {
	this.__b = "";
};
$hxClasses["haxe.Utf8"] = haxe_Utf8;
haxe_Utf8.__name__ = ["haxe","Utf8"];
haxe_Utf8.prototype = {
	__b: null
	,__class__: haxe_Utf8
};
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = ["haxe","ds","ArraySort"];
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g1 = from + 1;
		while(_g1 < to) {
			var j = _g1++;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	var new_mid;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	var n;
	if(from == mid || mid == to) {
		return;
	}
	n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = ["haxe","ds","IntMap"];
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	h: null
	,get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = ["haxe","ds","StringMap"];
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	h: null
	,rh: null
	,get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_rtti_CType = { __ename__ : true, __constructs__ : ["CUnknown","CEnum","CClass","CTypedef","CFunction","CAnonymous","CDynamic","CAbstract"] };
haxe_rtti_CType.CUnknown = ["CUnknown",0];
haxe_rtti_CType.CUnknown.toString = $estr;
haxe_rtti_CType.CUnknown.__enum__ = haxe_rtti_CType;
haxe_rtti_CType.CEnum = function(name,params) { var $x = ["CEnum",1,name,params]; $x.__enum__ = haxe_rtti_CType; $x.toString = $estr; return $x; };
haxe_rtti_CType.CClass = function(name,params) { var $x = ["CClass",2,name,params]; $x.__enum__ = haxe_rtti_CType; $x.toString = $estr; return $x; };
haxe_rtti_CType.CTypedef = function(name,params) { var $x = ["CTypedef",3,name,params]; $x.__enum__ = haxe_rtti_CType; $x.toString = $estr; return $x; };
haxe_rtti_CType.CFunction = function(args,ret) { var $x = ["CFunction",4,args,ret]; $x.__enum__ = haxe_rtti_CType; $x.toString = $estr; return $x; };
haxe_rtti_CType.CAnonymous = function(fields) { var $x = ["CAnonymous",5,fields]; $x.__enum__ = haxe_rtti_CType; $x.toString = $estr; return $x; };
haxe_rtti_CType.CDynamic = function(t) { var $x = ["CDynamic",6,t]; $x.__enum__ = haxe_rtti_CType; $x.toString = $estr; return $x; };
haxe_rtti_CType.CAbstract = function(name,params) { var $x = ["CAbstract",7,name,params]; $x.__enum__ = haxe_rtti_CType; $x.toString = $estr; return $x; };
var haxe_rtti_Rights = { __ename__ : true, __constructs__ : ["RNormal","RNo","RCall","RMethod","RDynamic","RInline"] };
haxe_rtti_Rights.RNormal = ["RNormal",0];
haxe_rtti_Rights.RNormal.toString = $estr;
haxe_rtti_Rights.RNormal.__enum__ = haxe_rtti_Rights;
haxe_rtti_Rights.RNo = ["RNo",1];
haxe_rtti_Rights.RNo.toString = $estr;
haxe_rtti_Rights.RNo.__enum__ = haxe_rtti_Rights;
haxe_rtti_Rights.RCall = function(m) { var $x = ["RCall",2,m]; $x.__enum__ = haxe_rtti_Rights; $x.toString = $estr; return $x; };
haxe_rtti_Rights.RMethod = ["RMethod",3];
haxe_rtti_Rights.RMethod.toString = $estr;
haxe_rtti_Rights.RMethod.__enum__ = haxe_rtti_Rights;
haxe_rtti_Rights.RDynamic = ["RDynamic",4];
haxe_rtti_Rights.RDynamic.toString = $estr;
haxe_rtti_Rights.RDynamic.__enum__ = haxe_rtti_Rights;
haxe_rtti_Rights.RInline = ["RInline",5];
haxe_rtti_Rights.RInline.toString = $estr;
haxe_rtti_Rights.RInline.__enum__ = haxe_rtti_Rights;
var haxe_rtti_TypeTree = { __ename__ : true, __constructs__ : ["TPackage","TClassdecl","TEnumdecl","TTypedecl","TAbstractdecl"] };
haxe_rtti_TypeTree.TPackage = function(name,full,subs) { var $x = ["TPackage",0,name,full,subs]; $x.__enum__ = haxe_rtti_TypeTree; $x.toString = $estr; return $x; };
haxe_rtti_TypeTree.TClassdecl = function(c) { var $x = ["TClassdecl",1,c]; $x.__enum__ = haxe_rtti_TypeTree; $x.toString = $estr; return $x; };
haxe_rtti_TypeTree.TEnumdecl = function(e) { var $x = ["TEnumdecl",2,e]; $x.__enum__ = haxe_rtti_TypeTree; $x.toString = $estr; return $x; };
haxe_rtti_TypeTree.TTypedecl = function(t) { var $x = ["TTypedecl",3,t]; $x.__enum__ = haxe_rtti_TypeTree; $x.toString = $estr; return $x; };
haxe_rtti_TypeTree.TAbstractdecl = function(a) { var $x = ["TAbstractdecl",4,a]; $x.__enum__ = haxe_rtti_TypeTree; $x.toString = $estr; return $x; };
var haxe_rtti_TypeApi = function() { };
$hxClasses["haxe.rtti.TypeApi"] = haxe_rtti_TypeApi;
haxe_rtti_TypeApi.__name__ = ["haxe","rtti","TypeApi"];
haxe_rtti_TypeApi.isVar = function(t) {
	if(t[1] == 4) {
		return false;
	} else {
		return true;
	}
};
var haxe_rtti_CTypeTools = function() { };
$hxClasses["haxe.rtti.CTypeTools"] = haxe_rtti_CTypeTools;
haxe_rtti_CTypeTools.__name__ = ["haxe","rtti","CTypeTools"];
haxe_rtti_CTypeTools.toString = function(t) {
	switch(t[1]) {
	case 0:
		return "unknown";
	case 1:
		return haxe_rtti_CTypeTools.nameWithParams(t[2],t[3]);
	case 2:
		return haxe_rtti_CTypeTools.nameWithParams(t[2],t[3]);
	case 3:
		return haxe_rtti_CTypeTools.nameWithParams(t[2],t[3]);
	case 4:
		var ret = t[3];
		var args = t[2];
		if(args.length == 0) {
			return "Void -> " + haxe_rtti_CTypeTools.toString(ret);
		} else {
			return args.map(haxe_rtti_CTypeTools.functionArgumentName).join(" -> ") + " -> " + haxe_rtti_CTypeTools.toString(ret);
		}
		break;
	case 5:
		return "{ " + t[2].map(haxe_rtti_CTypeTools.classField).join(", ");
	case 6:
		var d = t[2];
		if(d == null) {
			return "Dynamic";
		} else {
			return "Dynamic<" + haxe_rtti_CTypeTools.toString(d) + ">";
		}
		break;
	case 7:
		return haxe_rtti_CTypeTools.nameWithParams(t[2],t[3]);
	}
};
haxe_rtti_CTypeTools.nameWithParams = function(name,params) {
	if(params.length == 0) {
		return name;
	}
	return name + "<" + params.map(haxe_rtti_CTypeTools.toString).join(", ") + ">";
};
haxe_rtti_CTypeTools.functionArgumentName = function(arg) {
	return (arg.opt?"?":"") + (arg.name == ""?"":arg.name + ":") + haxe_rtti_CTypeTools.toString(arg.t) + (arg.value == null?"":" = " + arg.value);
};
haxe_rtti_CTypeTools.classField = function(cf) {
	return cf.name + ":" + haxe_rtti_CTypeTools.toString(cf.type);
};
var haxe_rtti_Meta = function() { };
$hxClasses["haxe.rtti.Meta"] = haxe_rtti_Meta;
haxe_rtti_Meta.__name__ = ["haxe","rtti","Meta"];
haxe_rtti_Meta.getMeta = function(t) {
	return t.__meta__;
};
haxe_rtti_Meta.getStatics = function(t) {
	var meta = haxe_rtti_Meta.getMeta(t);
	if(meta == null || meta.statics == null) {
		return { };
	} else {
		return meta.statics;
	}
};
haxe_rtti_Meta.getFields = function(t) {
	var meta = haxe_rtti_Meta.getMeta(t);
	if(meta == null || meta.fields == null) {
		return { };
	} else {
		return meta.fields;
	}
};
var haxe_rtti_Rtti = function() { };
$hxClasses["haxe.rtti.Rtti"] = haxe_rtti_Rtti;
haxe_rtti_Rtti.__name__ = ["haxe","rtti","Rtti"];
haxe_rtti_Rtti.getRtti = function(c) {
	var rtti = Reflect.field(c,"__rtti");
	if(rtti == null) {
		throw new js__$Boot_HaxeError("Class " + Type.getClassName(c) + " has no RTTI information, consider adding @:rtti");
	}
	var x = Xml.parse(rtti).firstElement();
	var infos = new haxe_rtti_XmlParser().processElement(x);
	if(infos[1] == 1) {
		return infos[2];
	} else {
		throw new js__$Boot_HaxeError("Enum mismatch: expected TClassDecl but found " + Std.string(infos));
	}
};
var haxe_rtti_XmlParser = function() {
	this.root = [];
};
$hxClasses["haxe.rtti.XmlParser"] = haxe_rtti_XmlParser;
haxe_rtti_XmlParser.__name__ = ["haxe","rtti","XmlParser"];
haxe_rtti_XmlParser.prototype = {
	root: null
	,curplatform: null
	,mkPath: function(p) {
		return p;
	}
	,mkTypeParams: function(p) {
		var pl = p.split(":");
		if(pl[0] == "") {
			return [];
		}
		return pl;
	}
	,mkRights: function(r) {
		switch(r) {
		case "dynamic":
			return haxe_rtti_Rights.RDynamic;
		case "inline":
			return haxe_rtti_Rights.RInline;
		case "method":
			return haxe_rtti_Rights.RMethod;
		case "null":
			return haxe_rtti_Rights.RNo;
		default:
			return haxe_rtti_Rights.RCall(r);
		}
	}
	,xerror: function(c) {
		throw new js__$Boot_HaxeError("Invalid " + c.get_name());
	}
	,processElement: function(x) {
		var c = new haxe_xml_Fast(x);
		switch(c.get_name()) {
		case "abstract":
			return haxe_rtti_TypeTree.TAbstractdecl(this.xabstract(c));
		case "class":
			return haxe_rtti_TypeTree.TClassdecl(this.xclass(c));
		case "enum":
			return haxe_rtti_TypeTree.TEnumdecl(this.xenum(c));
		case "typedef":
			return haxe_rtti_TypeTree.TTypedecl(this.xtypedef(c));
		default:
			return this.xerror(c);
		}
	}
	,xmeta: function(x) {
		var ml = [];
		var _g_head = x.nodes.resolve("m").h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var pl = [];
			var _g_head1 = val.nodes.resolve("e").h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				pl.push(val1.get_innerHTML());
			}
			ml.push({ name : val.att.resolve("n"), params : pl});
		}
		return ml;
	}
	,xoverloads: function(x) {
		var l = new List();
		var tmp = x.get_elements();
		while(tmp.hasNext()) l.add(this.xclassfield(tmp.next()));
		return l;
	}
	,xpath: function(x) {
		var path = this.mkPath(x.att.resolve("path"));
		var params = new List();
		var tmp = x.get_elements();
		while(tmp.hasNext()) params.add(this.xtype(tmp.next()));
		return { path : path, params : params};
	}
	,xclass: function(x) {
		var csuper = null;
		var doc = null;
		var tdynamic = null;
		var interfaces = new List();
		var fields = new List();
		var statics = new List();
		var meta = [];
		var tmp = x.get_elements();
		while(tmp.hasNext()) {
			var c = tmp.next();
			switch(c.get_name()) {
			case "extends":
				csuper = this.xpath(c);
				break;
			case "haxe_doc":
				doc = c.get_innerData();
				break;
			case "haxe_dynamic":
				tdynamic = this.xtype(new haxe_xml_Fast(c.x.firstElement()));
				break;
			case "implements":
				interfaces.add(this.xpath(c));
				break;
			case "meta":
				meta = this.xmeta(c);
				break;
			default:
				if(c.x.exists("static")) {
					statics.add(this.xclassfield(c));
				} else {
					fields.add(this.xclassfield(c));
				}
			}
		}
		return { file : x.has.resolve("file")?x.att.resolve("file"):null, path : this.mkPath(x.att.resolve("path")), module : x.has.resolve("module")?this.mkPath(x.att.resolve("module")):null, doc : doc, isPrivate : x.x.exists("private"), isExtern : x.x.exists("extern"), isInterface : x.x.exists("interface"), params : this.mkTypeParams(x.att.resolve("params")), superClass : csuper, interfaces : interfaces, fields : fields, statics : statics, tdynamic : tdynamic, platforms : this.defplat(), meta : meta};
	}
	,xclassfield: function(x,defPublic) {
		if(defPublic == null) {
			defPublic = false;
		}
		var e = x.get_elements();
		var t = this.xtype(e.next());
		var doc = null;
		var meta = [];
		var overloads = null;
		while(e.hasNext()) {
			var c = e.next();
			switch(c.get_name()) {
			case "haxe_doc":
				doc = c.get_innerData();
				break;
			case "meta":
				meta = this.xmeta(c);
				break;
			case "overloads":
				overloads = this.xoverloads(c);
				break;
			default:
				this.xerror(c);
			}
		}
		return { name : x.get_name(), type : t, isPublic : x.x.exists("public") || defPublic, isOverride : x.x.exists("override"), line : x.has.resolve("line")?Std.parseInt(x.att.resolve("line")):null, doc : doc, get : x.has.resolve("get")?this.mkRights(x.att.resolve("get")):haxe_rtti_Rights.RNormal, set : x.has.resolve("set")?this.mkRights(x.att.resolve("set")):haxe_rtti_Rights.RNormal, params : x.has.resolve("params")?this.mkTypeParams(x.att.resolve("params")):[], platforms : this.defplat(), meta : meta, overloads : overloads, expr : x.has.resolve("expr")?x.att.resolve("expr"):null};
	}
	,xenum: function(x) {
		var cl = new List();
		var doc = null;
		var meta = [];
		var tmp = x.get_elements();
		while(tmp.hasNext()) {
			var c = tmp.next();
			if(c.get_name() == "haxe_doc") {
				doc = c.get_innerData();
			} else if(c.get_name() == "meta") {
				meta = this.xmeta(c);
			} else {
				cl.add(this.xenumfield(c));
			}
		}
		return { file : x.has.resolve("file")?x.att.resolve("file"):null, path : this.mkPath(x.att.resolve("path")), module : x.has.resolve("module")?this.mkPath(x.att.resolve("module")):null, doc : doc, isPrivate : x.x.exists("private"), isExtern : x.x.exists("extern"), params : this.mkTypeParams(x.att.resolve("params")), constructors : cl, platforms : this.defplat(), meta : meta};
	}
	,xenumfield: function(x) {
		var args = null;
		var xdoc = x.x.elementsNamed("haxe_doc").next();
		var meta = x.hasNode.resolve("meta")?this.xmeta(x.node.resolve("meta")):[];
		if(x.has.resolve("a")) {
			var names = x.att.resolve("a").split(":");
			var elts = x.get_elements();
			args = new List();
			var _g = 0;
			while(_g < names.length) {
				var c = names[_g];
				++_g;
				var opt = false;
				if(c.charAt(0) == "?") {
					opt = true;
					c = HxOverrides.substr(c,1,null);
				}
				args.add({ name : c, opt : opt, t : this.xtype(elts.next())});
			}
		}
		return { name : x.get_name(), args : args, doc : xdoc == null?null:new haxe_xml_Fast(xdoc).get_innerData(), meta : meta, platforms : this.defplat()};
	}
	,xabstract: function(x) {
		var doc = null;
		var impl = null;
		var athis = null;
		var meta = [];
		var to = [];
		var from = [];
		var tmp = x.get_elements();
		while(tmp.hasNext()) {
			var c = tmp.next();
			switch(c.get_name()) {
			case "from":
				var tmp1 = c.get_elements();
				while(tmp1.hasNext()) {
					var t = tmp1.next();
					from.push({ t : this.xtype(new haxe_xml_Fast(t.x.firstElement())), field : t.has.resolve("field")?t.att.resolve("field"):null});
				}
				break;
			case "haxe_doc":
				doc = c.get_innerData();
				break;
			case "impl":
				impl = this.xclass(c.node.resolve("class"));
				break;
			case "meta":
				meta = this.xmeta(c);
				break;
			case "this":
				athis = this.xtype(new haxe_xml_Fast(c.x.firstElement()));
				break;
			case "to":
				var tmp2 = c.get_elements();
				while(tmp2.hasNext()) {
					var t1 = tmp2.next();
					to.push({ t : this.xtype(new haxe_xml_Fast(t1.x.firstElement())), field : t1.has.resolve("field")?t1.att.resolve("field"):null});
				}
				break;
			default:
				this.xerror(c);
			}
		}
		return { file : x.has.resolve("file")?x.att.resolve("file"):null, path : this.mkPath(x.att.resolve("path")), module : x.has.resolve("module")?this.mkPath(x.att.resolve("module")):null, doc : doc, isPrivate : x.x.exists("private"), params : this.mkTypeParams(x.att.resolve("params")), platforms : this.defplat(), meta : meta, athis : athis, to : to, from : from, impl : impl};
	}
	,xtypedef: function(x) {
		var doc = null;
		var t = null;
		var meta = [];
		var tmp = x.get_elements();
		while(tmp.hasNext()) {
			var c = tmp.next();
			if(c.get_name() == "haxe_doc") {
				doc = c.get_innerData();
			} else if(c.get_name() == "meta") {
				meta = this.xmeta(c);
			} else {
				t = this.xtype(c);
			}
		}
		var types = new haxe_ds_StringMap();
		if(this.curplatform != null) {
			var key = this.curplatform;
			if(__map_reserved[key] != null) {
				types.setReserved(key,t);
			} else {
				types.h[key] = t;
			}
		}
		return { file : x.has.resolve("file")?x.att.resolve("file"):null, path : this.mkPath(x.att.resolve("path")), module : x.has.resolve("module")?this.mkPath(x.att.resolve("module")):null, doc : doc, isPrivate : x.x.exists("private"), params : this.mkTypeParams(x.att.resolve("params")), type : t, types : types, platforms : this.defplat(), meta : meta};
	}
	,xtype: function(x) {
		switch(x.get_name()) {
		case "a":
			var fields = new List();
			var tmp = x.get_elements();
			while(tmp.hasNext()) {
				var f = this.xclassfield(tmp.next(),true);
				f.platforms = new List();
				fields.add(f);
			}
			return haxe_rtti_CType.CAnonymous(fields);
		case "c":
			return haxe_rtti_CType.CClass(this.mkPath(x.att.resolve("path")),this.xtypeparams(x));
		case "d":
			var t = null;
			var tx = x.x.firstElement();
			if(tx != null) {
				t = this.xtype(new haxe_xml_Fast(tx));
			}
			return haxe_rtti_CType.CDynamic(t);
		case "e":
			return haxe_rtti_CType.CEnum(this.mkPath(x.att.resolve("path")),this.xtypeparams(x));
		case "f":
			var args = new List();
			var eargs = HxOverrides.iter(x.att.resolve("a").split(":"));
			var evalues = x.has.resolve("v")?HxOverrides.iter(x.att.resolve("v").split(":")):null;
			var tmp1 = x.get_elements();
			while(tmp1.hasNext()) {
				var e = tmp1.next();
				var opt = false;
				var a = eargs.next();
				if(a == null) {
					a = "";
				}
				if(a.charAt(0) == "?") {
					opt = true;
					a = HxOverrides.substr(a,1,null);
				}
				var v = evalues == null?null:evalues.next();
				args.add({ name : a, opt : opt, t : this.xtype(e), value : v == ""?null:v});
			}
			var ret = args.last();
			args.remove(ret);
			return haxe_rtti_CType.CFunction(args,ret.t);
		case "t":
			return haxe_rtti_CType.CTypedef(this.mkPath(x.att.resolve("path")),this.xtypeparams(x));
		case "unknown":
			return haxe_rtti_CType.CUnknown;
		case "x":
			return haxe_rtti_CType.CAbstract(this.mkPath(x.att.resolve("path")),this.xtypeparams(x));
		default:
			return this.xerror(x);
		}
	}
	,xtypeparams: function(x) {
		var p = new List();
		var tmp = x.get_elements();
		while(tmp.hasNext()) p.add(this.xtype(tmp.next()));
		return p;
	}
	,defplat: function() {
		var l = new List();
		if(this.curplatform != null) {
			l.add(this.curplatform);
		}
		return l;
	}
	,__class__: haxe_rtti_XmlParser
};
var haxe_xml__$Fast_NodeAccess = function(x) {
	this.__x = x;
};
$hxClasses["haxe.xml._Fast.NodeAccess"] = haxe_xml__$Fast_NodeAccess;
haxe_xml__$Fast_NodeAccess.__name__ = ["haxe","xml","_Fast","NodeAccess"];
haxe_xml__$Fast_NodeAccess.prototype = {
	__x: null
	,resolve: function(name) {
		var x = this.__x.elementsNamed(name).next();
		if(x == null) {
			var xname;
			if(this.__x.nodeType == Xml.Document) {
				xname = "Document";
			} else {
				var _this = this.__x;
				if(_this.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + _this.nodeType);
				}
				xname = _this.nodeName;
			}
			throw new js__$Boot_HaxeError(xname + " is missing element " + name);
		}
		return new haxe_xml_Fast(x);
	}
	,__class__: haxe_xml__$Fast_NodeAccess
};
var haxe_xml__$Fast_AttribAccess = function(x) {
	this.__x = x;
};
$hxClasses["haxe.xml._Fast.AttribAccess"] = haxe_xml__$Fast_AttribAccess;
haxe_xml__$Fast_AttribAccess.__name__ = ["haxe","xml","_Fast","AttribAccess"];
haxe_xml__$Fast_AttribAccess.prototype = {
	__x: null
	,resolve: function(name) {
		if(this.__x.nodeType == Xml.Document) {
			throw new js__$Boot_HaxeError("Cannot access document attribute " + name);
		}
		var v = this.__x.get(name);
		if(v == null) {
			var _this = this.__x;
			if(_this.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + _this.nodeType);
			}
			throw new js__$Boot_HaxeError(_this.nodeName + " is missing attribute " + name);
		}
		return v;
	}
	,__class__: haxe_xml__$Fast_AttribAccess
};
var haxe_xml__$Fast_HasAttribAccess = function(x) {
	this.__x = x;
};
$hxClasses["haxe.xml._Fast.HasAttribAccess"] = haxe_xml__$Fast_HasAttribAccess;
haxe_xml__$Fast_HasAttribAccess.__name__ = ["haxe","xml","_Fast","HasAttribAccess"];
haxe_xml__$Fast_HasAttribAccess.prototype = {
	__x: null
	,resolve: function(name) {
		if(this.__x.nodeType == Xml.Document) {
			throw new js__$Boot_HaxeError("Cannot access document attribute " + name);
		}
		return this.__x.exists(name);
	}
	,__class__: haxe_xml__$Fast_HasAttribAccess
};
var haxe_xml__$Fast_HasNodeAccess = function(x) {
	this.__x = x;
};
$hxClasses["haxe.xml._Fast.HasNodeAccess"] = haxe_xml__$Fast_HasNodeAccess;
haxe_xml__$Fast_HasNodeAccess.__name__ = ["haxe","xml","_Fast","HasNodeAccess"];
haxe_xml__$Fast_HasNodeAccess.prototype = {
	__x: null
	,resolve: function(name) {
		return this.__x.elementsNamed(name).hasNext();
	}
	,__class__: haxe_xml__$Fast_HasNodeAccess
};
var haxe_xml__$Fast_NodeListAccess = function(x) {
	this.__x = x;
};
$hxClasses["haxe.xml._Fast.NodeListAccess"] = haxe_xml__$Fast_NodeListAccess;
haxe_xml__$Fast_NodeListAccess.__name__ = ["haxe","xml","_Fast","NodeListAccess"];
haxe_xml__$Fast_NodeListAccess.prototype = {
	__x: null
	,resolve: function(name) {
		var l = new List();
		var tmp = this.__x.elementsNamed(name);
		while(tmp.hasNext()) l.add(new haxe_xml_Fast(tmp.next()));
		return l;
	}
	,__class__: haxe_xml__$Fast_NodeListAccess
};
var haxe_xml_Fast = function(x) {
	if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
		throw new js__$Boot_HaxeError("Invalid nodeType " + x.nodeType);
	}
	this.x = x;
	this.node = new haxe_xml__$Fast_NodeAccess(x);
	this.nodes = new haxe_xml__$Fast_NodeListAccess(x);
	this.att = new haxe_xml__$Fast_AttribAccess(x);
	this.has = new haxe_xml__$Fast_HasAttribAccess(x);
	this.hasNode = new haxe_xml__$Fast_HasNodeAccess(x);
};
$hxClasses["haxe.xml.Fast"] = haxe_xml_Fast;
haxe_xml_Fast.__name__ = ["haxe","xml","Fast"];
haxe_xml_Fast.prototype = {
	x: null
	,node: null
	,nodes: null
	,att: null
	,has: null
	,hasNode: null
	,get_name: function() {
		if(this.x.nodeType == Xml.Document) {
			return "Document";
		} else {
			var _this = this.x;
			if(_this.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + _this.nodeType);
			}
			return _this.nodeName;
		}
	}
	,get_innerData: function() {
		var _this = this.x;
		if(_this.nodeType != Xml.Document && _this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + _this.nodeType);
		}
		var it = HxOverrides.iter(_this.children);
		if(!it.hasNext()) {
			throw new js__$Boot_HaxeError(this.get_name() + " does not have data");
		}
		var v = it.next();
		var n = it.next();
		if(n != null) {
			var tmp;
			if(v.nodeType == Xml.PCData && n.nodeType == Xml.CData) {
				if(v.nodeType == Xml.Document || v.nodeType == Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, unexpected " + v.nodeType);
				}
				tmp = StringTools.trim(v.nodeValue) == "";
			} else {
				tmp = false;
			}
			if(tmp) {
				var n2 = it.next();
				var tmp1;
				if(n2 != null) {
					var tmp2;
					if(n2.nodeType == Xml.PCData) {
						if(n2.nodeType == Xml.Document || n2.nodeType == Xml.Element) {
							throw new js__$Boot_HaxeError("Bad node type, unexpected " + n2.nodeType);
						}
						tmp2 = StringTools.trim(n2.nodeValue) == "";
					} else {
						tmp2 = false;
					}
					if(tmp2) {
						tmp1 = it.next() == null;
					} else {
						tmp1 = false;
					}
				} else {
					tmp1 = true;
				}
				if(tmp1) {
					if(n.nodeType == Xml.Document || n.nodeType == Xml.Element) {
						throw new js__$Boot_HaxeError("Bad node type, unexpected " + n.nodeType);
					}
					return n.nodeValue;
				}
			}
			throw new js__$Boot_HaxeError(this.get_name() + " does not only have data");
		}
		if(v.nodeType != Xml.PCData && v.nodeType != Xml.CData) {
			throw new js__$Boot_HaxeError(this.get_name() + " does not have data");
		}
		if(v.nodeType == Xml.Document || v.nodeType == Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, unexpected " + v.nodeType);
		}
		return v.nodeValue;
	}
	,get_innerHTML: function() {
		var s_b = "";
		var _this = this.x;
		if(_this.nodeType != Xml.Document && _this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + _this.nodeType);
		}
		var tmp = HxOverrides.iter(_this.children);
		while(tmp.hasNext()) s_b += Std.string(haxe_xml_Printer.print(tmp.next()));
		return s_b;
	}
	,get_elements: function() {
		var it = this.x.elements();
		return { hasNext : $bind(it,it.hasNext), next : function() {
			var x = it.next();
			if(x == null) {
				return null;
			}
			return new haxe_xml_Fast(x);
		}};
	}
	,__class__: haxe_xml_Fast
	,__properties__: {get_elements:"get_elements",get_innerHTML:"get_innerHTML",get_innerData:"get_innerData",get_name:"get_name"}
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g1 = 0;
	while(_g1 < position) {
		var c = xml.charCodeAt(_g1++);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
$hxClasses["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException;
haxe_xml_XmlParserException.__name__ = ["haxe","xml","XmlParserException"];
haxe_xml_XmlParserException.prototype = {
	message: null
	,lineNumber: null
	,positionAtLine: null
	,position: null
	,xml: null
	,toString: function() {
		return Type.getClassName(js_Boot.getClass(this)) + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
$hxClasses["haxe.xml.Parser"] = haxe_xml_Parser;
haxe_xml_Parser.__name__ = ["haxe","xml","Parser"];
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var c = str.charCodeAt(p);
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(c == c) {
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				var tmp;
				if(start == p) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(tmp)) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Duplicate attribute [" + tmp + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCharCode(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + parent.nodeType);
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + parent.nodeType);
					}
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				parent.addChild(Xml.createProcessingInstruction(HxOverrides.substr(str,start + 1,p - start - 2)));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createCData(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					buf.b += String.fromCharCode(s.charCodeAt(1) == 120?Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)):Std.parseInt(HxOverrides.substr(s,1,s.length - 1)));
				} else {
					var _this = haxe_xml_Parser.escapes;
					if(!(__map_reserved[s] != null?_this.existsReserved(s):_this.h.hasOwnProperty(s))) {
						if(strict) {
							throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
						}
						buf.b += Std.string("&" + s + ";");
					} else {
						var _this1 = haxe_xml_Parser.escapes;
						buf.b += Std.string(__map_reserved[s] != null?_this1.getReserved(s):_this1.h[s]);
					}
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCharCode(c),str,p));
				}
				buf.b += "&";
				var len5 = p - start;
				buf.b += len5 == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len5);
				start = p--;
				state = escapeNext;
			}
			break;
		}
		c = str.charCodeAt(++p);
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(p != start || nsubs == 0) {
			var len6 = p - start;
			buf.b += len6 == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len6);
			parent.addChild(Xml.createPCData(buf.b));
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += "&";
		var len7 = p - start;
		buf.b += len7 == null?HxOverrides.substr(str,start,null):HxOverrides.substr(str,start,len7);
		parent.addChild(Xml.createPCData(buf.b));
		return p;
	}
	throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = ["haxe","xml","Printer"];
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	output: null
	,pretty: null
	,writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + value.nodeType);
			}
			this.output.b += Std.string(value.nodeName);
			var tmp = value.attributes();
			while(tmp.hasNext()) {
				var attribute = tmp.next();
				this.output.b += Std.string(" " + attribute + "=\"");
				this.output.b += Std.string(StringTools.htmlEscape(value.get(attribute),true));
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + value.nodeType);
				}
				var tmp1 = HxOverrides.iter(value.children);
				while(tmp1.hasNext()) this.writeNode(tmp1.next(),this.pretty?tabs + "\t":tabs);
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + value.nodeType);
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				this.output.b += Std.string(tabs + StringTools.htmlEscape(nodeValue));
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			this.output.b += Std.string(StringTools.trim(value.nodeValue));
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			var commentContent = value.nodeValue;
			commentContent = commentContent.replace(new RegExp("[\n\r\t]+","g".split("u").join("")),"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null?"null":"" + tabs;
			this.output.b += Std.string(StringTools.trim(commentContent));
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + value.nodeType);
			}
			var tmp2 = HxOverrides.iter(value.children);
			while(tmp2.hasNext()) this.writeNode(tmp2.next(),tabs);
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + value.nodeType);
		}
		var tmp = HxOverrides.iter(value.children);
		while(tmp.hasNext()) {
			var child = tmp.next();
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, unexpected " + child.nodeType);
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = ["js","_Boot","HaxeError"];
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	val: null
	,__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = ["js","Boot"];
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0?",":"") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = intf[_g1++];
			if(i == cl || js_Boot.__interfLoop(i,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class && o.__name__ != null) {
			return true;
		}
		if(cl == Enum && o.__ename__ != null) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var tjson_TJSON = $hx_exports["tjson"]["TJSON"] = function() { };
$hxClasses["tjson.TJSON"] = tjson_TJSON;
tjson_TJSON.__name__ = ["tjson","TJSON"];
tjson_TJSON.parse = function(json,fileName,stringProcessor) {
	if(fileName == null) {
		fileName = "JSON Data";
	}
	return new tjson_TJSONParser(json,fileName,stringProcessor).doParse();
};
tjson_TJSON.encode = function(obj,style,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return new tjson_TJSONEncoder(useCache).doEncode(obj,style);
};
tjson_TJSON.encodeToPlainObject = function(obj,style,useCache) {
	if(useCache == null) {
		useCache = true;
	}
	return tjson_TJSON.parse(tjson_TJSON.encode(obj));
};
var tjson_TJSONParser = function(vjson,vfileName,stringProcessor) {
	if(vfileName == null) {
		vfileName = "JSON Data";
	}
	this.json = vjson;
	this.fileName = vfileName;
	this.currentLine = 1;
	this.lastSymbolQuoted = false;
	this.pos = 0;
	this.floatRegex = new EReg("^-?[0-9]*\\.[0-9]+$","");
	this.intRegex = new EReg("^-?[0-9]+$","");
	this.strProcessor = stringProcessor == null?$bind(this,this.defaultStringProcessor):stringProcessor;
	this.cache = [];
};
$hxClasses["tjson.TJSONParser"] = tjson_TJSONParser;
tjson_TJSONParser.__name__ = ["tjson","TJSONParser"];
tjson_TJSONParser.prototype = {
	pos: null
	,json: null
	,lastSymbolQuoted: null
	,fileName: null
	,currentLine: null
	,cache: null
	,floatRegex: null
	,intRegex: null
	,strProcessor: null
	,doParse: function() {
		try {
			var _g = this.getNextSymbol();
			switch(_g) {
			case "[":
				return this.doArray();
			case "{":
				return this.doObject();
			default:
				return this.convertSymbolToProperType(_g);
			}
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			if( js_Boot.__instanceof(e,String) ) {
				throw new js__$Boot_HaxeError(this.fileName + " on line " + this.currentLine + ": " + e);
			} else throw(e);
		}
	}
	,doObject: function() {
		var o = { };
		var val = "";
		var key;
		var isClassOb = false;
		this.cache.push(o);
		while(this.pos < this.json.length) {
			key = this.getNextSymbol();
			if(key == "," && !this.lastSymbolQuoted) {
				continue;
			}
			if(key == "}" && !this.lastSymbolQuoted) {
				if(isClassOb && o.TJ_unserialize != null) {
					o.TJ_unserialize();
				}
				return o;
			}
			var seperator = this.getNextSymbol();
			if(seperator != ":") {
				throw new js__$Boot_HaxeError("Expected ':' but got '" + seperator + "' instead.");
			}
			var v = this.getNextSymbol();
			if(key == "_hxcls") {
				if(StringTools.startsWith(v,"Date@")) {
					var t = Std.parseInt(HxOverrides.substr(v,5,null));
					o = new Date(t);
				} else {
					var cls = Type.resolveClass(v);
					if(cls == null) {
						cls = eval("window['" + v + "']");
						if(cls == null) {
							throw new js__$Boot_HaxeError("Could not resolve Javascript class - " + v);
						}
					}
					o = Type.createEmptyInstance(cls);
				}
				this.cache.pop();
				this.cache.push(o);
				isClassOb = true;
				continue;
			}
			if(v == "{" && !this.lastSymbolQuoted) {
				val = this.doObject();
			} else if(v == "[" && !this.lastSymbolQuoted) {
				val = this.doArray();
			} else {
				val = this.convertSymbolToProperType(v);
			}
			o[key] = val;
		}
		throw new js__$Boot_HaxeError("Unexpected end of file. Expected '}'");
	}
	,doArray: function() {
		var a = [];
		var val;
		while(this.pos < this.json.length) {
			val = this.getNextSymbol();
			if(val == "," && !this.lastSymbolQuoted) {
				continue;
			} else if(val == "]" && !this.lastSymbolQuoted) {
				return a;
			} else if(val == "{" && !this.lastSymbolQuoted) {
				val = this.doObject();
			} else if(val == "[" && !this.lastSymbolQuoted) {
				val = this.doArray();
			} else {
				val = this.convertSymbolToProperType(val);
			}
			a.push(val);
		}
		throw new js__$Boot_HaxeError("Unexpected end of file. Expected ']'");
	}
	,convertSymbolToProperType: function(symbol) {
		if(this.lastSymbolQuoted) {
			if(StringTools.startsWith(symbol,tjson_TJSON.OBJECT_REFERENCE_PREFIX)) {
				return this.cache[Std.parseInt(HxOverrides.substr(symbol,tjson_TJSON.OBJECT_REFERENCE_PREFIX.length,null))];
			}
			return symbol;
		}
		if(this.looksLikeFloat(symbol)) {
			return parseFloat(symbol);
		}
		if(this.looksLikeInt(symbol)) {
			return Std.parseInt(symbol);
		}
		if(symbol.toLowerCase() == "true") {
			return true;
		}
		if(symbol.toLowerCase() == "false") {
			return false;
		}
		if(symbol.toLowerCase() == "null") {
			return null;
		}
		return symbol;
	}
	,looksLikeFloat: function(s) {
		if(this.floatRegex.match(s)) {
			return true;
		}
		if(this.intRegex.match(s)) {
			var intStr = this.intRegex.matched(0);
			if(HxOverrides.cca(intStr,0) == 45?intStr > "-2147483648":intStr > "2147483647") {
				return true;
			}
			var f = parseFloat(s);
			if(f > 2147483647.0) {
				return true;
			} else if(f < -2147483648) {
				return true;
			}
		}
		return false;
	}
	,looksLikeInt: function(s) {
		return this.intRegex.match(s);
	}
	,getNextSymbol: function() {
		this.lastSymbolQuoted = false;
		var c = "";
		var inQuote = false;
		var quoteType = "";
		var symbol = "";
		var inEscape = false;
		var inSymbol = false;
		var inLineComment = false;
		var inBlockComment = false;
		while(this.pos < this.json.length) {
			c = this.json.charAt(this.pos++);
			if(c == "\n" && !inSymbol) {
				this.currentLine++;
			}
			if(inLineComment) {
				if(c == "\n" || c == "\r") {
					inLineComment = false;
					this.pos++;
				}
				continue;
			}
			if(inBlockComment) {
				if(c == "*" && this.json.charAt(this.pos) == "/") {
					inBlockComment = false;
					this.pos++;
				}
				continue;
			}
			if(inQuote) {
				if(inEscape) {
					inEscape = false;
					if(c == "'" || c == "\"") {
						symbol += c;
						continue;
					}
					if(c == "t") {
						symbol += "\t";
						continue;
					}
					if(c == "n") {
						symbol += "\n";
						continue;
					}
					if(c == "\\") {
						symbol += "\\";
						continue;
					}
					if(c == "r") {
						symbol += "\r";
						continue;
					}
					if(c == "/") {
						symbol += "/";
						continue;
					}
					if(c == "u") {
						var hexValue = 0;
						var _g = 0;
						while(_g < 4) {
							++_g;
							if(this.pos >= this.json.length) {
								throw new js__$Boot_HaxeError("Unfinished UTF8 character");
							}
							var nc = HxOverrides.cca(this.json,this.pos++);
							hexValue <<= 4;
							if(nc >= 48 && nc <= 57) {
								hexValue += nc - 48;
							} else if(nc >= 65 && nc <= 70) {
								hexValue += 10 + nc - 65;
							} else if(nc >= 97 && nc <= 102) {
								hexValue += 10 + nc - 95;
							} else {
								throw new js__$Boot_HaxeError("Not a hex digit");
							}
						}
						var utf = new haxe_Utf8();
						utf.__b += String.fromCharCode(hexValue);
						symbol += utf.__b;
						continue;
					}
					throw new js__$Boot_HaxeError("Invalid escape sequence '\\" + c + "'");
				} else {
					if(c == "\\") {
						inEscape = true;
						continue;
					}
					if(c == quoteType) {
						return symbol;
					}
					symbol += c;
					continue;
				}
			} else if(c == "/") {
				var c2 = this.json.charAt(this.pos);
				if(c2 == "/") {
					inLineComment = true;
					this.pos++;
					continue;
				} else if(c2 == "*") {
					inBlockComment = true;
					this.pos++;
					continue;
				}
			}
			if(inSymbol) {
				if(c == " " || c == "\n" || c == "\r" || c == "\t" || c == "," || c == ":" || c == "}" || c == "]") {
					this.pos--;
					return symbol;
				} else {
					symbol += c;
					continue;
				}
			} else {
				if(c == " " || c == "\t" || c == "\n" || c == "\r") {
					continue;
				}
				if(c == "{" || c == "}" || c == "[" || c == "]" || c == "," || c == ":") {
					return c;
				}
				if(c == "'" || c == "\"") {
					inQuote = true;
					quoteType = c;
					this.lastSymbolQuoted = true;
					continue;
				} else {
					inSymbol = true;
					symbol = c;
					continue;
				}
			}
		}
		if(inQuote) {
			throw new js__$Boot_HaxeError("Unexpected end of data. Expected ( " + quoteType + " )");
		}
		return symbol;
	}
	,defaultStringProcessor: function(str) {
		return str;
	}
	,__class__: tjson_TJSONParser
};
var tjson_TJSONEncoder = function(useCache) {
	if(useCache == null) {
		useCache = true;
	}
	this.uCache = useCache;
	if(this.uCache) {
		this.cache = [];
	}
};
$hxClasses["tjson.TJSONEncoder"] = tjson_TJSONEncoder;
tjson_TJSONEncoder.__name__ = ["tjson","TJSONEncoder"];
tjson_TJSONEncoder.prototype = {
	cache: null
	,uCache: null
	,doEncode: function(obj,style) {
		if(!Reflect.isObject(obj)) {
			throw new js__$Boot_HaxeError("Provided object is not an object.");
		}
		var st = js_Boot.__instanceof(style,tjson_EncodeStyle)?style:style == "fancy"?new tjson_FancyStyle():new tjson_SimpleStyle();
		var buffer_b = "";
		if((obj instanceof Array) && obj.__enum__ == null || js_Boot.__instanceof(obj,List)) {
			buffer_b += Std.string(this.encodeIterable(obj,st,0));
		} else if(js_Boot.__instanceof(obj,haxe_ds_StringMap)) {
			buffer_b += Std.string(this.encodeMap(obj,st,0));
		} else {
			this.cacheEncode(obj);
			buffer_b += Std.string(this.encodeObject(obj,st,0));
		}
		return buffer_b;
	}
	,encodeObject: function(obj,style,depth) {
		var buffer_b = "";
		buffer_b = "" + Std.string(style.beginObject(depth));
		var fieldCount = 0;
		var fields;
		var dontEncodeFields = null;
		var cls = obj == null?null:js_Boot.getClass(obj);
		if(cls != null) {
			fields = Type.getInstanceFields(cls);
		} else {
			fields = Reflect.fields(obj);
		}
		var _g = Type["typeof"](obj);
		if(_g[1] == 6) {
			var className = Type.getClassName(_g[2]);
			if(className == "Date") {
				className += "@" + (js_Boot.__cast(obj , Date)).getTime();
			}
			fieldCount = 1;
			buffer_b += Std.string(style.firstEntry(depth));
			buffer_b += Std.string("\"_hxcls\"" + style.keyValueSeperator(depth));
			buffer_b += Std.string(this.encodeValue(className,style,depth));
			if(obj.TJ_noEncode != null) {
				dontEncodeFields = obj.TJ_noEncode();
			}
		}
		var _g1 = 0;
		while(_g1 < fields.length) {
			var field = fields[_g1];
			++_g1;
			if(dontEncodeFields != null && dontEncodeFields.indexOf(field) >= 0) {
				continue;
			}
			var vStr = this.encodeValue(Reflect.field(obj,field),style,depth);
			if(vStr != null) {
				if(fieldCount++ > 0) {
					buffer_b += Std.string(style.entrySeperator(depth));
				} else {
					buffer_b += Std.string(style.firstEntry(depth));
				}
				buffer_b += Std.string("\"" + field + "\"" + style.keyValueSeperator(depth) + vStr);
			}
		}
		buffer_b += Std.string(style.endObject(depth));
		return buffer_b;
	}
	,encodeMap: function(obj,style,depth) {
		var buffer_b = "";
		buffer_b = "" + Std.string(style.beginObject(depth));
		var fieldCount = 0;
		var tmp = obj.keys();
		while(tmp.hasNext()) {
			var field = tmp.next();
			if(fieldCount++ > 0) {
				buffer_b += Std.string(style.entrySeperator(depth));
			} else {
				buffer_b += Std.string(style.firstEntry(depth));
			}
			var value = obj.get(field);
			buffer_b += Std.string("\"" + field + "\"" + style.keyValueSeperator(depth));
			buffer_b += Std.string(this.encodeValue(value,style,depth));
		}
		buffer_b += Std.string(style.endObject(depth));
		return buffer_b;
	}
	,encodeIterable: function(obj,style,depth) {
		var buffer_b = "";
		buffer_b = "" + Std.string(style.beginArray(depth));
		var fieldCount = 0;
		var tmp = $iterator(obj)();
		while(tmp.hasNext()) {
			var value = tmp.next();
			if(fieldCount++ > 0) {
				buffer_b += Std.string(style.entrySeperator(depth));
			} else {
				buffer_b += Std.string(style.firstEntry(depth));
			}
			buffer_b += Std.string(this.encodeValue(value,style,depth));
		}
		buffer_b += Std.string(style.endArray(depth));
		return buffer_b;
	}
	,cacheEncode: function(value) {
		if(!this.uCache) {
			return null;
		}
		var _g1 = 0;
		var _g = this.cache.length;
		while(_g1 < _g) {
			var c = _g1++;
			if(this.cache[c] == value) {
				return "\"" + tjson_TJSON.OBJECT_REFERENCE_PREFIX + c + "\"";
			}
		}
		this.cache.push(value);
		return null;
	}
	,encodeValue: function(value,style,depth) {
		if(typeof(value) == "number" && ((value | 0) === value) || typeof(value) == "number") {
			return value;
		} else if((value instanceof Array) && value.__enum__ == null || js_Boot.__instanceof(value,List)) {
			var v = value;
			return this.encodeIterable(v,style,depth + 1);
		} else if(js_Boot.__instanceof(value,List)) {
			var v1 = value;
			return this.encodeIterable(v1,style,depth + 1);
		} else if(js_Boot.__instanceof(value,haxe_ds_StringMap)) {
			return this.encodeMap(value,style,depth + 1);
		} else if(typeof(value) == "string") {
			return "\"" + StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(Std.string(value),"\\","\\\\"),"\n","\\n"),"\r","\\r"),"\"","\\\"") + "\"";
		} else if(typeof(value) == "boolean") {
			return value;
		} else if(Reflect.isObject(value)) {
			var ret = this.cacheEncode(value);
			if(ret != null) {
				return ret;
			}
			return this.encodeObject(value,style,depth + 1);
		} else if(value == null) {
			return "null";
		} else {
			return null;
		}
	}
	,__class__: tjson_TJSONEncoder
};
var tjson_EncodeStyle = function() { };
$hxClasses["tjson.EncodeStyle"] = tjson_EncodeStyle;
tjson_EncodeStyle.__name__ = ["tjson","EncodeStyle"];
tjson_EncodeStyle.prototype = {
	beginObject: null
	,endObject: null
	,beginArray: null
	,endArray: null
	,firstEntry: null
	,entrySeperator: null
	,keyValueSeperator: null
	,__class__: tjson_EncodeStyle
};
var tjson_SimpleStyle = function() {
};
$hxClasses["tjson.SimpleStyle"] = tjson_SimpleStyle;
tjson_SimpleStyle.__name__ = ["tjson","SimpleStyle"];
tjson_SimpleStyle.__interfaces__ = [tjson_EncodeStyle];
tjson_SimpleStyle.prototype = {
	beginObject: function(depth) {
		return "{";
	}
	,endObject: function(depth) {
		return "}";
	}
	,beginArray: function(depth) {
		return "[";
	}
	,endArray: function(depth) {
		return "]";
	}
	,firstEntry: function(depth) {
		return "";
	}
	,entrySeperator: function(depth) {
		return ",";
	}
	,keyValueSeperator: function(depth) {
		return ":";
	}
	,__class__: tjson_SimpleStyle
};
var tjson_FancyStyle = function(tab) {
	if(tab == null) {
		tab = "    ";
	}
	this.tab = tab;
	this.charTimesNCache = [""];
};
$hxClasses["tjson.FancyStyle"] = tjson_FancyStyle;
tjson_FancyStyle.__name__ = ["tjson","FancyStyle"];
tjson_FancyStyle.__interfaces__ = [tjson_EncodeStyle];
tjson_FancyStyle.prototype = {
	tab: null
	,beginObject: function(depth) {
		return "{\n";
	}
	,endObject: function(depth) {
		return "\n" + this.charTimesN(depth) + "}";
	}
	,beginArray: function(depth) {
		return "[\n";
	}
	,endArray: function(depth) {
		return "\n" + this.charTimesN(depth) + "]";
	}
	,firstEntry: function(depth) {
		return this.charTimesN(depth + 1) + " ";
	}
	,entrySeperator: function(depth) {
		return "\n" + this.charTimesN(depth + 1) + ",";
	}
	,keyValueSeperator: function(depth) {
		return " : ";
	}
	,charTimesNCache: null
	,charTimesN: function(n) {
		if(n < this.charTimesNCache.length) {
			return this.charTimesNCache[n];
		} else {
			return this.charTimesNCache[n] = this.charTimesN(n - 1) + this.tab;
		}
	}
	,__class__: tjson_FancyStyle
};
var troshx_components_Bout = function() {
	this.combatants = new List();
	this.state = new troshx_components_FightState();
};
$hxClasses["troshx.components.Bout"] = troshx_components_Bout;
troshx_components_Bout.__name__ = ["troshx","components","Bout"];
troshx_components_Bout.prototype = {
	state: null
	,combatants: null
	,__class__: troshx_components_Bout
};
var troshx_components_FightNode = function() { };
$hxClasses["troshx.components.FightNode"] = troshx_components_FightNode;
troshx_components_FightNode.__name__ = ["troshx","components","FightNode"];
troshx_components_FightNode.prototype = {
	fight: null
	,charSheet: null
	,__class__: troshx_components_FightNode
};
var troshx_components_FightState = function() {
	this.lastAttacking = false;
	this.shortRangeAdvantage = false;
	this.attacking = false;
	this.rounds = 0;
	this.enemyManuevers = [];
	this.manuevers = [{ manuever : null, numDice : 0}];
	this.orientation = 0;
	this.flags = 0;
	this.targetedByFlags = 0;
	this.targetLocked = false;
	this.target__ = null;
	this.initiative = false;
	this.numEnemies = 0;
	this.side = 1;
	this.e = false;
	this.s = 0;
};
$hxClasses["troshx.components.FightState"] = troshx_components_FightState;
troshx_components_FightState.__name__ = ["troshx","components","FightState"];
troshx_components_FightState.isAttackingChoice = function(choice) {
	if(choice.manuever != null) {
		return choice.manuever.type == 2;
	} else {
		return false;
	}
};
troshx_components_FightState.manueverNeedsElaboration = function(cManuever) {
	if(cManuever.numDice != 0) {
		if(cManuever.to != null) {
			return cManuever.targetZone == null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
troshx_components_FightState.prototype = {
	s: null
	,e: null
	,side: null
	,numEnemies: null
	,initiative: null
	,target__: null
	,get_target: function() {
		return this.target__;
	}
	,set_target: function(value) {
		return this.target__ = value;
	}
	,targetLocked: null
	,paused: null
	,get_paused: function() {
		if(this.target__ == null) {
			return this.targetedByFlags == 0;
		} else if(!(this.target__.target__ == this && !this.target__.initiative && !this.initiative)) {
			if(this.target__.target__ != this && !this.initiative) {
				return this.traceExceptionIsPaused();
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,targetedByFlags: null
	,flags: null
	,traceExceptionIsPaused: function() {
		console.log("traceExceptionIsPaused exception found");
		return true;
	}
	,orientation: null
	,hasOrientationInitiative: function(targetFight) {
		if(this.orientation != 3) {
			if(this.orientation != 1) {
				if(!(this.target__ == targetFight && targetFight.target__ != this)) {
					return this.orientation > targetFight.orientation;
				} else {
					return true;
				}
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,getInitiativeTowards: function(fightState) {
		if(this.orientation == 0) {
			if(this.initiative) {
				if(fightState.initiative) {
					return 1;
				} else {
					return 2;
				}
			} else {
				return 0;
			}
		} else if(this.orientation != 1) {
			if(this.orientation != fightState.orientation) {
				if(this.orientation > fightState.orientation) {
					return 2;
				} else {
					return 0;
				}
			} else if(this.orientation == 2) {
				if(fightState.orientation != 2) {
					throw new js__$Boot_HaxeError("Equal assertion cautious failed:" + fightState.orientation);
				}
				if(this.initiative != fightState.initiative) {
					return 10;
				} else {
					return -10;
				}
			} else if(this.orientation == 3) {
				if(fightState.orientation != 3) {
					throw new js__$Boot_HaxeError("Equal assertion aggressive failed:" + fightState.orientation);
				}
				return 1;
			} else {
				throw new js__$Boot_HaxeError("Missed out this case?? Orientation: " + this.orientation);
			}
		} else {
			return 0;
		}
	}
	,manuevers: null
	,enemyManuevers: null
	,rounds: null
	,attacking: null
	,shortRangeAdvantage: null
	,lastAttacking: null
	,combatPool: null
	,shock: null
	,resetManueverObj: function(obj) {
		obj.manuever = null;
		obj.marginSuccess = null;
		obj.reflexScore = null;
		obj.successes = null;
		obj.numDice = 0;
		obj.from = null;
		obj.tn = 0;
		obj.to = null;
		obj.targetZone = null;
		obj.cost = null;
		obj.defManuever = null;
	}
	,resetManuevers: function() {
		var primary = this.manuevers[0];
		this.resetManueverObj(primary);
		this.manuevers.length = 1;
		this.enemyManuevers.length = 0;
	}
	,syncStepWith: function(fight) {
		if(fight.s >= this.s) {
			this.s = fight.s;
		} else {
			fight.s = this.s;
		}
	}
	,isSyncedWith: function(fight) {
		if(this.s == fight.s) {
			return this.e == fight.e;
		} else {
			return false;
		}
	}
	,step: function(nextExchange) {
		this.shock = 0;
		this.targetLocked = false;
		this.s++;
		if(nextExchange) {
			this.s = 0;
			this.e = !this.e;
			this.s = 0;
			this.orientation = 0;
			if(!this.e) {
				this.rounds++;
			}
		}
	}
	,clone: function() {
		var fState = new troshx_components_FightState();
		fState.side = this.side;
		return fState;
	}
	,checkContestAgainstDefense: function(defManueverChoice) {
		var primary = this.manuevers[0];
		var secondary = this.manuevers.length > 1?this.manuevers[1]:null;
		if(!(troshx_components_FightState.isAttackingChoice(primary) && primary.to == defManueverChoice.from)) {
			if(secondary != null && troshx_components_FightState.isAttackingChoice(secondary)) {
				return secondary.to == defManueverChoice.from;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,getPrimaryManuever: function() {
		return this.manuevers[0];
	}
	,getSecondaryManuever: function() {
		if(this.manuevers.length > 1) {
			return this.manuevers[1];
		} else {
			return null;
		}
	}
	,getPrimaryEnemyManuever: function() {
		if(this.enemyManuevers.length > 0) {
			return this.enemyManuevers[0];
		} else {
			return null;
		}
	}
	,getEnemyManueverAt: function(index) {
		return this.enemyManuevers[index];
	}
	,getManueverAt: function(index) {
		return this.manuevers[index];
	}
	,isUnderAttack: function() {
		return this.enemyManuevers.length > 0;
	}
	,getTotalEnemyManuevers: function() {
		return this.enemyManuevers.length;
	}
	,noMoreCP: function() {
		return this.combatPool <= 0;
	}
	,setSideAggro: function(val) {
		this.side = val;
		return this;
	}
	,hostileTowards: function(fight) {
		return this.side != fight.side;
	}
	,matchScheduleWith: function(other) {
		this.s = other.s;
		this.e = other.e;
	}
	,reset: function(disengaged) {
		if(disengaged == null) {
			disengaged = false;
		}
		this.s = 0;
		this.e = false;
		this.orientation = 0;
		this.initiative = false;
		this.targetLocked = false;
		this.attacking = false;
		this.lastAttacking = false;
		this.shortRangeAdvantage = false;
		this.shock = 0;
		if(disengaged) {
			this.numEnemies = 0;
			this.flags = 0;
			this.targetedByFlags = 0;
			this.target__ = null;
			this.rounds = 0;
			this.resetManuevers();
		}
		return this;
	}
	,__class__: troshx_components_FightState
	,__properties__: {get_paused:"get_paused",set_target:"set_target",get_target:"get_target"}
};
var troshx_core_BodyChar = $hx_exports["troshx"]["core"]["BodyChar"] = function() {
	this.zones = [];
	this.zones[0] = null;
	this.zonesB = [];
	this.zones[1] = null;
};
$hxClasses["troshx.core.BodyChar"] = troshx_core_BodyChar;
troshx_core_BodyChar.__name__ = ["troshx","core","BodyChar"];
troshx_core_BodyChar.getEmptyBodyPartTypeDef = function() {
	return { BL : 0, KD : null, lev : 0, d : 0, ko : null, shock : 0, shockWP : 0, pain : 0, painWP : 0};
};
troshx_core_BodyChar.getEmptyWoundLocation = function(id) {
	return { id : id, cut : [], puncture : [], bludgeon : []};
};
troshx_core_BodyChar.getCleanArrayOfWound = function(dirtyArr) {
	var cleanArr = [];
	var _g1 = 0;
	var _g = dirtyArr.length;
	while(_g1 < _g) {
		var i = _g1++;
		cleanArr[i] = troshx_core_BodyChar.getBodyPartOf(dirtyArr[i]);
	}
	return cleanArr;
};
troshx_core_BodyChar.getBodyPartOf = function(obj) {
	var theBodyPart = troshx_core_BodyChar.getEmptyBodyPartTypeDef();
	var _g = 0;
	var _g1 = Reflect.fields(theBodyPart);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		if(Object.prototype.hasOwnProperty.call(obj,f)) {
			theBodyPart[f] = Reflect.field(obj,f);
		}
	}
	return theBodyPart;
};
troshx_core_BodyChar.prototype = {
	getAllWoundLocations: function() {
		var arr = [];
		var partsMap = new haxe_ds_StringMap();
		var _g = 0;
		var _g1 = Reflect.fields(this.partsCut);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(__map_reserved[f] != null) {
				partsMap.setReserved(f,true);
			} else {
				partsMap.h[f] = true;
			}
		}
		var _g2 = 0;
		var _g11 = Reflect.fields(this.partsBludgeon);
		while(_g2 < _g11.length) {
			var f1 = _g11[_g2];
			++_g2;
			if(__map_reserved[f1] != null) {
				partsMap.setReserved(f1,true);
			} else {
				partsMap.h[f1] = true;
			}
		}
		var _g3 = 0;
		var _g12 = Reflect.fields(this.partsPuncture);
		while(_g3 < _g12.length) {
			var f2 = _g12[_g3];
			++_g3;
			if(__map_reserved[f2] != null) {
				partsMap.setReserved(f2,true);
			} else {
				partsMap.h[f2] = true;
			}
		}
		var tmp = partsMap.keys();
		while(tmp.hasNext()) {
			var f3 = tmp.next();
			var woundLocation = troshx_core_BodyChar.getEmptyWoundLocation(f3);
			if(Object.prototype.hasOwnProperty.call(this.partsCut,f3)) {
				woundLocation.cut = troshx_core_BodyChar.getCleanArrayOfWound(Reflect.field(this.partsCut,f3));
			}
			if(Object.prototype.hasOwnProperty.call(this.partsPuncture,f3)) {
				woundLocation.puncture = troshx_core_BodyChar.getCleanArrayOfWound(Reflect.field(this.partsPuncture,f3));
			}
			if(Object.prototype.hasOwnProperty.call(this.partsBludgeon,f3)) {
				woundLocation.bludgeon = troshx_core_BodyChar.getCleanArrayOfWound(Reflect.field(this.partsBludgeon,f3));
			}
			arr.push(woundLocation);
		}
		return arr;
	}
	,zones: null
	,zonesB: null
	,thrustStartIndex: null
	,centerOfMass: null
	,centerOfMassT: null
	,partsCut: null
	,partsPuncture: null
	,partsBludgeon: null
	,getTargetZoneCost: function(index) {
		return 0;
	}
	,__class__: troshx_core_BodyChar
};
var troshx_core_BoutMessage = function() {
};
$hxClasses["troshx.core.BoutMessage"] = troshx_core_BoutMessage;
troshx_core_BoutMessage.__name__ = ["troshx","core","BoutMessage"];
troshx_core_BoutMessage.create = function(type,text) {
	if(type == null) {
		type = 0;
	}
	var me = new troshx_core_BoutMessage();
	me.type = type;
	me.text = text;
	return me;
};
troshx_core_BoutMessage.prototype = {
	text: null
	,type: null
	,__class__: troshx_core_BoutMessage
};
var troshx_core_CharSheet = function() {
};
$hxClasses["troshx.core.CharSheet"] = troshx_core_CharSheet;
troshx_core_CharSheet.__name__ = ["troshx","core","CharSheet"];
troshx_core_CharSheet.prototype = {
	__class__: troshx_core_CharSheet
};
var troshx_core_GameRules = $hx_exports["troshx"]["core"]["GameRules"] = function() { };
$hxClasses["troshx.core.GameRules"] = troshx_core_GameRules;
troshx_core_GameRules.__name__ = ["troshx","core","GameRules"];
var troshx_core_IBoutController = function() { };
$hxClasses["troshx.core.IBoutController"] = troshx_core_IBoutController;
troshx_core_IBoutController.__name__ = ["troshx","core","IBoutController"];
troshx_core_IBoutController.prototype = {
	step: null
	,handleCurrentStep: null
	,__class__: troshx_core_IBoutController
};
var troshx_core_IBoutModel = function() { };
$hxClasses["troshx.core.IBoutModel"] = troshx_core_IBoutModel;
troshx_core_IBoutModel.__name__ = ["troshx","core","IBoutModel"];
troshx_core_IBoutModel.prototype = {
	setBout: null
	,getMessages: null
	,getMessagesCount: null
	,clearMessages: null
	,__class__: troshx_core_IBoutModel
};
var troshx_core_ICharacterSheet = function() { };
$hxClasses["troshx.core.ICharacterSheet"] = troshx_core_ICharacterSheet;
troshx_core_ICharacterSheet.__name__ = ["troshx","core","ICharacterSheet"];
var troshx_core_Manuever = $hx_exports["troshx"]["core"]["Manuever"] = function(id,name,cost) {
	if(cost == null) {
		cost = 0;
	}
	this.type = 0;
	this.id = id;
	this.name = name;
	this.cost = cost;
	this.usingHands = 0;
	this.defaultTN = 0;
	this.customRange = 0;
	this.customMinRange = 0;
	this.stanceModifier = 2;
	this.attackTypes = 1 | 2;
	this.damageType = 0;
	this.requiredLevel = 0;
	this.spamPenalty = 0;
	this.spamIndividualOnly = false;
	this.regionMask = 0;
	this.offHanded = false;
	this.evasive = false;
	this.manueverType = 0;
};
$hxClasses["troshx.core.Manuever"] = troshx_core_Manuever;
troshx_core_Manuever.__name__ = ["troshx","core","Manuever"];
troshx_core_Manuever.isThrustingMotion = function(targetzone,toBody) {
	return targetzone >= toBody.thrustStartIndex;
};
troshx_core_Manuever.prototype = {
	id: null
	,name: null
	,cost: null
	,attackTypes: null
	,damageType: null
	,defaultTN: null
	,customRange: null
	,customMinRange: null
	,requiredLevel: null
	,spamPenalty: null
	,spamIndividualOnly: null
	,regionMask: null
	,offHanded: null
	,stanceModifier: null
	,evasive: null
	,usingHands: null
	,manueverType: null
	,type: null
	,__class__: troshx_core_Manuever
};
var troshx_core_ManueverStack = function() {
	this.stack = [];
};
$hxClasses["troshx.core.ManueverStack"] = troshx_core_ManueverStack;
troshx_core_ManueverStack.__name__ = ["troshx","core","ManueverStack"];
troshx_core_ManueverStack.prototype = {
	stack: null
	,reset: function() {
		this.stack.length = 0;
	}
	,reverseOrder: function() {
		this.stack.reverse();
	}
	,pushManuever: function(manueverObj) {
		this.stack.push(manueverObj);
	}
	,sortOnLowestToHighestReflex: function() {
		haxe_ds_ArraySort.sort(this.stack,function(a,b) {
			if(a.reflexScore != b.reflexScore) {
				if(a.reflexScore > b.reflexScore) {
					return 1;
				} else {
					return -1;
				}
			} else {
				return 0;
			}
		});
	}
	,sortOnHighestToLowestReflex: function(property) {
		haxe_ds_ArraySort.sort(this.stack,function(a,b) {
			if(a.reflexScore != b.reflexScore) {
				if(a.reflexScore > b.reflexScore) {
					return -1;
				} else {
					return 1;
				}
			} else {
				return 0;
			}
		});
	}
	,__class__: troshx_core_ManueverStack
};
var troshx_core_Weapon = $hx_exports["troshx"]["core"]["Weapon"] = function(name,profGroups) {
	this.name = name;
	this.profeciencies = profGroups;
	this.attrBaseIndex = 0;
	this.drawCutModifier = 0;
	this.damage = 0;
	this.damage2 = 0;
	this.damage3 = 0;
	this.atn = 0;
	this.atn2 = 0;
	this.dtn = 0;
	this.dtn2 = 0;
	this.twoHanded = false;
	this.rangedWeapon = false;
	this.shield = false;
	this.shieldLimit = 0;
	this.cpPenalty = 0;
	this.movePenalty = 0;
	this.blunt = false;
	this.hooking = 0;
};
$hxClasses["troshx.core.Weapon"] = troshx_core_Weapon;
troshx_core_Weapon.__name__ = ["troshx","core","Weapon"];
troshx_core_Weapon.createDyn = function(name,profGroups,properties) {
	var weap = new troshx_core_Weapon(name,profGroups);
	var _g = 0;
	var _g1 = Reflect.fields(properties);
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		weap[p] = Reflect.field(properties,p);
	}
	return weap;
};
troshx_core_Weapon.prototype = {
	atn: null
	,atn2: null
	,dtn: null
	,dntT: null
	,dtn2: null
	,damage: null
	,damage2: null
	,damage3: null
	,shield: null
	,profeciencies: null
	,name: null
	,drawCutModifier: null
	,attrBaseIndex: null
	,twoHanded: null
	,rangedWeapon: null
	,cpPenalty: null
	,movePenalty: null
	,shieldLimit: null
	,blunt: null
	,range: null
	,hooking: null
	,getDamageTo: function(body,manuever,targetZone,margin,strength) {
		var dmg = this.damage3 != 0 && (this.blunt || manuever.damageType == 3)?this.damage3:targetZone >= body.thrustStartIndex?this.damage2:this.damage;
		dmg += margin;
		if(this.attrBaseIndex == 0) {
			dmg += strength;
		}
		return dmg;
	}
	,getHookingATN: function(tieBiasToThrust) {
		if(tieBiasToThrust == null) {
			tieBiasToThrust = false;
		}
		var strikeATN = (this.hooking & 1) != 0?this.atn:0;
		var thrustATN = (this.hooking & 2) != 0?this.atn2:0;
		if(strikeATN != 0 && thrustATN != 0) {
			if(!tieBiasToThrust) {
				if(thrustATN < strikeATN) {
					return -thrustATN;
				} else {
					return strikeATN;
				}
			} else if(strikeATN < thrustATN) {
				return strikeATN;
			} else {
				return -thrustATN;
			}
		} else if(strikeATN == 0) {
			return -thrustATN;
		} else {
			return strikeATN;
		}
	}
	,getHookingATNType: function(tieBiasToThrust) {
		if(tieBiasToThrust == null) {
			tieBiasToThrust = false;
		}
		var strikeATN = (this.hooking & 1) != 0?this.atn:0;
		var thrustATN = (this.hooking & 2) != 0?this.atn2:0;
		if(strikeATN != 0 && thrustATN != 0) {
			if(!tieBiasToThrust) {
				if(thrustATN < strikeATN) {
					return -thrustATN;
				} else {
					return strikeATN;
				}
			} else if(strikeATN < thrustATN) {
				return strikeATN;
			} else {
				return -thrustATN;
			}
		} else if(strikeATN == 0) {
			return -thrustATN;
		} else {
			return strikeATN;
		}
	}
	,getInlineTest: function() {
		var weap = this.weaponListInlineTest[0];
		var testVar = 8 + (Math.random() * this.dtn2 | 0);
		testVar += this.damage;
		var tmp = this.damage2 + testVar + 99999.22222;
		var testVar1 = 5 + (Math.random() * weap.dtn2 | 0);
		testVar1 += weap.damage;
		return tmp + (weap.damage2 + testVar1);
	}
	,weaponListInlineTest: null
	,getInlineTest2: function(val,val2) {
		if(val2 == null) {
			val2 = 5;
		}
		if(val == null) {
			val = 0;
		}
		var testVar = val + val2 + (Math.random() * this.dtn2 | 0);
		testVar += this.damage;
		return this.damage2 + testVar;
	}
	,__class__: troshx_core_Weapon
};
var troshx_core_ZoneBody = function() {
	this.weightsTotal = 0;
};
$hxClasses["troshx.core.ZoneBody"] = troshx_core_ZoneBody;
troshx_core_ZoneBody.__name__ = ["troshx","core","ZoneBody"];
troshx_core_ZoneBody.create = function(name,partWeights,parts,weightsTotal) {
	if(weightsTotal == null) {
		weightsTotal = 0;
	}
	var zb = new troshx_core_ZoneBody();
	zb.name = name;
	zb.parts = parts;
	zb.partWeights = partWeights;
	zb.weightsTotal = weightsTotal;
	if(weightsTotal == 0) {
		zb.recalcWeightsTotal();
	}
	return zb;
};
troshx_core_ZoneBody.prototype = {
	name: null
	,parts: null
	,partWeights: null
	,weightsTotal: null
	,recalcWeightsTotal: function() {
		var accum = 0;
		var i = this.partWeights.length;
		while(--i > -1) accum += this.partWeights[i];
		this.weightsTotal = accum;
	}
	,getBodyPart: function(floatRatio) {
		floatRatio *= this.weightsTotal;
		var accum = 0;
		var result = 0;
		var _g1 = 0;
		var _g = this.partWeights.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(floatRatio < accum) {
				break;
			}
			accum += this.partWeights[i];
			result = i;
		}
		return this.parts[result];
	}
	,__class__: troshx_core_ZoneBody
};
var troshx_sos_BoutController = function() {
	this.model = new troshx_sos_BoutModel();
};
$hxClasses["troshx.sos.BoutController"] = troshx_sos_BoutController;
troshx_sos_BoutController.__name__ = ["troshx","sos","BoutController"];
troshx_sos_BoutController.__interfaces__ = [troshx_core_IBoutController];
troshx_sos_BoutController.prototype = {
	model: null
	,waitForPlayer: function() {
		return null;
	}
	,step: function() {
		this.model.bout.state.step(this.model.bout.state.s == 2);
		var _g_head = this.model.bout.combatants.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var _this = val.fight;
			var other = this.model.bout.state;
			_this.s = other.s;
			_this.e = other.e;
		}
	}
	,handleCurrentStep: function() {
		var step = this.model.bout.state.s;
		if(step == 0) {
			return true;
		} else if(step == 1) {
			return true;
		} else if(step == 2) {
			return true;
		} else {
			throw new js__$Boot_HaxeError("Unhandled step:" + step);
		}
	}
	,__class__: troshx_sos_BoutController
};
var troshx_sos_BoutModel = function() {
	this.defManueverStack = new troshx_core_ManueverStack();
	this.manueverStack = new troshx_core_ManueverStack();
	this._messages = [];
	this.bout = new troshx_components_Bout();
};
$hxClasses["troshx.sos.BoutModel"] = troshx_sos_BoutModel;
troshx_sos_BoutModel.__name__ = ["troshx","sos","BoutModel"];
troshx_sos_BoutModel.__interfaces__ = [troshx_core_IBoutModel];
troshx_sos_BoutModel.prototype = {
	bout: null
	,setBout: function(val) {
		this.bout = val;
	}
	,_messages: null
	,getMessages: function() {
		return this._messages;
	}
	,getMessagesCount: function() {
		return this._messages.length;
	}
	,clearMessages: function() {
		this._messages.length = 0;
	}
	,manueverStack: null
	,defManueverStack: null
	,__class__: troshx_sos_BoutModel
};
var troshx_tros_HumanoidBody = $hx_exports["troshx"]["tros"]["HumanoidBody"] = function() {
	troshx_core_BodyChar.call(this);
	this.partsBludgeon = { 'foot' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 3, 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : 1, 'BL' : 0, 'shock' : 6, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'KD' : -1, 'BL' : 1, 'shock' : 9, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1}], 'shin_and_lower_leg' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 2, 'BL' : 0, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 0, 'shock' : 6, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'KD' : -3, 'BL' : 2, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'KD' : -1, 'BL' : 5, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'knee_and_nearby_areas' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 0, 'BL' : 2, 'shock' : 8, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'KD' : -5, 'BL' : 6, 'shock' : 10, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0},{ 'KD' : -1, 'BL' : 8, 'shock' : 15, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'thigh' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'KD' : 2, 'BL' : 0, 'shock' : 5, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'KD' : 0, 'BL' : 0, 'shock' : 7, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'KD' : -4, 'BL' : 3, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'KD' : -1, 'BL' : 7, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'inner_thigh' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'KD' : 2, 'BL' : 0, 'shock' : 5, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'KD' : 0, 'BL' : 0, 'shock' : 7, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'KD' : -4, 'BL' : 3, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'KD' : -1, 'BL' : 7, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'hip' : [{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : -1, 'BL' : 2, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 10, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'BL' : 20, 'shock' : -1, 'shockWP' : 0, 'pain' : 13, 'painWP' : 1, 'd' : 1}], 'groin' : [{ 'BL' : 0, 'shock' : 7, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'ko' : 0, 'BL' : 0, 'shock' : 9, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'ko' : -2, 'BL' : 3, 'shock' : 11, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1},{ 'ko' : -1, 'BL' : 18, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0},{ 'BL' : 20, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0, 'd' : 2}], 'abdomen' : [{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'ko' : 3, 'BL' : 0, 'shock' : 7, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'ko' : 0, 'BL' : 3, 'shock' : 10, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 8, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'ko' : -3, 'BL' : 15, 'shock' : -1, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1}], 'ribcage' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'ko' : 2, 'BL' : 1, 'shock' : 8, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'ko' : 0, 'BL' : 3, 'shock' : 10, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'ko' : -3, 'BL' : 9, 'shock' : -1, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1}], 'upper_abdomen' : [{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'ko' : 3, 'BL' : 0, 'shock' : 7, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'ko' : 0, 'BL' : 3, 'shock' : 10, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 8, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'ko' : -3, 'BL' : 15, 'shock' : -1, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1}], 'chest' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'ko' : 2, 'BL' : 1, 'shock' : 8, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'ko' : 0, 'BL' : 3, 'shock' : 10, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'ko' : 0, 'BL' : 9, 'shock' : -1, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1}], 'upper_body' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'ko' : 2, 'BL' : 1, 'shock' : 8, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'ko' : 0, 'BL' : 3, 'shock' : 10, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'ko' : -3, 'BL' : 9, 'shock' : -1, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1}], 'neck' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 1, 'shock' : 7, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'ko' : 0, 'BL' : 3, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'BL' : 3, 'shock' : -1, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'face' : [{ 'ko' : 3, 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 0, 'painWP' : 0},{ 'ko' : 1, 'BL' : 1, 'shock' : 8, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 4, 'shock' : 10, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0},{ 'ko' : -3, 'BL' : 6, 'shock' : 12, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'lower_head' : [{ 'ko' : 3, 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 0, 'painWP' : 0},{ 'ko' : 1, 'BL' : 1, 'shock' : 8, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 4, 'shock' : 10, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0},{ 'ko' : -3, 'BL' : 6, 'shock' : 12, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'upper_head' : [{ 'ko' : 2, 'BL' : 0, 'shock' : 8, 'shockWP' : 1, 'pain' : 5, 'painWP' : 1},{ 'ko' : 0, 'BL' : 3, 'shock' : 8, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'ko' : -3, 'BL' : 4, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'BL' : 6, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'upper_arm_and_shoulder' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 5, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 1, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 5, 'shock' : 10, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'BL' : 10, 'shock' : 13, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'hand' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 0, 'painWP' : 0},{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 7, 'shockWP' : 1, 'pain' : 5, 'painWP' : 1},{ 'BL' : 1, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 3, 'shock' : 9, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1}], 'forearm' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 0, 'painWP' : 0},{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 1, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 2, 'shock' : 8, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 3, 'shock' : 10, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1}], 'elbow' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 5, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 1, 'shock' : 8, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 3, 'shock' : 9, 'shockWP' : 0, 'pain' : 10, 'painWP' : 0}]};
	this.partsCut = { 'foot' : [{ 'BL' : 0, 'shock' : 3, 'shockWP' : 1, 'pain' : 2, 'painWP' : 1},{ 'BL' : 1, 'shock' : 3, 'shockWP' : 0, 'pain' : 3, 'painWP' : 1},{ 'KD' : 3, 'BL' : 2, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 1, 'BL' : 5, 'shock' : 6, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : 0, 'BL' : 10, 'shock' : 9, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1}], 'shin_and_lower_leg' : [{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 2, 'painWP' : 1},{ 'KD' : 2, 'BL' : 2, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : -2, 'BL' : 8, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'KD' : 0, 'BL' : 13, 'shock' : 9, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1}], 'knee_and_nearby_areas' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 3, 'painWP' : 1},{ 'BL' : 2, 'shock' : 5, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 0, 'BL' : 4, 'shock' : 8, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'KD' : -5, 'BL' : 8, 'shock' : 10, 'shockWP' : 0, 'pain' : 13, 'painWP' : 1},{ 'KD' : 0, 'BL' : 13, 'shock' : 12, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'thigh' : [{ 'BL' : 1, 'shock' : 4, 'shockWP' : 1, 'pain' : 3, 'painWP' : 1},{ 'KD' : 2, 'BL' : 2, 'shock' : 2, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'KD' : 2, 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'KD' : 2, 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'KD' : 2, 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1}], 'inner_thigh' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 6, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 0, 'BL' : 9, 'shock' : 5, 'shockWP' : 0, 'pain' : 16, 'painWP' : 1},{ 'BL' : 12, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 17, 'shock' : 7, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1, 'd' : 2}], 'groin' : [{ 'BL' : 6, 'shock' : 9, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'BL' : 9, 'shock' : 9, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 12, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1, 'd' : 1},{ 'BL' : 18, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0},{ 'BL' : 20, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0, 'd' : 2}], 'hip' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 3, 'painWP' : 1},{ 'BL' : 2, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 0, 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'KD' : -2, 'BL' : 8, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'KD' : -1, 'BL' : 12, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'abdomen' : [{ 'BL' : 1, 'shock' : 2, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 3, 'shock' : 4, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 7, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 10, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'BL' : 20, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0}], 'ribcage' : [{ 'BL' : 0, 'shock' : 2, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 0, 'BL' : 3, 'shock' : 8, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 9, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'BL' : 20, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0, 'd' : 2}], 'chest' : [{ 'BL' : 0, 'shock' : 2, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 0, 'BL' : 3, 'shock' : 8, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 9, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'BL' : 20, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0, 'd' : 2}], 'upper_arm_and_shoulder' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 8, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 12, 'shock' : 13, 'shockWP' : 0, 'pain' : 14, 'painWP' : 1}], 'shoulder' : [{ 'BL' : 1, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 5, 'shock' : 6, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 10, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 25, 'shock' : 10, 'shockWP' : 0, 'pain' : 11, 'painWP' : 1}], 'neck' : [{ 'BL' : 1, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 4, 'shock' : 7, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 9, 'shock' : 10, 'shockWP' : 0, 'pain' : 11, 'painWP' : 1},{ 'BL' : 20, 'shock' : 13, 'shockWP' : 0, 'pain' : 14, 'painWP' : 1},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'face' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 0, 'painWP' : 0},{ 'BL' : 2, 'shock' : 8, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 5, 'shock' : 1, 'shockWP' : 1, 'pain' : 7, 'painWP' : 1},{ 'BL' : 7, 'shock' : 10, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'lower_head' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 0, 'painWP' : 0},{ 'BL' : 2, 'shock' : 8, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 5, 'shock' : 1, 'shockWP' : 1, 'pain' : 7, 'painWP' : 1},{ 'BL' : 7, 'shock' : 10, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'upper_head' : [{ 'BL' : 3, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 3, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 4, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'ko' : 0, 'BL' : 10, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'hand' : [{ 'BL' : 0, 'shock' : 7, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 6, 'shock' : 9, 'shockWP' : 1, 'pain' : 6, 'painWP' : 1},{ 'BL' : 8, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'BL' : 10, 'shock' : 10, 'shockWP' : 0, 'pain' : 11, 'painWP' : 1, 'd' : 1}], 'forearm' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 6, 'shock' : 8, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 12, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1, 'd' : 1}], 'elbow' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 3, 'shock' : 6, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 6, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'BL' : 12, 'shock' : 10, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1}]};
	this.partsPuncture = { 'foot' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 3, 'BL' : 2, 'shock' : 4, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : -1, 'BL' : 3, 'shock' : 7, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'KD' : -1, 'BL' : 3, 'shock' : 7, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1}], 'shin_and_lower_leg' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'KD' : 2, 'BL' : 1, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 2, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : -2, 'BL' : 2, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : 0, 'BL' : 4, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1}], 'knee_and_nearby_areas' : [{ 'BL' : 0, 'shock' : 5, 'shockWP' : 1, 'pain' : 5, 'painWP' : 1},{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : 0, 'BL' : 3, 'shock' : 6, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'KD' : -2, 'BL' : 4, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'KD' : -5, 'BL' : 6, 'shock' : 9, 'shockWP' : 0, 'pain' : 11, 'painWP' : 1}], 'thigh' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'KD' : 2, 'BL' : 1, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'KD' : 0, 'BL' : 2, 'shock' : 5, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'KD' : -2, 'BL' : 4, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 8, 'shock' : 5, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1}], 'groin' : [{ 'BL' : 6, 'shock' : 7, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'BL' : 8, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 10, 'shock' : 10, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1},{ 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0},{ 'BL' : 15, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0}], 'hip' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 1, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'KD' : -2, 'BL' : 6, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'KD' : 0, 'BL' : 10, 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1}], 'flesh_to_the_side' : [{ 'lev' : 1, 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'lev' : 1, 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'lev' : 1, 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'lev' : 1, 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'lev' : 1, 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1}], 'lower_abdomen' : [{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 6, 'shock' : 4, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 8, 'shock' : 7, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'shock' : 10, 'shockWP' : 0, 'pain' : 12, 'painWP' : 1},{ 'BL' : 18, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0}], 'upper_abdomen' : [{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 8, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 10, 'shock' : 8, 'shockWP' : 0, 'pain' : 10, 'painWP' : 1},{ 'BL' : 13, 'shock' : 13, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1},{ 'BL' : 19, 'shock' : -1, 'shockWP' : 0, 'pain' : -1, 'painWP' : 0}], 'chest' : [{ 'BL' : 0, 'shock' : 9, 'shockWP' : 1, 'pain' : 5, 'painWP' : 1},{ 'BL' : 4, 'shock' : 4, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 8, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 19, 'shock' : 13, 'shockWP' : 0, 'pain' : 13, 'painWP' : 1, 'd' : 2},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'collar_and_throat' : [{ 'BL' : 2, 'shock' : 4, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 6, 'shock' : 7, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'shock' : 13, 'shockWP' : 0, 'pain' : 15, 'painWP' : 1},{ 'BL' : 15, 'shock' : -1, 'shockWP' : 0, 'pain' : 20, 'painWP' : 1},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'face' : [{ 'BL' : 1, 'shock' : 7, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 6, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'ko' : -3, 'BL' : 8, 'shock' : 10, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'ko' : 0, 'BL' : 19, 'shock' : 13, 'shockWP' : 0, 'pain' : 13, 'painWP' : 0},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'head' : [{ 'BL' : 1, 'shock' : 7, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 6, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'ko' : -3, 'BL' : 8, 'shock' : 10, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'ko' : 0, 'BL' : 19, 'shock' : 13, 'shockWP' : 0, 'pain' : 13, 'painWP' : 0},{ 'd' : 2, 'shock' : 0, 'shockWP' : 0, 'pain' : 0, 'painWP' : 0}], 'hand' : [{ 'BL' : 0, 'shock' : 6, 'shockWP' : 1, 'pain' : 5, 'painWP' : 1},{ 'BL' : 0, 'shock' : 3, 'shockWP' : 0, 'pain' : 4, 'painWP' : 1},{ 'BL' : 2, 'shock' : 9, 'shockWP' : 1, 'pain' : 6, 'painWP' : 1},{ 'BL' : 5, 'shock' : 7, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'BL' : 9, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1}], 'forearm' : [{ 'shock' : 5, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 1, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 2, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 6, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1},{ 'BL' : 7, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1}], 'elbow' : [{ 'BL' : 0, 'shock' : 6, 'shockWP' : 1, 'pain' : 5, 'painWP' : 1},{ 'BL' : 0, 'shock' : 4, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 3, 'shock' : 6, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 5, 'shock' : 8, 'shockWP' : 0, 'pain' : 9, 'painWP' : 1},{ 'BL' : 7, 'shock' : 9, 'shockWP' : 0, 'pain' : 11, 'painWP' : 1}], 'upper_arm' : [{ 'BL' : 0, 'shock' : 4, 'shockWP' : 1, 'pain' : 4, 'painWP' : 1},{ 'BL' : 1, 'shock' : 3, 'shockWP' : 0, 'pain' : 5, 'painWP' : 1},{ 'BL' : 3, 'shock' : 5, 'shockWP' : 0, 'pain' : 6, 'painWP' : 1},{ 'BL' : 5, 'shock' : 6, 'shockWP' : 0, 'pain' : 7, 'painWP' : 1},{ 'BL' : 7, 'shock' : 7, 'shockWP' : 0, 'pain' : 8, 'painWP' : 1}]};
	this.thrustStartIndex = 8;
	this.zones[1] = troshx_core_ZoneBody.create("to the Lower Legs",[1,3,2],["foot","shin_and_lower_leg","knee_and_nearby_areas"]);
	this.zones[2] = troshx_core_ZoneBody.create("to the Upper Legs",[2,3,1],["knee_and_nearby_areas","thigh","hip"]);
	this.zones[3] = troshx_core_ZoneBody.create("for Horizontal Swing",[1,1,1,2,1],["hip","upper_abdomen","lower_abdomen","ribcage","arms"]);
	this.zones[4] = troshx_core_ZoneBody.create("for Overhand Swing",[2,1,1,1,1],["upper_arm_and_shoulder","chest","neck","lower_head","upper_head"]);
	this.zones[5] = troshx_core_ZoneBody.create("for Downward Swing from Above",[3,1,2],["upper_head","lower_head","shoulder"]);
	this.zones[6] = troshx_core_ZoneBody.create("for Upward Swing from Below",[3,1,1,1],["inner_thigh","groin","abdomen","chest"]);
	this.zones[7] = troshx_core_ZoneBody.create("to the Arms",[1,2,1,2],["hand","forearm","elbow","upper_arm_and_shoulder"]);
	this.zones[8] = troshx_core_ZoneBody.create("to the Lower Legs",[1,3,1,1],["foot","shin_and_lower_leg","knee_and_nearby_areas",""]);
	this.zones[9] = troshx_core_ZoneBody.create("to the Upper Legs",[2,3,1],["knee_and_nearby_areas","thigh","hip"]);
	this.zones[10] = troshx_core_ZoneBody.create("to the Pelvis",[2,2,2],["hip","groin","lower_abdomen"]);
	this.zones[11] = troshx_core_ZoneBody.create("to the Belly",[5,1],["lower_abdomen","flesh_to_the_side"]);
	this.zones[12] = troshx_core_ZoneBody.create("to the Chest",[2,4],["upper_abdomen","chest"]);
	this.zones[13] = troshx_core_ZoneBody.create("to the Head",[2,4],["collar_and_throat",["face","face","face","head","head"]]);
	this.zones[14] = troshx_core_ZoneBody.create("to the Arm",[1,2,1,2],["hand","forearm","elbow","upper_arm"]);
	this.zonesB[1] = troshx_core_ZoneBody.create("to the Lower Legs",[1,3,2],["foot","shin_and_lower_leg","knee_and_nearby_areas"]);
	this.zonesB[2] = troshx_core_ZoneBody.create("to the Upper Legs",[2,3,1],["knee_and_nearby_areas","thigh","hip"]);
	this.zonesB[3] = troshx_core_ZoneBody.create("for Horizontal Swing",[1,1,1,2,1],["hip","upper_abdomen","lower_abdomen","ribcage","arms"]);
	this.zonesB[4] = troshx_core_ZoneBody.create("for Overhand Swing",[2,1,1,1,1],["upper_arm_and_shoulder","upper_body","neck","lower_head","upper_head"]);
	this.zonesB[5] = troshx_core_ZoneBody.create("for Downward Swing from Above",[2,1,3],["shoulder","lower_head","upper_head"]);
	this.zonesB[6] = troshx_core_ZoneBody.create("for Upward Swing from Below",[3,1,1,1],["inner_thigh","groin","abdomen","lower_head"]);
	this.zonesB[7] = troshx_core_ZoneBody.create("to the Arms",[1,2,1,2],["hand","forearm","elbow","upper_arm_and_shoulder"]);
	this.zonesB[8] = troshx_core_ZoneBody.create("to the Lower Legs",[1,3,1,1],["foot","shin_and_lower_leg","knee_and_nearby_areas",""]);
	this.zonesB[9] = troshx_core_ZoneBody.create("to the Upper Legs",[2,3,1],["knee_and_nearby_areas","thigh","hip"]);
	this.zonesB[10] = troshx_core_ZoneBody.create("to the Pelvis",[2,2,2],["hip","groin","lower_abdomen"]);
	this.zonesB[11] = troshx_core_ZoneBody.create("to the Belly",[6],["lower_abdomen"]);
	this.zonesB[12] = troshx_core_ZoneBody.create("to the Chest",[2,4],["upper_abdomen","chest"]);
	this.zonesB[13] = troshx_core_ZoneBody.create("to the Head",[1,3,2],["neck",["face","face","face","lower_head","lower_head"],"upper_head"]);
	this.zonesB[14] = troshx_core_ZoneBody.create("to the Arm",[1,2,1,2],["hand","forearm","elbow","upper_arm_and_shoulder"]);
	this.partsBludgeon.lower_abdomen = this.partsBludgeon.abdomen;
	this.partsBludgeon.arms = this.partsBludgeon.upper_arm_and_shoulder;
	this.partsBludgeon.shoulder = this.partsBludgeon.upper_arm_and_shoulder;
	this.partsCut.lower_abdomen = this.partsCut.abdomen;
	this.partsCut.upper_abdomen = this.partsCut.abdomen;
	this.partsCut.arms = this.partsCut.upper_arm_and_shoulder;
	this.centerOfMass = troshx_tros_HumanoidBody.CENTER_OF_MASS;
	this.centerOfMassT = troshx_tros_HumanoidBody.CENTER_OF_MASS_T;
};
$hxClasses["troshx.tros.HumanoidBody"] = troshx_tros_HumanoidBody;
troshx_tros_HumanoidBody.__name__ = ["troshx","tros","HumanoidBody"];
troshx_tros_HumanoidBody.getInstance = function() {
	if(troshx_tros_HumanoidBody.INSTANCE != null) {
		return troshx_tros_HumanoidBody.INSTANCE;
	} else {
		return troshx_tros_HumanoidBody.INSTANCE = new troshx_tros_HumanoidBody();
	}
};
troshx_tros_HumanoidBody.__super__ = troshx_core_BodyChar;
troshx_tros_HumanoidBody.prototype = $extend(troshx_core_BodyChar.prototype,{
	__class__: troshx_tros_HumanoidBody
});
var troshx_tros_ManueverSheet = $hx_exports["troshx"]["tros"]["ManueverSheet"] = function() {
};
$hxClasses["troshx.tros.ManueverSheet"] = troshx_tros_ManueverSheet;
troshx_tros_ManueverSheet.__name__ = ["troshx","tros","ManueverSheet"];
troshx_tros_ManueverSheet.getManueverById = function(id) {
	return null;
};
troshx_tros_ManueverSheet.isDamagingManuever = function(ms) {
	if(!(ms == "cut" || ms == "spike" || ms == "thrust")) {
		return ms == "bash";
	} else {
		return true;
	}
};
troshx_tros_ManueverSheet.prototype = {
	__class__: troshx_tros_ManueverSheet
};
var troshx_tros_WeaponSheet = $hx_exports["troshx"]["tros"]["WeaponSheet"] = function() {
};
$hxClasses["troshx.tros.WeaponSheet"] = troshx_tros_WeaponSheet;
troshx_tros_WeaponSheet.__name__ = ["troshx","tros","WeaponSheet"];
troshx_tros_WeaponSheet.getWeaponByName = function(name) {
	var _this = troshx_tros_WeaponSheet.HASH;
	if(__map_reserved[name] != null) {
		return _this.getReserved(name);
	} else {
		return _this.h[name];
	}
};
troshx_tros_WeaponSheet.weaponNameIsShield = function(name) {
	var weap = troshx_tros_WeaponSheet.getWeaponByName(name);
	if(weap != null) {
		return weap.shield;
	} else {
		return false;
	}
};
troshx_tros_WeaponSheet.weaponIsShield = function(weapon) {
	return weapon.shield;
};
troshx_tros_WeaponSheet.createHashLookupViaName = function(arr) {
	var obj = new haxe_ds_StringMap();
	var _g1 = 0;
	var _g = arr.length;
	while(_g1 < _g) {
		var lookinFor = arr[_g1++];
		var key = lookinFor.name;
		if(__map_reserved[key] != null) {
			obj.setReserved(key,lookinFor);
		} else {
			obj.h[key] = lookinFor;
		}
	}
	return obj;
};
troshx_tros_WeaponSheet.prototype = {
	__class__: troshx_tros_WeaponSheet
};
var troshx_util_AIManueverChoice = $hx_exports["troshx"]["util"]["AIManueverChoice"] = function() {
};
$hxClasses["troshx.util.AIManueverChoice"] = troshx_util_AIManueverChoice;
troshx_util_AIManueverChoice.__name__ = ["troshx","util","AIManueverChoice"];
troshx_util_AIManueverChoice.prototype = {
	manuever: null
	,manueverCP: null
	,manueverTN: null
	,targetZone: null
	,manueverType: null
	,offhand: null
	,againstID: null
	,cost: null
	,getManueverCPSpent: function() {
		return this.cost + this.manueverCP;
	}
	,secondary: null
	,nothing: function() {
		this.manuever = "";
		this.manueverCP = 0;
		this.targetZone = 0;
		this.manueverType = 0;
		this.offhand = false;
		this.againstID = 0;
		this.secondary = null;
	}
	,waitForQuickDefense: function() {
		this.manuever = "";
		this.manueverCP = 0;
		this.targetZone = 0;
		this.manueverType = 0;
		this.offhand = false;
		this.againstID = 0;
		this.secondary = null;
		this.manuever = troshx_util_AIManueverChoice.DO_NOTHING_WAIT_FOR_DEFENSE;
		this.manueverType = 1;
	}
	,setupSecondAttack: function(manuever,manueverCP,manueverTN,targetZone,cost,offhand) {
		if(offhand == null) {
			offhand = false;
		}
		if(this.secondary == null) {
			this.secondary = new troshx_util_AIManueverChoice();
		}
		this.secondary.setAttack(manuever,manueverCP,manueverTN,targetZone,cost,offhand);
	}
	,setupSecondDefend: function(manuever,manueverCP,manueverTN,targetZone,cost,offhand) {
		if(offhand == null) {
			offhand = false;
		}
		if(this.secondary == null) {
			this.secondary = new troshx_util_AIManueverChoice();
		}
		this.secondary.setDefend(manuever,manueverCP,manueverTN,cost,offhand);
	}
	,copyTo: function(newChoice,newAgainstID) {
		if(newAgainstID == null) {
			newAgainstID = -1;
		}
		newChoice.manuever = this.manuever;
		newChoice.manueverCP = this.manueverCP;
		newChoice.targetZone = this.targetZone;
		newChoice.manueverType = this.manueverType;
		newChoice.offhand = this.offhand;
		newChoice.manueverTN = this.manueverTN;
		newChoice.againstID = newAgainstID >= 0?newAgainstID:this.againstID;
	}
	,setAttack: function(manuever,manueverCP,manueverTN,targetZone,cost,offhand) {
		if(offhand == null) {
			offhand = false;
		}
		this.manuever = manuever;
		this.manueverCP = manueverCP;
		this.targetZone = targetZone;
		this.offhand = offhand;
		this.manueverType = 2;
		this.manueverTN = manueverTN;
		this.cost = cost;
		this.secondary = null;
	}
	,setDefend: function(manuever,manueverCP,manueverTN,cost,offhand) {
		if(offhand == null) {
			offhand = false;
		}
		this.manuever = manuever;
		this.manueverCP = manueverCP;
		this.targetZone = 0;
		this.offhand = offhand;
		this.manueverType = 1;
		this.manueverTN = manueverTN;
		this.cost = cost;
		this.secondary = null;
	}
	,__class__: troshx_util_AIManueverChoice
};
var troshx_tros_ai_TROSAiBot = $hx_exports["troshx"]["tros"]["ai"]["TROSAiBot"] = function() {
	this.decidedManuevers = [new troshx_util_AIManueverChoice(),new troshx_util_AIManueverChoice(),new troshx_util_AIManueverChoice(),new troshx_util_AIManueverChoice()];
	this.handsUsedUp = 0;
	this.manueverUsingHands = 0;
	this.mobility = 6;
	this.perception = 4;
	this.currentExchange = 0;
	this.plannedCombos = [0,0,0,0];
	this.cpBudget = [];
	this.opponentLen = 0;
	this.opponents = [];
};
$hxClasses["troshx.tros.ai.TROSAiBot"] = troshx_tros_ai_TROSAiBot;
troshx_tros_ai_TROSAiBot.__name__ = ["troshx","tros","ai","TROSAiBot"];
troshx_tros_ai_TROSAiBot.getTargetAlphaStrikeCPThreshold = function() {
	return troshx_tros_ai_TROSAiBot.ENEMY_STEAL_COST + 1 + troshx_tros_ai_TROSAiBot.MIN_EXPOSED_AV;
};
troshx_tros_ai_TROSAiBot.setAlphaStrikeBudget = function(cp,cp2) {
	var minCP = troshx_tros_ai_TROSAiBot.ENEMY_STEAL_COST + 1 + troshx_tros_ai_TROSAiBot.MIN_EXPOSED_AV - 1;
	if(cp2 > minCP) {
		minCP = cp2 - minCP;
	} else {
		minCP = 0;
	}
	troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0] = cp - minCP;
	troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[3] = cp2;
	troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[2] = minCP;
	troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[3] = -1;
};
troshx_tros_ai_TROSAiBot.setTypicalAVAILCostsForTesting = function() {
	troshx_tros_ai_TROSAiBot.AVAIL_bash = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_spike = 0;
	troshx_tros_ai_TROSAiBot.AVAIL_cut = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_thrust = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_beat = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_bindstrike = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_hook = 2;
	troshx_tros_ai_TROSAiBot.AVAIL_block = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_parry = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_duckweave = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_partialevasion = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_fullevasion = 1;
	troshx_tros_ai_TROSAiBot.AVAIL_blockopenstrike = 3;
	troshx_tros_ai_TROSAiBot.AVAIL_counter = 3;
	troshx_tros_ai_TROSAiBot.AVAIL_rota = 3;
	troshx_tros_ai_TROSAiBot.AVAIL_expulsion = 3;
	troshx_tros_ai_TROSAiBot.AVAIL_disarm = 2;
	troshx_tros_ai_TROSAiBot.AVAIL_StealInitiative = 5;
};
troshx_tros_ai_TROSAiBot.getCostOfAVAIL = function(avail) {
	return avail - 1;
};
troshx_tros_ai_TROSAiBot.getCostOfManuever = function(manuever) {
	switch(manuever) {
	case "bash":
		return troshx_tros_ai_TROSAiBot.AVAIL_bash - 1;
	case "beat":
		return troshx_tros_ai_TROSAiBot.AVAIL_beat - 1;
	case "bindstrike":
		return troshx_tros_ai_TROSAiBot.AVAIL_bindstrike - 1;
	case "block":
		return troshx_tros_ai_TROSAiBot.AVAIL_block - 1;
	case "blockopenstrike":
		return troshx_tros_ai_TROSAiBot.AVAIL_blockopenstrike - 1;
	case "counter":
		return troshx_tros_ai_TROSAiBot.AVAIL_counter - 1;
	case "cut":
		return troshx_tros_ai_TROSAiBot.AVAIL_cut - 1;
	case "disarm":
		return troshx_tros_ai_TROSAiBot.AVAIL_disarm - 1;
	case "duckweave":
		return troshx_tros_ai_TROSAiBot.AVAIL_duckweave - 1;
	case "expulsion":
		return troshx_tros_ai_TROSAiBot.AVAIL_expulsion - 1;
	case "fullevasion":
		return troshx_tros_ai_TROSAiBot.AVAIL_fullevasion - 1;
	case "hook":
		return troshx_tros_ai_TROSAiBot.AVAIL_hook - 1;
	case "parry":
		return troshx_tros_ai_TROSAiBot.AVAIL_parry - 1;
	case "partialevasion":
		return troshx_tros_ai_TROSAiBot.AVAIL_partialevasion - 1;
	case "rota":
		return troshx_tros_ai_TROSAiBot.AVAIL_rota - 1;
	case "spike":
		return troshx_tros_ai_TROSAiBot.AVAIL_spike - 1;
	case "thrust":
		return troshx_tros_ai_TROSAiBot.AVAIL_thrust - 1;
	}
	return 0;
};
troshx_tros_ai_TROSAiBot.getRegularAttackOrAdvantageMove = function(availableCP,roll,againstRoll,againstTN) {
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = -1;
	}
	if(roll == null) {
		roll = 0;
	}
	var str = troshx_tros_ai_TROSAiBot.getRegularAttack(availableCP,roll,againstRoll,againstTN);
	var curAggr = -999;
	var regularStr = null;
	troshx_tros_ai_TROSAiBot.B_USE_ADVANTAGE = false;
	if(str != null) {
		curAggr = troshx_tros_ai_TROSAiBot.ATTACK_AGGR;
		regularStr = str;
	}
	str = troshx_tros_ai_TROSAiBot.getRegularAdvantageMove(availableCP,roll,againstRoll,againstTN);
	if(str != null && troshx_tros_ai_TROSAiBot.ATTACK_AGGR > curAggr) {
		curAggr = troshx_tros_ai_TROSAiBot.ATTACK_AGGR;
		troshx_tros_ai_TROSAiBot.B_USE_ADVANTAGE = true;
		return str;
	}
	return regularStr;
};
troshx_tros_ai_TROSAiBot.getRegularAdvantageMove = function(availableCP,roll,againstRoll,againstTN) {
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = -1;
	}
	if(roll == null) {
		roll = 0;
	}
	troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
	var weapon = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.B_EQUIP);
	var tn = weapon != null?weapon.atn:888;
	var tn2 = weapon != null?weapon.atn2:888;
	var cost;
	var aggr;
	if(roll == 0) {
		roll = availableCP;
	}
	var tnP = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
	var tn2P = tn2 < 11?(10 - tn2 + 1) / 10:(1 - (tn2 - Math.floor(tn2 / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn2 / 10));
	var gotEnemyRoll = againstRoll >= 0;
	var aggrCur = -999;
	if(troshx_tros_ai_TROSAiBot.AVAIL_beat > 0 && tn != 888) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_beat - 1;
		if(cost < availableCP) {
			var tn1 = troshx_tros_ai_TROSAiBot.getATNOfManuever("beat");
			if(gotEnemyRoll) {
				aggr = Math.round(troshx_util_TROSAI.getChanceToSucceedContest(roll - cost,tn1,againstRoll,againstTN,1) * 1000);
			} else {
				aggr = tnP * (roll - cost);
			}
			if(aggr > 0 && aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "beat";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_bindstrike > 0) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_bindstrike - 1;
		if(cost < availableCP) {
			if(gotEnemyRoll) {
				aggr = Math.round(troshx_util_TROSAI.getChanceToSucceedContest(roll - cost,troshx_tros_ai_TROSAiBot.getATNOfManuever("bindstrike"),againstRoll,againstTN,1) * 1000);
			} else {
				aggr = Math.min(tnP,tn2P) * (roll - cost);
			}
			if(aggr > 0 && aggr > aggrCur) {
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "bindstrike";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT == 0) {
		return null;
	}
	troshx_tros_ai_TROSAiBot.ATTACK_AGGR = aggrCur;
	return troshx_tros_ai_TROSAiBot.B_CANDIDATES[Math.random() * troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT | 0];
};
troshx_tros_ai_TROSAiBot.mathMax = function(a,b) {
	if(a >= b) {
		return a;
	} else {
		return b;
	}
};
troshx_tros_ai_TROSAiBot.enforceDmgAggrIfFav = function(val) {
	return Math.round(val * 1000) + (val >= troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE?1000:0);
};
troshx_tros_ai_TROSAiBot.getRegularAttack = function(availableCP,roll,againstRoll,againstTN) {
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = -1;
	}
	if(roll == null) {
		roll = 0;
	}
	troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
	var weapon = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.B_EQUIP);
	var tn = weapon != null?weapon.atn:888;
	var tn2 = weapon != null?weapon.atn2:888;
	var cost;
	var aggr;
	if(roll == 0) {
		roll = availableCP;
	}
	var tnP = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
	var tn2P = tn2 < 11?(10 - tn2 + 1) / 10:(1 - (tn2 - Math.floor(tn2 / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn2 / 10));
	var gotEnemyRoll = againstRoll >= 0;
	var dmg = weapon != null && gotEnemyRoll?weapon.damage:0;
	var dmgT = weapon != null && gotEnemyRoll?weapon.damage2:0;
	var aggrCur = -999;
	if(troshx_tros_ai_TROSAiBot.AVAIL_bash > 0 && tn != 888) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_bash - 1;
		if(cost < availableCP) {
			if(gotEnemyRoll) {
				aggr = troshx_tros_ai_TROSAiBot.enforceDmgAggrIfFav(troshx_util_TROSAI.getChanceToSucceedContest(roll - cost,tn,againstRoll,againstTN,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT,true)) + dmg / 10;
			} else {
				aggr = tnP * (roll - cost);
			}
			if(aggr > 0 && aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "bash";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_cut > 0 && tn != 888) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_cut - 1;
		if(cost < availableCP) {
			if(gotEnemyRoll) {
				aggr = troshx_tros_ai_TROSAiBot.enforceDmgAggrIfFav(troshx_util_TROSAI.getChanceToSucceedContest(roll - cost,tn,againstRoll,againstTN,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT,true)) + dmg / 10;
			} else {
				aggr = tnP * (roll - cost);
			}
			if(aggr > 0 && aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "cut";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_spike > 0 && tn2 != 888) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_spike - 1;
		if(cost < availableCP) {
			if(gotEnemyRoll) {
				aggr = troshx_tros_ai_TROSAiBot.enforceDmgAggrIfFav(troshx_util_TROSAI.getChanceToSucceedContest(roll - cost,tn2,againstRoll,againstTN,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT,true)) + dmgT / 10;
			} else {
				aggr = tn2P * (roll - cost);
			}
			if(aggr > 0 && aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "spike";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_thrust > 0 && tn2 != 888) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_thrust - 1;
		if(cost < availableCP) {
			if(gotEnemyRoll) {
				aggr = troshx_tros_ai_TROSAiBot.enforceDmgAggrIfFav(troshx_util_TROSAI.getChanceToSucceedContest(roll - cost,tn2,againstRoll,againstTN,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT,true)) + dmgT / 10;
			} else {
				aggr = tn2P * (roll - cost);
			}
			if(aggr > 0 && aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "thrust";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT == 0) {
		return null;
	}
	troshx_tros_ai_TROSAiBot.ATTACK_AGGR = aggrCur;
	return troshx_tros_ai_TROSAiBot.B_CANDIDATES[Math.random() * troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT | 0];
};
troshx_tros_ai_TROSAiBot.getRegularDefense = function(availableCP,roll,enforceMustRegainInitiative) {
	if(enforceMustRegainInitiative == null) {
		enforceMustRegainInitiative = false;
	}
	if(roll == null) {
		roll = 0;
	}
	troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
	var weapon = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.B_EQUIP);
	var offhand = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.D_EQUIP);
	var tn = weapon != null?weapon.dtn:888;
	var tnOff = offhand != null?offhand.dtn:888;
	var tnP = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
	var tnPOff = tnOff < 11?(10 - tnOff + 1) / 10:(1 - (tnOff - Math.floor(tnOff / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tnOff / 10));
	var aggr;
	var aggrCur = -999;
	if(roll == 0) {
		roll = availableCP;
	}
	var cost;
	if(troshx_tros_ai_TROSAiBot.AVAIL_block > 0 && tnPOff != 888) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_block - 1;
		if(cost < roll) {
			aggr = tnPOff * (roll - cost);
			if(aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "block";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_parry > 0 && tnP != 888) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_parry - 1;
		if(cost < availableCP) {
			aggr = tnP * (roll - cost);
			if(aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "parry";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_partialevasion > 0) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_partialevasion - 1;
		if(cost + (enforceMustRegainInitiative?2:0) < availableCP) {
			aggr = 0.4 * (roll - cost - .00000001);
			if(aggr >= aggrCur) {
				if(aggr != aggrCur) {
					troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
				}
				troshx_tros_ai_TROSAiBot.B_CANDIDATES[troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT++] = "partialevasion";
				aggrCur = aggr;
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT == 0) {
		return null;
	}
	return troshx_tros_ai_TROSAiBot.B_CANDIDATES[Math.random() * troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT | 0];
};
troshx_tros_ai_TROSAiBot.getATNOfManuever = function(manuever) {
	var weapon = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.B_EQUIP);
	var weaponOff = troshx_tros_ai_TROSAiBot.B_IS_OFFHAND?weapon:troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.D_EQUIP);
	var tn = weapon != null?weapon.atn:888;
	var tn2 = weapon != null?weapon.atn2:888;
	var tnOff = weaponOff != null?weaponOff.shield?weaponOff.dtn:weaponOff.atn:888;
	switch(manuever) {
	case "bash":
		return tn;
	case "beat":
		return tn;
	case "bindstrike":
		return tnOff;
	case "cut":
		return tn;
	case "disarm":
		return tn;
	case "hook":
		if(weapon != null) {
			return weapon.getHookingATN();
		} else {
			return 888;
		}
		break;
	case "spike":
		return tn2;
	case "thrust":
		return tn2;
	}
	return 0;
};
troshx_tros_ai_TROSAiBot.isFleeingManuever = function(manueverName) {
	return manueverName == "fullevasion";
};
troshx_tros_ai_TROSAiBot.getDTNOfManuever = function(manuever) {
	var weapon = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.B_EQUIP);
	var offhand = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.D_EQUIP);
	var tn = weapon != null?weapon.dtn:888;
	var tnOff = offhand != null?offhand.dtn:888;
	switch(manuever) {
	case "block":
		return tnOff;
	case "blockopenstrike":
		return tn;
	case "counter":
		return tn;
	case "disarm":
		return tn;
	case "duckweave":
		return 9;
	case "expulsion":
		return tn;
	case "fullevasion":
		return 4;
	case "parry":
		return tn;
	case "partialevasion":
		return 7;
	case "rota":
		return tn;
	}
	return 0;
};
troshx_tros_ai_TROSAiBot.getFollowupAtkManuever = function(favorable,lastManuever,availableCPWithBonus,againstCP,customThreshold) {
	if(customThreshold == null) {
		customThreshold = 0;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getTargetZoneAverageAVOffset = function(tarZone,weaponName) {
	return 0;
};
troshx_tros_ai_TROSAiBot.getRegularTargetZone = function(manuever,atn,cp) {
	return 1 + (Math.random() * (troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.zones.length - 1) | 0);
};
troshx_tros_ai_TROSAiBot.checkCostViability = function(availableCP,tn,threshold,againstRoll,againstTN,useAllCP) {
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	var min;
	var accum;
	if(useAllCP) {
		min = availableCP;
	} else if(troshx_tros_ai_TROSAiBot.B_BS_REQUIRED > 1) {
		min = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED;
	} else {
		min = 1;
	}
	var _g1 = min;
	var _g = availableCP + 1;
	while(_g1 < _g) {
		var c = _g1++;
		accum = Math.round(troshx_util_TROSAI.getChanceToSucceedContest(c,tn,againstRoll,againstTN,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED,true) / 0.01) * 0.01;
		if(accum >= threshold) {
			troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY = accum;
			return c;
		}
	}
	return 0;
};
troshx_tros_ai_TROSAiBot.checkCostViabilityWithBs = function(availableCP,tn,threshold,againstRoll,againstTN,useAllCP,bs) {
	if(bs == null) {
		bs = 1;
	}
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	var lastBS = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED;
	troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = bs;
	var result = troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,tn,threshold,againstRoll,againstTN,useAllCP);
	troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = lastBS;
	return result;
};
troshx_tros_ai_TROSAiBot.precisionPerc = function(val) {
	return Math.round(val / 0.01) * 0.01;
};
troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline = function(availableCP,tn,threshold,againstRoll,againstTN,useAllCP) {
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	var accum;
	var bsRequired = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED > 1?troshx_tros_ai_TROSAiBot.B_BS_REQUIRED:1;
	var _g1 = useAllCP?availableCP:bsRequired;
	var _g = availableCP + 1;
	while(_g1 < _g) {
		var c = _g1++;
		var successProbabilitWithBS = troshx_util_TROSAI.getChanceToSucceedContest(c,tn,againstRoll,againstTN,bsRequired,true);
		accum = Math.round((successProbabilitWithBS + troshx_util_TROSAI.getChanceToSucceedContest(c,tn,againstRoll,againstTN,bsRequired - 1,false)) * 0.5 / 0.01) * 0.01;
		if(accum >= threshold) {
			if(successProbabilitWithBS == 0) {
				return 0;
			}
			troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY = successProbabilitWithBS;
			if(useAllCP) {
				return availableCP;
			} else {
				return c;
			}
		}
	}
	return 0;
};
troshx_tros_ai_TROSAiBot.checkCostAntiFavorability = function(availableCP,tn,threshold,againstCP,againstTN,useAllCP,offset,requiredBS) {
	if(requiredBS == null) {
		requiredBS = 1;
	}
	if(offset == null) {
		offset = 0;
	}
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	var accum;
	var cpToUse = 0;
	var _g1 = 1;
	var _g = availableCP + 1;
	while(_g1 < _g) {
		var c = _g1++;
		accum = Math.round(troshx_util_TROSAI.getChanceToSucceedContest(againstCP,againstTN,c,tn,requiredBS,true) / 0.01) * 0.01;
		if(accum < threshold) {
			cpToUse = c;
			break;
		}
	}
	if(cpToUse != 0) {
		if(useAllCP) {
			cpToUse = availableCP;
		} else {
			cpToUse += offset;
			if(cpToUse <= 0) {
				cpToUse = 1;
			}
			if(cpToUse > availableCP) {
				cpToUse = availableCP;
			}
		}
		troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_util_TROSAI.getChanceToSucceedContest(cpToUse,tn,againstCP,againstTN,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED,true);
	}
	return cpToUse;
};
troshx_tros_ai_TROSAiBot.checkCostAntiBorderline = function(availableCP,tn,threshold,againstCP,againstTN,useAllCP,offset) {
	if(offset == null) {
		offset = 0;
	}
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	var accum;
	var cpToUse = 0;
	var successProbabilitWith1BS = .0;
	var _g1 = 1;
	var _g = availableCP + 1;
	while(_g1 < _g) {
		var c = _g1++;
		successProbabilitWith1BS = troshx_util_TROSAI.getChanceToSucceedContest(againstCP,againstTN,c,tn,1,true);
		accum = Math.round((successProbabilitWith1BS + troshx_util_TROSAI.getChanceToSucceedContest(againstCP,againstTN,c,tn,0)) * 0.5 / 0.01) * 0.01;
		if(accum < threshold) {
			cpToUse = c;
			break;
		}
	}
	if(cpToUse != 0) {
		if(useAllCP) {
			cpToUse = availableCP;
		} else {
			cpToUse += offset;
			if(cpToUse <= 0) {
				cpToUse = 1;
			}
			if(cpToUse > availableCP) {
				cpToUse = availableCP;
			}
		}
		troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_util_TROSAI.getChanceToSucceedContest(cpToUse,tn,againstCP,againstTN,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED,true);
	}
	return cpToUse;
};
troshx_tros_ai_TROSAiBot.getCostOfAvail = function(avail) {
	return avail - 1;
};
troshx_tros_ai_TROSAiBot.getTheSuitableAttack = function(manuever,tn,tarZone,threshold,availableCP,againstRoll,againstTN,favorable,useAllCP) {
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(favorable == null) {
		favorable = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var cpToUse = favorable?troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,tn,threshold,againstRoll,againstTN,useAllCP):troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(availableCP,tn,threshold,againstRoll,againstTN,useAllCP);
	if(cpToUse > 0) {
		troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack(manuever,cpToUse,tn,tarZone,troshx_tros_ai_TROSAiBot.getCostOfManuever(manuever),troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getTheSuitableDefense = function(manuever,tn,threshold,availableCP,againstRoll,againstTN,favorable,useAllCP) {
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(favorable == null) {
		favorable = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var cpToUse = favorable?troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,tn,threshold,againstRoll,againstTN,useAllCP):troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(availableCP,tn,threshold,againstRoll,againstTN,useAllCP);
	if(cpToUse > 0) {
		troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend(manuever,cpToUse,tn,troshx_tros_ai_TROSAiBot.getCostOfManuever(manuever),troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getTheForcefulInitiativeAttack = function(manuever,tn,tarZone,threshold,availableCP,againstCP,againstTN,favorable,useAllCP,offset) {
	if(offset == null) {
		offset = 0;
	}
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(favorable == null) {
		favorable = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstCP == null) {
		againstCP = 0;
	}
	var cpToUse = favorable?troshx_tros_ai_TROSAiBot.checkCostAntiFavorability(availableCP,tn,threshold,againstCP,againstTN,useAllCP,offset):troshx_tros_ai_TROSAiBot.checkCostAntiBorderline(availableCP,tn,threshold,againstCP,againstTN,useAllCP,offset);
	if(cpToUse > 0) {
		troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack(manuever,cpToUse,tn,tarZone,troshx_tros_ai_TROSAiBot.getCostOfManuever(manuever),troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getASuitableAttack = function(threshold,availableCP,againstRoll,againstTN,favorable,useAllCP) {
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(favorable == null) {
		favorable = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
	var manuever = troshx_tros_ai_TROSAiBot.getRegularAttack(availableCP,0,againstRoll,againstTN);
	if(manuever != null) {
		availableCP -= troshx_tros_ai_TROSAiBot.getCostOfManuever(manuever);
		var tn = troshx_tros_ai_TROSAiBot.getATNOfManuever(manuever);
		var tarZone = troshx_tros_ai_TROSAiBot.getRegularTargetZone(manuever,tn,availableCP);
		if(tarZone != 0) {
			availableCP -= troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.getTargetZoneCost(tarZone);
			return troshx_tros_ai_TROSAiBot.getTheSuitableAttack(manuever,tn,tarZone,threshold,availableCP,againstRoll,againstTN,favorable,useAllCP);
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getAForcefulInitiativeAttack = function(threshold,availableCP,againstCP,againstTN,favorable,useAllCP,offset) {
	if(offset == null) {
		offset = 0;
	}
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(favorable == null) {
		favorable = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstCP == null) {
		againstCP = 0;
	}
	var manuever = troshx_tros_ai_TROSAiBot.getRegularAttackOrAdvantageMove(availableCP,0,againstCP,againstTN);
	troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_USE_ADVANTAGE?1:troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
	if(manuever != null) {
		availableCP -= troshx_tros_ai_TROSAiBot.getCostOfManuever(manuever);
		var tn = troshx_tros_ai_TROSAiBot.getATNOfManuever(manuever);
		var tarZone = troshx_tros_ai_TROSAiBot.getRegularTargetZone(manuever,tn,availableCP);
		if(tarZone != 0) {
			if(troshx_tros_ai_TROSAiBot.getTheForcefulInitiativeAttack(manuever,tn,tarZone,threshold,availableCP,againstCP,againstTN,favorable,useAllCP,offset)) {
				return true;
			}
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getASuitableDefense = function(threshold,availableCP,againstRoll,againstTN,mustRegainInitiative,favorable,useAllCP) {
	if(useAllCP == null) {
		useAllCP = false;
	}
	if(favorable == null) {
		favorable = true;
	}
	if(mustRegainInitiative == null) {
		mustRegainInitiative = false;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
	var manuever = troshx_tros_ai_TROSAiBot.getRegularDefense(availableCP,0,mustRegainInitiative);
	if(manuever != null) {
		availableCP -= troshx_tros_ai_TROSAiBot.getCostOfManuever(manuever);
		return troshx_tros_ai_TROSAiBot.getTheSuitableDefense(manuever,troshx_tros_ai_TROSAiBot.getDTNOfManuever(manuever),threshold,availableCP,againstRoll,againstTN,favorable,useAllCP);
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getFavorableAttack = function(availableCP,againstRoll,againstTN,heuristic,flags,customThreshold) {
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	return troshx_tros_ai_TROSAiBot.getFBAttack(true,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold);
};
troshx_tros_ai_TROSAiBot.getBorderlineAttack = function(availableCP,againstRoll,againstTN,heuristic,flags,customThreshold) {
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	return troshx_tros_ai_TROSAiBot.getFBAttack(false,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold);
};
troshx_tros_ai_TROSAiBot.getFBAttack = function(favorable,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold) {
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var threshold = customThreshold != 0?customThreshold:favorable?troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE:troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE;
	troshx_tros_ai_TROSAiBot.B_VIABLE_HEURISTIC = false;
	if(heuristic && troshx_tros_ai_TROSAiBot.getASuitableAttack(threshold,availableCP,againstRoll,againstTN,favorable,(flags & 2) != 0)) {
		troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
		troshx_tros_ai_TROSAiBot.B_VIABLE_HEURISTIC = true;
		return true;
	}
	var cp = availableCP;
	var cpToUse;
	var useCheapestMult = (flags & 1) != 0?1:0;
	var aggr;
	troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
	var curAggr = 9999999999999;
	var tn;
	var checkCostFunc = favorable?troshx_tros_ai_TROSAiBot.checkCostViability:troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline;
	if(troshx_tros_ai_TROSAiBot.AVAIL_bash > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
		cp = availableCP - (troshx_tros_ai_TROSAiBot.AVAIL_bash - 1);
		if(cp > 0) {
			tn = troshx_tros_ai_TROSAiBot.getATNOfManuever("bash");
			var _g1 = 1;
			var _g = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.thrustStartIndex;
			while(_g1 < _g) {
				var i = _g1++;
				troshx_tros_ai_TROSAiBot.B_BS_REQUIRED += troshx_tros_ai_TROSAiBot.getTargetZoneAverageAVOffset(i,troshx_tros_ai_TROSAiBot.B_EQUIP);
				cpToUse = checkCostFunc(cp,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
				if(cpToUse > 0) {
					aggr = useCheapestMult * cpToUse + (1 - troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY);
					if(aggr <= curAggr) {
						if(aggr != curAggr) {
							troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
						}
						troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack("bash",cpToUse,tn,i,troshx_tros_ai_TROSAiBot.AVAIL_bash - 1,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
						var index = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
						var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
						var newChoice = index >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index];
						newChoice.manuever = _this.manuever;
						newChoice.manueverCP = _this.manueverCP;
						newChoice.targetZone = _this.targetZone;
						newChoice.manueverType = _this.manueverType;
						newChoice.offhand = _this.offhand;
						newChoice.manueverTN = _this.manueverTN;
						newChoice.againstID = _this.againstID;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
						curAggr = aggr;
					}
				}
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_spike > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
		cp = availableCP - (troshx_tros_ai_TROSAiBot.AVAIL_spike - 1);
		if(cp > 0) {
			tn = troshx_tros_ai_TROSAiBot.getATNOfManuever("spike");
			var _g11 = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.thrustStartIndex;
			var _g2 = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.zones.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				troshx_tros_ai_TROSAiBot.B_BS_REQUIRED += troshx_tros_ai_TROSAiBot.getTargetZoneAverageAVOffset(i1,troshx_tros_ai_TROSAiBot.B_EQUIP);
				cpToUse = checkCostFunc(cp,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
				if(cpToUse > 0) {
					aggr = useCheapestMult * cpToUse + (1 - troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY);
					if(aggr <= curAggr) {
						if(aggr != curAggr) {
							troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
						}
						troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack("spike",cpToUse,tn,i1,troshx_tros_ai_TROSAiBot.AVAIL_spike - 1,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
						var index1 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
						var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
						var newChoice1 = index1 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index1] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index1];
						newChoice1.manuever = _this1.manuever;
						newChoice1.manueverCP = _this1.manueverCP;
						newChoice1.targetZone = _this1.targetZone;
						newChoice1.manueverType = _this1.manueverType;
						newChoice1.offhand = _this1.offhand;
						newChoice1.manueverTN = _this1.manueverTN;
						newChoice1.againstID = _this1.againstID;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
						curAggr = aggr;
					}
				}
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_cut > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
		cp = availableCP - (troshx_tros_ai_TROSAiBot.AVAIL_cut - 1);
		if(cp > 0) {
			tn = troshx_tros_ai_TROSAiBot.getATNOfManuever("cut");
			var _g12 = 1;
			var _g3 = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.thrustStartIndex;
			while(_g12 < _g3) {
				var i2 = _g12++;
				troshx_tros_ai_TROSAiBot.B_BS_REQUIRED += troshx_tros_ai_TROSAiBot.getTargetZoneAverageAVOffset(i2,troshx_tros_ai_TROSAiBot.B_EQUIP);
				cpToUse = checkCostFunc(cp,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
				if(cpToUse > 0) {
					aggr = useCheapestMult * cpToUse + (1 - troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY);
					if(aggr <= curAggr) {
						if(aggr != curAggr) {
							troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
						}
						troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack("cut",cpToUse,tn,i2,troshx_tros_ai_TROSAiBot.AVAIL_cut - 1,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
						var index2 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
						var _this2 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
						var newChoice2 = index2 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index2] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index2];
						newChoice2.manuever = _this2.manuever;
						newChoice2.manueverCP = _this2.manueverCP;
						newChoice2.targetZone = _this2.targetZone;
						newChoice2.manueverType = _this2.manueverType;
						newChoice2.offhand = _this2.offhand;
						newChoice2.manueverTN = _this2.manueverTN;
						newChoice2.againstID = _this2.againstID;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
						curAggr = aggr;
					}
				}
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_thrust > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
		cp = availableCP - (troshx_tros_ai_TROSAiBot.AVAIL_thrust - 1);
		if(cp > 0) {
			tn = troshx_tros_ai_TROSAiBot.getATNOfManuever("thrust");
			var _g13 = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.thrustStartIndex;
			var _g4 = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.body.zones.length;
			while(_g13 < _g4) {
				var i3 = _g13++;
				troshx_tros_ai_TROSAiBot.B_BS_REQUIRED += troshx_tros_ai_TROSAiBot.getTargetZoneAverageAVOffset(i3,troshx_tros_ai_TROSAiBot.B_EQUIP);
				cpToUse = checkCostFunc(cp,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
				if(cpToUse > 0) {
					aggr = useCheapestMult * cpToUse + (1 - troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY);
					if(aggr <= curAggr) {
						if(aggr != curAggr) {
							troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
						}
						troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack("thrust",cpToUse,tn,i3,troshx_tros_ai_TROSAiBot.AVAIL_thrust - 1,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
						var index3 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
						var _this3 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
						var newChoice3 = index3 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index3] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index3];
						newChoice3.manuever = _this3.manuever;
						newChoice3.manueverCP = _this3.manueverCP;
						newChoice3.targetZone = _this3.targetZone;
						newChoice3.manueverType = _this3.manueverType;
						newChoice3.offhand = _this3.offhand;
						newChoice3.manueverTN = _this3.manueverTN;
						newChoice3.againstID = _this3.againstID;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
						curAggr = aggr;
					}
				}
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT > 0) {
		var randIndex = Math.random() * troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT | 0;
		var _this4 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[randIndex];
		var newChoice4 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
		newChoice4.manuever = _this4.manuever;
		newChoice4.manueverCP = _this4.manueverCP;
		newChoice4.targetZone = _this4.targetZone;
		newChoice4.manueverType = _this4.manueverType;
		newChoice4.offhand = _this4.offhand;
		newChoice4.manueverTN = _this4.manueverTN;
		newChoice4.againstID = _this4.againstID;
		troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[randIndex];
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getFBDefense = function(favorable,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold) {
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var threshold = customThreshold != 0?customThreshold:favorable?troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE:troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE;
	var safetyCost;
	troshx_tros_ai_TROSAiBot.B_VIABLE_HEURISTIC = false;
	var result = heuristic && troshx_tros_ai_TROSAiBot.getASuitableDefense(threshold,availableCP,againstRoll,againstTN,false,favorable,(flags & 2) != 0);
	if(result && (flags & 4) != 0) {
		safetyCost = troshx_tros_ai_TROSAiBot.checkCostAntiFavorability(availableCP,troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverTN,troshx_tros_ai_TROSAiBot.P_RECKLESS,againstRoll,againstTN,false,0,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT);
		if(safetyCost > 0) {
			if(troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverCP < safetyCost) {
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverCP = safetyCost;
			}
		} else {
			result = false;
		}
	}
	if(result) {
		troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
		troshx_tros_ai_TROSAiBot.B_VIABLE_HEURISTIC = true;
		return true;
	}
	var cp = availableCP;
	var cpToUse;
	var useCheapestMult = (flags & 1) != 0?1:0;
	var aggr;
	troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
	var tn;
	var checkCostFunc = favorable?troshx_tros_ai_TROSAiBot.checkCostViability:troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline;
	if(troshx_tros_ai_TROSAiBot.AVAIL_block > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
		cp = availableCP - (troshx_tros_ai_TROSAiBot.AVAIL_block - 1);
		if(cp > 0) {
			tn = troshx_tros_ai_TROSAiBot.getDTNOfManuever("block");
			cpToUse = checkCostFunc(cp,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
			if(cpToUse > 0 && (flags & 4) != 0) {
				safetyCost = troshx_tros_ai_TROSAiBot.checkCostAntiFavorability(cp,tn,troshx_tros_ai_TROSAiBot.P_RECKLESS,againstRoll,againstTN,false,0,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT);
				if(safetyCost > 0) {
					if(cpToUse < safetyCost) {
						cpToUse = safetyCost;
					}
				} else {
					cpToUse = 0;
				}
			}
			if(cpToUse > 0) {
				aggr = useCheapestMult * cpToUse + (1 - troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY);
				if(aggr <= 9999999999999) {
					if(aggr != 9999999999999) {
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
					}
					troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("block",cpToUse,tn,troshx_tros_ai_TROSAiBot.AVAIL_block - 1,true);
					var index = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
					var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					var newChoice = index >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index];
					newChoice.manuever = _this.manuever;
					newChoice.manueverCP = _this.manueverCP;
					newChoice.targetZone = _this.targetZone;
					newChoice.manueverType = _this.manueverType;
					newChoice.offhand = _this.offhand;
					newChoice.manueverTN = _this.manueverTN;
					newChoice.againstID = _this.againstID;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
				}
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_parry > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
		cp = availableCP - (troshx_tros_ai_TROSAiBot.AVAIL_parry - 1);
		if(cp > 0) {
			tn = troshx_tros_ai_TROSAiBot.getDTNOfManuever("parry");
			cpToUse = checkCostFunc(cp,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
			if(cpToUse > 0 && (flags & 4) != 0) {
				safetyCost = troshx_tros_ai_TROSAiBot.checkCostAntiFavorability(cp,tn,troshx_tros_ai_TROSAiBot.P_RECKLESS,againstRoll,againstTN,false,0,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT);
				if(safetyCost > 0) {
					if(cpToUse < safetyCost) {
						cpToUse = safetyCost;
					}
				} else {
					cpToUse = 0;
				}
			}
			if(cpToUse > 0) {
				aggr = useCheapestMult * cpToUse + (1 - troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY);
				if(aggr <= 9999999999999) {
					if(aggr != 9999999999999) {
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
					}
					troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("parry",cpToUse,tn,troshx_tros_ai_TROSAiBot.AVAIL_parry - 1,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
					var index1 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
					var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					var newChoice1 = index1 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index1] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index1];
					newChoice1.manuever = _this1.manuever;
					newChoice1.manueverCP = _this1.manueverCP;
					newChoice1.targetZone = _this1.targetZone;
					newChoice1.manueverType = _this1.manueverType;
					newChoice1.offhand = _this1.offhand;
					newChoice1.manueverTN = _this1.manueverTN;
					newChoice1.againstID = _this1.againstID;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
				}
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_partialevasion > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
		cp = availableCP - (troshx_tros_ai_TROSAiBot.AVAIL_partialevasion - 1) - 2;
		if(cp > 0) {
			tn = troshx_tros_ai_TROSAiBot.getDTNOfManuever("partialevasion");
			cpToUse = checkCostFunc(cp,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
			if(cpToUse > 0 && (flags & 4) != 0) {
				safetyCost = troshx_tros_ai_TROSAiBot.checkCostAntiFavorability(cp,tn,troshx_tros_ai_TROSAiBot.P_RECKLESS,againstRoll,againstTN,false,0,troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT);
				if(safetyCost > 0) {
					if(cpToUse < safetyCost) {
						cpToUse = safetyCost;
					}
				} else {
					cpToUse = 0;
				}
			}
			if(cpToUse > 0) {
				aggr = useCheapestMult * cpToUse + (1 - troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY);
				if(aggr < 9999999999999) {
					if(aggr != 9999999999999) {
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
					}
					troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("partialevasion",cpToUse,tn,troshx_tros_ai_TROSAiBot.AVAIL_partialevasion - 1,false);
					var index2 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
					var _this2 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					var newChoice2 = index2 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index2] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index2];
					newChoice2.manuever = _this2.manuever;
					newChoice2.manueverCP = _this2.manueverCP;
					newChoice2.targetZone = _this2.targetZone;
					newChoice2.manueverType = _this2.manueverType;
					newChoice2.offhand = _this2.offhand;
					newChoice2.manueverTN = _this2.manueverTN;
					newChoice2.againstID = _this2.againstID;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
				}
			}
		}
	}
	if(troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT > 0) {
		var randIndex = Math.random() * troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT | 0;
		var _this3 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[randIndex];
		var newChoice3 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
		newChoice3.manuever = _this3.manuever;
		newChoice3.manueverCP = _this3.manueverCP;
		newChoice3.targetZone = _this3.targetZone;
		newChoice3.manueverType = _this3.manueverType;
		newChoice3.offhand = _this3.offhand;
		newChoice3.manueverTN = _this3.manueverTN;
		newChoice3.againstID = _this3.againstID;
		troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[randIndex];
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getFavorableDefense = function(availableCP,againstRoll,againstTN,heuristic,flags) {
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	return troshx_tros_ai_TROSAiBot.getFBDefense(true,availableCP,againstRoll,againstTN,heuristic,flags);
};
troshx_tros_ai_TROSAiBot.getBorderlineDefense = function(availableCP,againstRoll,againstTN,heuristic,flags,customThreshold) {
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	return troshx_tros_ai_TROSAiBot.getFBDefense(false,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold);
};
troshx_tros_ai_TROSAiBot.getFleeOrDefend = function(favorable,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold,secondExchange) {
	if(secondExchange == null) {
		secondExchange = false;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var resultFirst = troshx_tros_ai_TROSAiBot.getFlee(favorable,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold,secondExchange);
	if(resultFirst && (flags & 1) != 0) {
		return resultFirst;
	}
	var fleeLikelihood = troshx_util_TROSAI.getChanceToSucceedContest(troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverCP,troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverTN,againstRoll,againstTN,1,true);
	var resultSecond = troshx_tros_ai_TROSAiBot.getFBDefense(favorable,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold);
	if(resultSecond) {
		if(!resultFirst || troshx_util_TROSAI.getChanceToSucceedContest(troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverCP,troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverTN,againstRoll,againstTN,1,true) >= fleeLikelihood) {
			return resultSecond;
		} else {
			return troshx_tros_ai_TROSAiBot.getDesperateFlee(availableCP,secondExchange);
		}
	} else if(resultFirst) {
		return troshx_tros_ai_TROSAiBot.getDesperateFlee(availableCP,secondExchange);
	} else {
		return false;
	}
};
troshx_tros_ai_TROSAiBot.minimalDefenseFirst = function(availableCP,againstRoll,againstTN,enemyCPInReserve) {
	if(enemyCPInReserve == null) {
		enemyCPInReserve = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var cp;
	if(troshx_tros_ai_TROSAiBot.getFlee(false,availableCP,enemyCPInReserve,troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedATN(),false,1,0,true)) {
		cp = availableCP - troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverCP;
		if(troshx_tros_ai_TROSAiBot.getFBDefense(false,cp,againstRoll,againstTN,true,6,0.0001)) {
			return true;
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.minimalDefenseOnly = function(availableCP,againstRoll,againstTN,flags) {
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	return troshx_tros_ai_TROSAiBot.getFBDefense(false,availableCP,againstRoll,againstTN,true,flags | 4,0.0001);
};
troshx_tros_ai_TROSAiBot.lastDitchFleeOrDefend = function(availableCP,threatManuever,secondExchange,enemyCPInReserve) {
	if(enemyCPInReserve == null) {
		enemyCPInReserve = 0;
	}
	if(secondExchange == null) {
		secondExchange = false;
	}
	var cpToUse;
	var cpLeft;
	var cpRight;
	var isDamaging = troshx_tros_ManueverSheet.isDamagingManuever(threatManuever.manuever);
	if(!secondExchange) {
		var opponentATN = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedATN();
		var minCPRequired = troshx_tros_ai_TROSAiBot.checkCostViabilityWithBs(availableCP,4,troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE,enemyCPInReserve,opponentATN,false,0);
		if(minCPRequired > 0) {
			cpLeft = availableCP - minCPRequired;
			if(isDamaging?troshx_tros_ai_TROSAiBot.getFBDefense(false,cpLeft,threatManuever.manueverCP,threatManuever.manueverTN,true,6,0.0001):troshx_tros_ai_TROSAiBot.getFBDefense(false,cpLeft,threatManuever.manueverCP,threatManuever.manueverTN,true,2,0)) {
				cpToUse = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverCP;
				cpRight = troshx_tros_ai_TROSAiBot.checkCostViabilityWithBs(availableCP,4,troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE,enemyCPInReserve,opponentATN,false,1);
				if(cpRight == 0) {
					cpRight = troshx_tros_ai_TROSAiBot.checkCostViabilityWithBs(availableCP,4,troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE,enemyCPInReserve,opponentATN,false,1);
				}
				if(cpRight > 0) {
					cpRight = availableCP - cpRight - 1;
					if(cpToUse < cpRight) {
						cpToUse = cpRight;
						troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manueverCP = cpToUse;
					}
				}
				return true;
			} else {
				return troshx_tros_ai_TROSAiBot.getFleeOrDefend(false,cpLeft,threatManuever.manueverCP,threatManuever.manueverTN,true,2,0.00000001,secondExchange);
			}
		}
		if(!troshx_tros_ai_TROSAiBot.getDesperateFlee(availableCP,secondExchange)) {
			return troshx_tros_ai_TROSAiBot.getFleeOrDefend(false,availableCP,threatManuever.manueverCP,threatManuever.manueverTN,true,2,0.00000001,secondExchange);
		} else {
			return true;
		}
	}
	return troshx_tros_ai_TROSAiBot.getFleeOrDefend(false,availableCP,threatManuever.manueverCP,threatManuever.manueverTN,true,2,0.00000001,secondExchange);
};
troshx_tros_ai_TROSAiBot.weightedChoiceBetween = function(trueConditionProbability,falseConditionProbability) {
	return Math.random() * (trueConditionProbability + falseConditionProbability) <= trueConditionProbability;
};
troshx_tros_ai_TROSAiBot.weightedChoiceBetween2 = function(trueConditionProbability,falseConditionProbability,maxMarginOfDifference) {
	if(maxMarginOfDifference != 0 && (trueConditionProbability > falseConditionProbability?trueConditionProbability - falseConditionProbability:falseConditionProbability - trueConditionProbability) > maxMarginOfDifference) {
		return trueConditionProbability >= falseConditionProbability;
	} else {
		return Math.random() * (trueConditionProbability + falseConditionProbability) <= trueConditionProbability;
	}
};
troshx_tros_ai_TROSAiBot.absDiffF = function(val,val2) {
	if(val > val2) {
		return val - val2;
	} else {
		return val2 - val;
	}
};
troshx_tros_ai_TROSAiBot.getDesperateFlee = function(availableCP,secondExchange) {
	if(troshx_tros_ai_TROSAiBot.AVAIL_fullevasion > 0) {
		troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("fullevasion",troshx_core_GameRules.FLEE_CAP == 0 || troshx_core_GameRules.FLEE_CAP == 1 && secondExchange?availableCP:availableCP > 6?6:availableCP,troshx_tros_ai_TROSAiBot.getDTNOfManuever("fullevasion"),troshx_tros_ai_TROSAiBot.AVAIL_fullevasion - 1,false);
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getFlee = function(favorable,availableCP,againstRoll,againstTN,heuristic,flags,customThreshold,secondExchange) {
	if(secondExchange == null) {
		secondExchange = false;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(heuristic == null) {
		heuristic = true;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var threshold = customThreshold != 0?customThreshold:favorable?troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE:troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE;
	var cpToSpend;
	if(troshx_tros_ai_TROSAiBot.AVAIL_fullevasion > 0) {
		var cpToUseForFleeing = troshx_core_GameRules.FLEE_CAP == 0 || troshx_core_GameRules.FLEE_CAP == 1 && secondExchange?availableCP:availableCP > 6?6:availableCP;
		if(favorable) {
			cpToSpend = troshx_tros_ai_TROSAiBot.checkCostViability(cpToUseForFleeing,4,threshold,againstRoll,againstTN,(flags & 2) != 0);
			if(cpToSpend > 0) {
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("fullevasion",cpToSpend,4,troshx_tros_ai_TROSAiBot.AVAIL_fullevasion - 1,false);
				return true;
			}
		} else {
			cpToSpend = troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(cpToUseForFleeing,4,threshold,againstRoll,againstTN,(flags & 2) != 0);
			if(cpToSpend > 0) {
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("fullevasion",cpToSpend,4,troshx_tros_ai_TROSAiBot.AVAIL_fullevasion - 1,false);
				return true;
			}
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getCPMaxForFleeing = function(availableCP,secondExchange) {
	if(troshx_core_GameRules.FLEE_CAP == 0 || troshx_core_GameRules.FLEE_CAP == 1 && secondExchange) {
		return availableCP;
	} else if(availableCP > 6) {
		return 6;
	} else {
		return availableCP;
	}
};
troshx_tros_ai_TROSAiBot.tryBestPossibleDefenseBoliao = function(cp,cp2,threatManuever,secondExchange) {
	troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET = 0;
	if(!troshx_tros_ai_TROSAiBot.getSpecialDefWithReturnAttack(cp,cp2,threatManuever.manueverCP,threatManuever.manueverTN,0,secondExchange)) {
		return troshx_tros_ai_TROSAiBot.lastDitchFleeOrDefend(cp,threatManuever,secondExchange,cp2 - threatManuever.manueverCP);
	} else {
		return true;
	}
};
troshx_tros_ai_TROSAiBot.tryBestPossibleAttackBoliao = function(cp,cp2,threatManuever,secondExchange) {
	troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET = 0;
	var atk = troshx_tros_ai_TROSAiBot.getRegularAttackOrAdvantageMove(cp,0,threatManuever != null?threatManuever.manueverCP:-1,threatManuever != null?threatManuever.manueverTN:1);
	if(atk != null) {
		var cost = troshx_tros_ai_TROSAiBot.getCostOfManuever(atk);
		cp -= cost;
		if(cp > 0) {
			var atn = troshx_tros_ai_TROSAiBot.getATNOfManuever(atk);
			var cpToUse = troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(cp,cp2,troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE,secondExchange?cp2:Math.ceil(cp2 * .5) | 0,troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedDTN(),secondExchange);
			troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack(atk,secondExchange?cp:cpToUse > 0?cpToUse:troshx_tros_ai_TROSAiBot.CAN_DESPERATE_ALPHASTRIKE && Math.random() < troshx_tros_ai_TROSAiBot.DESPERATE_ALPHASTRIKE_CHANCE?cp:Math.ceil(cp * .5) | 0,atn,troshx_tros_ai_TROSAiBot.getRegularTargetZone(atk,atn,cp),cost,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
			return true;
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.tryBestPossibleAttackOrDefBoliao = function(cp,cp2,threatManuever,secondExchange) {
	troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverCP = cp2;
	troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverTN = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedATN();
	troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET = 0;
	if(secondExchange) {
		if(troshx_tros_ai_TROSAiBot.WISH_TO_REGAIN_STANCE) {
			var result = false;
			if(troshx_tros_ai_TROSAiBot.getFleeOrDefend(false,cp,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverCP,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverTN,true,0,0,secondExchange)) {
				if(troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manuever == "fullevasion") {
					result = true;
				} else if(cp > 2 && troshx_tros_ai_TROSAiBot.getFBDefense(false,cp - 2,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverCP,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverTN,true,secondExchange?2:0,0)) {
					var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					_this.manuever = "";
					_this.manueverCP = 0;
					_this.targetZone = 0;
					_this.manueverType = 0;
					_this.offhand = false;
					_this.againstID = 0;
					_this.secondary = null;
					_this.manuever = troshx_util_AIManueverChoice.DO_NOTHING_WAIT_FOR_DEFENSE;
					_this.manueverType = 1;
					result = true;
				}
			}
			if(result) {
				return true;
			}
		}
	} else if(!troshx_tros_ai_TROSAiBot.CURRENTLY_AGGROED && troshx_tros_ai_TROSAiBot.WISH_TO_REGAIN_STANCE) {
		var result1 = false;
		if(troshx_tros_ai_TROSAiBot.getFleeOrDefend(false,cp,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverCP,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverTN,true,0,0,secondExchange)) {
			if(troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manuever == "fullevasion") {
				result1 = true;
			} else if(cp > 2 && troshx_tros_ai_TROSAiBot.getFBDefense(false,cp - 2,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverCP,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverTN,true,secondExchange?2:0,0)) {
				var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				_this1.manuever = "";
				_this1.manueverCP = 0;
				_this1.targetZone = 0;
				_this1.manueverType = 0;
				_this1.offhand = false;
				_this1.againstID = 0;
				_this1.secondary = null;
				_this1.manuever = troshx_util_AIManueverChoice.DO_NOTHING_WAIT_FOR_DEFENSE;
				_this1.manueverType = 1;
				result1 = true;
			}
		}
		if(result1) {
			return true;
		}
	}
	return troshx_tros_ai_TROSAiBot.tryBestPossibleAttackBoliao(cp,cp2,null,secondExchange);
};
troshx_tros_ai_TROSAiBot.tryBestPossibleDefWithInitiativeBoliao = function(cp,cp2,threatManuever,secondExchange) {
	var result = false;
	if(troshx_tros_ai_TROSAiBot.getFleeOrDefend(false,cp,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverCP,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverTN,true,0,0,secondExchange)) {
		if(troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.manuever == "fullevasion") {
			result = true;
		} else if(cp > 2 && troshx_tros_ai_TROSAiBot.getFBDefense(false,cp - 2,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverCP,troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK.manueverTN,true,secondExchange?2:0,0)) {
			var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
			_this.manuever = "";
			_this.manueverCP = 0;
			_this.targetZone = 0;
			_this.manueverType = 0;
			_this.offhand = false;
			_this.againstID = 0;
			_this.secondary = null;
			_this.manuever = troshx_util_AIManueverChoice.DO_NOTHING_WAIT_FOR_DEFENSE;
			_this.manueverType = 1;
			result = true;
		}
	}
	return result;
};
troshx_tros_ai_TROSAiBot.addPossibleRegularManueverChoice = function(index) {
	var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
	var newChoice = index >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index];
	newChoice.manuever = _this.manuever;
	newChoice.manueverCP = _this.manueverCP;
	newChoice.targetZone = _this.targetZone;
	newChoice.manueverType = _this.manueverType;
	newChoice.offhand = _this.offhand;
	newChoice.manueverTN = _this.manueverTN;
	newChoice.againstID = _this.againstID;
};
troshx_tros_ai_TROSAiBot.getAdvantageManuever = function(manueverName,favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,defensive,alwaysUseOffhand) {
	if(alwaysUseOffhand == null) {
		alwaysUseOffhand = false;
	}
	if(defensive == null) {
		defensive = false;
	}
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var threshold = customThreshold != 0?customThreshold:favorable?troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE:troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE;
	availableCP -= troshx_tros_ai_TROSAiBot.getCostOfManuever(manueverName);
	if(availableCP > 0) {
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = preferedRS;
		var tn = defensive?troshx_tros_ai_TROSAiBot.getDTNOfManuever(manueverName):troshx_tros_ai_TROSAiBot.getATNOfManuever(manueverName);
		if(tn == 0 || tn == 888) {
			return false;
		}
		var costing = favorable?troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,tn,threshold,againstRoll,againstTN,(flags & 2) != 0):troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(availableCP,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
		if(costing > 0) {
			if(defensive) {
				troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend(manueverName,costing,tn,troshx_tros_ai_TROSAiBot.getCostOfManuever(manueverName),alwaysUseOffhand || troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
			} else {
				troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack(manueverName,costing,tn,0,troshx_tros_ai_TROSAiBot.getCostOfManuever(manueverName),alwaysUseOffhand || troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
			}
			return true;
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getBlockOpenAndStrike = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS) {
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_blockopenstrike > 0) {
		return troshx_tros_ai_TROSAiBot.getAdvantageManuever("blockopenstrike",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,true);
	} else {
		return false;
	}
};
troshx_tros_ai_TROSAiBot.getRota = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS) {
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_rota > 0) {
		return troshx_tros_ai_TROSAiBot.getAdvantageManuever("rota",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,true);
	} else {
		return false;
	}
};
troshx_tros_ai_TROSAiBot.getCounter = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS) {
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_counter > 0) {
		return troshx_tros_ai_TROSAiBot.getAdvantageManuever("counter",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,true);
	} else {
		return false;
	}
};
troshx_tros_ai_TROSAiBot.getExpulsion = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS) {
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_expulsion > 0) {
		return troshx_tros_ai_TROSAiBot.getAdvantageManuever("expulsion",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,true);
	} else {
		return false;
	}
};
troshx_tros_ai_TROSAiBot.getSpecialDefWithReturnAttack = function(availableCP,againstCP,againstRoll,againstTN,customThreshold,secondExchange) {
	if(secondExchange == null) {
		secondExchange = false;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	var cost;
	var cpToUse;
	var weapon = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.B_EQUIP);
	var offhandWeap = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.D_EQUIP);
	var dtn = weapon != null?weapon.dtn:0;
	var blockDTN = offhandWeap != null?offhandWeap.dtn:0;
	var atn = weapon != null?weapon.atn:0;
	var atn2 = weapon != null?weapon.atn2:0;
	var pool = availableCP;
	var enemyDTN = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedDTN();
	var enemyCPLeft = againstCP - againstRoll;
	var cpToSave;
	var aggr;
	var usingReturnStrikeTN;
	var curAggr = 99999999;
	if(dtn == 0) {
		return false;
	}
	troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
	var initialCount = 0;
	var threshold = customThreshold != 0?customThreshold:troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE;
	if(troshx_tros_ai_TROSAiBot.AVAIL_counter > 0) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_counter - 1;
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = cost + 1;
		if(troshx_tros_ai_TROSAiBot.checkCostViability(againstRoll,againstTN,troshx_tros_ai_TROSAiBot.P_THRESHOLD_ANTI_FAVORABLE,0,1,false) > 0) {
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 1;
			usingReturnStrikeTN = Math.round((atn + atn2) / 2) | 0;
			if(secondExchange) {
				cpToSave = 0;
			} else {
				cpToSave = troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(pool,usingReturnStrikeTN,troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE,enemyCPLeft,enemyDTN,false);
			}
			aggr = dtn + usingReturnStrikeTN + troshx_tros_ai_TROSAiBot.getAverageOpponentCounterAV() / 8;
			aggr = cpToSave + cost + aggr / 20;
			availableCP = pool - cpToSave;
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 1;
			if(availableCP > 0) {
				cpToUse = troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,dtn,threshold,againstRoll,againstTN,true);
			} else {
				cpToUse = 0;
			}
			if(cpToUse > 0) {
				if(aggr <= curAggr) {
					if(aggr != curAggr) {
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
					}
					troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("counter",cpToUse,dtn,cost,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
					var index = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
					var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					var newChoice = index >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index];
					newChoice.manuever = _this.manuever;
					newChoice.manueverCP = _this.manueverCP;
					newChoice.targetZone = _this.targetZone;
					newChoice.manueverType = _this.manueverType;
					newChoice.offhand = _this.offhand;
					newChoice.manueverTN = _this.manueverTN;
					newChoice.againstID = _this.againstID;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
					curAggr = aggr;
				}
			}
		}
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_rota > 0) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_rota - 1;
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = cost + 1;
		if(troshx_tros_ai_TROSAiBot.checkCostViability(againstRoll,againstTN,troshx_tros_ai_TROSAiBot.P_THRESHOLD_ANTI_FAVORABLE,0,1,false) > 0) {
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 1;
			usingReturnStrikeTN = atn;
			if(secondExchange) {
				cpToSave = 0;
			} else {
				cpToSave = troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(pool,usingReturnStrikeTN,troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE,enemyCPLeft,enemyDTN,false);
			}
			aggr = dtn + usingReturnStrikeTN + troshx_tros_ai_TROSAiBot.getAverageOpponentCounterAV() / 8;
			aggr = cpToSave + cost + aggr / 20;
			availableCP = pool - cpToSave;
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 1;
			if(availableCP > 0) {
				cpToUse = troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,dtn,threshold,againstRoll,againstTN,true);
			} else {
				cpToUse = 0;
			}
			if(cpToUse > 0) {
				if(aggr <= curAggr) {
					if(aggr != curAggr) {
						troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
					}
					troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("rota",cpToUse,dtn,cost,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
					var index1 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
					var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					var newChoice1 = index1 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index1] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index1];
					newChoice1.manuever = _this1.manuever;
					newChoice1.manueverCP = _this1.manueverCP;
					newChoice1.targetZone = _this1.targetZone;
					newChoice1.manueverType = _this1.manueverType;
					newChoice1.offhand = _this1.offhand;
					newChoice1.manueverTN = _this1.manueverTN;
					newChoice1.againstID = _this1.againstID;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
					curAggr = aggr;
				}
			}
		}
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
	}
	initialCount = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
	curAggr = 99999999;
	if(troshx_tros_ai_TROSAiBot.AVAIL_blockopenstrike > 0 && blockDTN > 0) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_blockopenstrike - 1;
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 1;
		if(atn2 < atn) {
			usingReturnStrikeTN = atn2;
		} else {
			usingReturnStrikeTN = atn;
		}
		if(secondExchange) {
			cpToSave = 0;
		} else {
			cpToSave = troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(pool,usingReturnStrikeTN,troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE,enemyCPLeft,enemyDTN,false);
		}
		aggr = blockDTN + usingReturnStrikeTN + troshx_tros_ai_TROSAiBot.getAverageOpponentCounterAV() / 8;
		aggr = cpToSave + cost + aggr / 20;
		availableCP = pool - cpToSave;
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = cost;
		if(availableCP > 0) {
			cpToUse = troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,blockDTN,threshold,againstRoll,againstTN,true);
		} else {
			cpToUse = 0;
		}
		if(cpToUse > 0) {
			if(aggr <= curAggr) {
				if(aggr != curAggr) {
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = initialCount;
				}
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("blockopenstrike",cpToUse,blockDTN,cost,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
				var index2 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
				var _this2 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				var newChoice2 = index2 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index2] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index2];
				newChoice2.manuever = _this2.manuever;
				newChoice2.manueverCP = _this2.manueverCP;
				newChoice2.targetZone = _this2.targetZone;
				newChoice2.manueverType = _this2.manueverType;
				newChoice2.offhand = _this2.offhand;
				newChoice2.manueverTN = _this2.manueverTN;
				newChoice2.againstID = _this2.againstID;
				troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
				troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
				curAggr = aggr;
			}
		}
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_expulsion > 0) {
		cost = troshx_tros_ai_TROSAiBot.AVAIL_expulsion - 1;
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 1;
		usingReturnStrikeTN = atn2;
		availableCP = pool - cost;
		if(secondExchange) {
			cpToSave = 0;
		} else {
			var val2 = enemyCPLeft - troshx_tros_ai_TROSAiBot.B_BS_REQUIRED;
			cpToSave = troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(availableCP,usingReturnStrikeTN,troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE,0 >= val2?0:val2,enemyDTN,false);
		}
		aggr = dtn + usingReturnStrikeTN + troshx_tros_ai_TROSAiBot.getAverageOpponentCounterAV() / 8;
		aggr = cpToSave + cost + aggr / 20;
		availableCP = pool - cpToSave - cost;
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 2;
		if(availableCP > 0) {
			cpToUse = troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,dtn,threshold,againstRoll,againstTN,true);
		} else {
			cpToUse = 0;
		}
		if(cpToUse > 0) {
			if(aggr <= curAggr) {
				if(aggr != curAggr) {
					troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = initialCount;
				}
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setDefend("expulsion",cpToUse,dtn,cost,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
				var index3 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT;
				var _this3 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				var newChoice3 = index3 >= troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES.length?troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index3] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[index3];
				newChoice3.manuever = _this3.manuever;
				newChoice3.manueverCP = _this3.manueverCP;
				newChoice3.targetZone = _this3.targetZone;
				newChoice3.manueverType = _this3.manueverType;
				newChoice3.offhand = _this3.offhand;
				newChoice3.manueverTN = _this3.manueverTN;
				newChoice3.againstID = _this3.againstID;
				troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT] = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
				troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT++;
				curAggr = aggr;
			}
		}
		troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
	}
	troshx_tros_ai_TROSAiBot.DEF_AGGR = curAggr;
	if(troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT > 0) {
		var randIndex = Math.random() * troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT | 0;
		var _this4 = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES[randIndex];
		var newChoice4 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
		newChoice4.manuever = _this4.manuever;
		newChoice4.manueverCP = _this4.manueverCP;
		newChoice4.targetZone = _this4.targetZone;
		newChoice4.manueverType = _this4.manueverType;
		newChoice4.offhand = _this4.offhand;
		newChoice4.manueverTN = _this4.manueverTN;
		newChoice4.againstID = _this4.againstID;
		troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES[randIndex];
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getAverageOpponentCounterAV = function() {
	return 0;
};
troshx_tros_ai_TROSAiBot.maxI = function(val,val2) {
	if(val >= val2) {
		return val;
	} else {
		return val2;
	}
};
troshx_tros_ai_TROSAiBot.getDisarm = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,defensive,disarmOffhand) {
	if(disarmOffhand == null) {
		disarmOffhand = false;
	}
	if(defensive == null) {
		defensive = false;
	}
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	var result = troshx_tros_ai_TROSAiBot.AVAIL_disarm > 0 && troshx_tros_ai_TROSAiBot.getAdvantageManuever("disarm",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,defensive);
	troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.targetZone = disarmOffhand?1:0;
	return result;
};
troshx_tros_ai_TROSAiBot.getHook = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS) {
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_hook > 0) {
		return troshx_tros_ai_TROSAiBot.getAdvantageManuever("hook",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,false);
	} else {
		return false;
	}
};
troshx_tros_ai_TROSAiBot.getBindStrike = function(favorable,availableCP,againstCP,againstRoll,againstTN,flags,customThreshold,preferedRS) {
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_bindstrike > 0) {
		return troshx_tros_ai_TROSAiBot.getAdvantageManuever("bindstrike",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,false,true);
	} else {
		return false;
	}
};
troshx_tros_ai_TROSAiBot.getBeat = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,preferTargetMaster) {
	if(preferTargetMaster == null) {
		preferTargetMaster = 0;
	}
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	if(troshx_tros_ai_TROSAiBot.AVAIL_beat > 0) {
		var result = troshx_tros_ai_TROSAiBot.getAdvantageManuever("beat",favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,false);
		if(result) {
			var weapon = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.equipMasterhand);
			var master = weapon != null?weapon.dtn:0;
			var weapon1 = troshx_tros_WeaponSheet.getWeaponByName(troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.equipOffhand);
			var shield = weapon1 != null && weapon1.shield?weapon1.dtn:0;
			troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.targetZone = master == 0 || shield == 0?shield == 0?0:1:shield < master - preferTargetMaster?1:0;
		}
		return result;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove = function(favorable,availableCP,againstRoll,againstTN,flags,customThreshold,preferedRS,preferTargetMaster) {
	if(preferTargetMaster == null) {
		preferTargetMaster = 0;
	}
	if(preferedRS == null) {
		preferedRS = 1;
	}
	if(customThreshold == null) {
		customThreshold = 0;
	}
	if(flags == null) {
		flags = 0;
	}
	if(againstTN == null) {
		againstTN = 1;
	}
	if(againstRoll == null) {
		againstRoll = 0;
	}
	troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
	var threshold = customThreshold != 0?customThreshold:favorable?troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE:troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE;
	var manuever = troshx_tros_ai_TROSAiBot.getRegularAdvantageMove(availableCP,0,againstRoll,againstTN);
	if(manuever != null) {
		var tn = troshx_tros_ai_TROSAiBot.getATNOfManuever(manuever);
		var cost = troshx_tros_ai_TROSAiBot.getCostOfManuever(manuever);
		availableCP -= cost;
		if(availableCP > 0) {
			var cpToUse = favorable?troshx_tros_ai_TROSAiBot.checkCostViability(availableCP,tn,threshold,againstRoll,againstTN,(flags & 2) != 0):troshx_tros_ai_TROSAiBot.checkCostViabilityBorderline(availableCP,tn,threshold,againstRoll,againstTN,(flags & 2) != 0);
			if(cpToUse > 0) {
				troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY_GET = troshx_tros_ai_TROSAiBot.B_VIABLE_PROBABILITY;
				troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE.setAttack(manuever,cpToUse,tn,0,cost,troshx_tros_ai_TROSAiBot.B_IS_OFFHAND);
				return true;
			}
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getPredictedOpponentDTN = function() {
	return troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedDTN();
};
troshx_tros_ai_TROSAiBot.getPredictedOpponentATN = function() {
	return troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedATN();
};
troshx_tros_ai_TROSAiBot.fluctuateLower = function(val,lowerBy) {
	if(lowerBy >= val) {
		lowerBy = val * .5;
	} else {
		lowerBy = lowerBy;
	}
	val -= Math.random() * lowerBy;
	return val;
};
troshx_tros_ai_TROSAiBot.getComboExchangeBudgetingWithInitiative = function(combo,cp,cp2,threatManuever) {
	var lastDefault;
	if(threatManuever != null && threatManuever.manuever == "") {
		threatManuever = null;
	}
	var dtn = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedDTN();
	var stipulateRemaining;
	if(combo > 0) {
		switch(combo) {
		case 1:
			stipulateRemaining = Math.floor(cp2 * .5);
			var tmp;
			var tmp1;
			if(troshx_tros_ai_TROSAiBot.getFBAttack(true,Math.floor(cp * .5),stipulateRemaining,dtn,false,1,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,Math.floor(cp * .5),stipulateRemaining,dtn,1)) {
				var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				tmp1 = cp - (_this.cost + _this.manueverCP) >= Math.ceil(cp * .5);
			} else {
				tmp1 = false;
			}
			if(!tmp1) {
				if(!troshx_tros_ai_TROSAiBot.getBorderlineAttack(Math.floor(cp * .5),stipulateRemaining,dtn,false,1)) {
					tmp = troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,Math.floor(cp * .5),stipulateRemaining,dtn,1);
				} else {
					tmp = true;
				}
			} else {
				tmp = true;
			}
			if(tmp) {
				var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				cp -= _this1.cost + _this1.manueverCP;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0] = cp;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[1] = Math.ceil(cp2 * .5);
				var _this2 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[2] = _this2.cost + _this2.manueverCP;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[3] = stipulateRemaining;
				if(troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[1],dtn,false,2) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[1],dtn,2)) {
					return troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET;
				}
			}
			break;
		case 2:
			if(troshx_tros_ai_TROSAiBot.getAForcefulInitiativeAttack(troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE,cp,cp2,dtn,true,false,0)) {
				stipulateRemaining = 0;
				var _this3 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				var consideredCP = _this3.cost + _this3.manueverCP;
				lastDefault = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT;
				troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT = 0;
				troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2 * .5 | 0,dtn,false,1,0);
				var _this4 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				if(_this4.cost + _this4.manueverCP > consideredCP) {
					var _this5 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					consideredCP = _this5.cost + _this5.manueverCP;
				}
				if(consideredCP < Math.ceil(cp * .5)) {
					consideredCP = Math.ceil(cp * .5);
				}
				troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT = lastDefault;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0] = consideredCP;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[1] = cp2;
				cp -= consideredCP;
				if(cp > 2 && (troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,0,dtn,false,2,0.5) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,0,dtn,2,0.5))) {
					var _this6 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
					troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[2] = _this6.cost + _this6.manueverCP;
					troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[3] = 0;
					return troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET;
				}
			}
			break;
		case 3:
			var minCP = troshx_tros_ai_TROSAiBot.ENEMY_STEAL_COST + 1 + troshx_tros_ai_TROSAiBot.MIN_EXPOSED_AV - 1;
			if(cp2 > minCP) {
				minCP = cp2 - minCP;
			} else {
				minCP = 0;
			}
			troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0] = cp - minCP;
			troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[3] = cp2;
			troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[2] = minCP;
			troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[3] = -1;
			if(troshx_tros_ai_TROSAiBot.getDisarm(true,troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0],cp2,dtn,2,0,troshx_tros_ai_TROSAiBot.PREFERED_DISARM_BS,false)) {
				return troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET;
			}
			break;
		case 4:
			var preferedRS = troshx_tros_ai_TROSAiBot.PREFERED_HOOK_BS;
			if(troshx_tros_ai_TROSAiBot.AVAIL_hook > 0 && troshx_tros_ai_TROSAiBot.getAdvantageManuever("hook",true,troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0],cp2,dtn,2,0,preferedRS,false)) {
				return troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET;
			}
			break;
		case 5:
			if(troshx_tros_ai_TROSAiBot.getFBAttack(true,troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0],cp2,dtn,false,2,0)) {
				return troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET;
			}
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			lastDefault = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT += 1;
			if(cp2 < troshx_tros_ai_TROSAiBot.ENEMY_STEAL_COST + 1 + troshx_tros_ai_TROSAiBot.MIN_EXPOSED_AV && troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,cp2 >= 2?0:cp2 == 0?0.00001:0.5)) {
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[2] = 0;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[3] = -1;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[0] = cp;
				troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET[1] = cp2;
				troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT = lastDefault;
				return troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET;
			}
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT = lastDefault;
			break;
		}
	}
	return null;
};
troshx_tros_ai_TROSAiBot.tryFavoredElseBorderlineAttacks = function(cp,cp2,dtn,heuristic,flags) {
	if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,heuristic,flags,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,flags) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,heuristic,flags))) {
		return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,flags);
	} else {
		return true;
	}
};
troshx_tros_ai_TROSAiBot.getComboAction = function(combo,cp,cp2,threatManuever,hasInitiative,secondExchange) {
	if(secondExchange == null) {
		secondExchange = false;
	}
	if(hasInitiative == null) {
		hasInitiative = true;
	}
	var lastInt;
	var result;
	var dtn = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedDTN();
	if(hasInitiative) {
		switch(combo) {
		case -6:
			if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case -5:
			if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case -4:
			if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case -3:
			if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case -2:
			if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case -1:
			if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case 1:
			if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case 2:
			if(!secondExchange) {
				return troshx_tros_ai_TROSAiBot.getAForcefulInitiativeAttack(troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE,cp,cp2,dtn,true,true,0);
			} else if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case 3:
			if(!secondExchange) {
				var _this = troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT;
				var tmp;
				if(_this.equipMasterhand != null && _this.equipOffhand != null) {
					var weap = troshx_tros_WeaponSheet.getWeaponByName(_this.equipOffhand);
					if(weap != null) {
						tmp = weap.shield;
					} else {
						tmp = false;
					}
				} else {
					tmp = false;
				}
				if(!tmp) {
					return troshx_tros_ai_TROSAiBot.getDisarm(true,cp,cp2,dtn,2,0,troshx_tros_ai_TROSAiBot.PREFERED_DISARM_BS,false);
				} else {
					return false;
				}
			} else if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case 4:
			if(!secondExchange) {
				var preferedRS = troshx_tros_ai_TROSAiBot.PREFERED_HOOK_BS;
				if(troshx_tros_ai_TROSAiBot.AVAIL_hook > 0) {
					return troshx_tros_ai_TROSAiBot.getAdvantageManuever("hook",true,cp,cp2,dtn,2,0,preferedRS,false);
				} else {
					return false;
				}
			} else if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case 5:
			if(!secondExchange) {
				return troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0);
			} else if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
				return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
			} else {
				return true;
			}
			break;
		case 6:
			if(!(!secondExchange)) {
				if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
					return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
				} else {
					return true;
				}
			}
			break;
		case 7:
			if(!(!secondExchange)) {
				if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
					return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
				} else {
					return true;
				}
			}
			break;
		case 8:
			if(!(!secondExchange)) {
				if(!(troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,0) || troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(true,cp,cp2,dtn,2) || troshx_tros_ai_TROSAiBot.getBorderlineAttack(cp,cp2,dtn,true,2))) {
					return troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,cp2,dtn,2);
				} else {
					return true;
				}
			}
			break;
		case 9:
			lastInt = troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT;
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT += 1;
			if(cp2 < troshx_tros_ai_TROSAiBot.ENEMY_STEAL_COST + 1 + troshx_tros_ai_TROSAiBot.MIN_EXPOSED_AV) {
				result = troshx_tros_ai_TROSAiBot.getFBAttack(true,cp,cp2,dtn,true,2,cp2 >= 2?0:cp2 == 0?0.00001:0.5);
			} else {
				result = false;
			}
			troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT = lastInt;
			return result;
		}
	} else {
		switch(combo) {
		case -6:
			break;
		case -5:
			if(threatManuever != null) {
				return troshx_tros_ai_TROSAiBot.getDisarm(true,cp,threatManuever.manueverCP,threatManuever.manueverTN,0,0,troshx_tros_ai_TROSAiBot.PREFERED_DISARM_DEF_BS,true,threatManuever.offhand);
			}
			break;
		case -4:
			break;
		case -3:
			if(threatManuever != null) {
				return troshx_tros_ai_TROSAiBot.getSpecialDefWithReturnAttack(cp,cp2,threatManuever.manueverCP,threatManuever.manueverTN,0,secondExchange);
			}
			break;
		case -2:
			if(threatManuever != null) {
				if(!secondExchange) {
					if(troshx_tros_ai_TROSAiBot.getFleeOrDefend(false,cp,cp2 - threatManuever.manueverCP,troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.getPredictedATN(),false,5,0,true)) {
						var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
						cp -= _this1.cost + _this1.manueverCP;
						return troshx_tros_ai_TROSAiBot.getFBDefense(false,cp,threatManuever.manueverCP,threatManuever.manueverTN,true,4,0);
					}
				}
			}
			break;
		case -1:
			if(threatManuever != null) {
				if(!secondExchange) {
					lastInt = troshx_tros_ai_TROSAiBot.getCheapestBorderlineAtkCost(cp,cp2 - threatManuever.manueverCP,dtn);
					if(lastInt > 0) {
						cp -= lastInt;
						return troshx_tros_ai_TROSAiBot.getFBDefense(true,cp,threatManuever.manueverCP,threatManuever.manueverTN,true,2,0);
					}
				}
			}
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
		}
	}
	return false;
};
troshx_tros_ai_TROSAiBot.getComboActionTest = function(combo,cp,cp2,threatManuever,hasInitiative,secondExchange) {
	if(secondExchange == null) {
		secondExchange = false;
	}
	if(hasInitiative == null) {
		hasInitiative = true;
	}
	if(!troshx_tros_ai_TROSAiBot.getComboAction(combo,cp,cp2,threatManuever,hasInitiative,secondExchange)) {
		if(hasInitiative) {
			return troshx_tros_ai_TROSAiBot.tryBestPossibleAttackOrDefBoliao(cp,cp2,threatManuever,secondExchange);
		} else {
			return troshx_tros_ai_TROSAiBot.tryBestPossibleDefenseBoliao(cp,cp2,threatManuever,secondExchange);
		}
	} else {
		return true;
	}
};
troshx_tros_ai_TROSAiBot.getCheapestBorderlineAtkCost = function(cp,againstCP,dtn,customThreshold) {
	if(customThreshold == null) {
		customThreshold = 0;
	}
	var cpToSpend = 0;
	if(troshx_tros_ai_TROSAiBot.getAdvantageGainCPOffensiveMove(false,cp,againstCP,dtn,1,customThreshold)) {
		var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
		cpToSpend = _this.cost + _this.manueverCP;
	}
	if(troshx_tros_ai_TROSAiBot.getFBAttack(false,cp,againstCP,dtn,false,1,customThreshold)) {
		var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
		if(_this1.cost + _this1.manueverCP < cpToSpend) {
			var _this2 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
			cpToSpend = _this2.cost + _this2.manueverCP;
		}
	}
	return cpToSpend;
};
troshx_tros_ai_TROSAiBot.getCoupThreshold = function(cp2) {
	if(cp2 >= 2) {
		return 0;
	} else if(cp2 == 0) {
		return 0.00001;
	} else {
		return 0.5;
	}
};
troshx_tros_ai_TROSAiBot.addPossibleComboManueverChoice = function(index,theChoice) {
	var newChoice = index >= troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER.length?troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[index] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[index];
	newChoice.manuever = theChoice.manuever;
	newChoice.manueverCP = theChoice.manueverCP;
	newChoice.targetZone = theChoice.targetZone;
	newChoice.manueverType = theChoice.manueverType;
	newChoice.offhand = theChoice.offhand;
	newChoice.manueverTN = theChoice.manueverTN;
	newChoice.againstID = theChoice.againstID;
};
troshx_tros_ai_TROSAiBot.setBestComboActionWithInitiativePlan = function(cp,cp2,threatManuever) {
	troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT = 0;
	if(troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT.get_initiative()) {
		var tmp = threatManuever != null && threatManuever.manueverType == 2;
	}
	var budget;
	var _g = 9;
	while(_g < 10) {
		var i = _g++;
		budget = troshx_tros_ai_TROSAiBot.getComboExchangeBudgetingWithInitiative(i,cp,cp2,threatManuever);
		if(budget != null) {
			if(troshx_tros_ai_TROSAiBot.getComboAction(i,budget[0],budget[1],threatManuever,true,false)) {
				var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				var newChoice = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_CONSIDER_MASTER;
				newChoice.manuever = _this.manuever;
				newChoice.manueverCP = _this.manueverCP;
				newChoice.targetZone = _this.targetZone;
				newChoice.manueverType = _this.manueverType;
				newChoice.offhand = _this.offhand;
				newChoice.manueverTN = _this.manueverTN;
				newChoice.againstID = _this.againstID;
				if(budget[3] == -1 || troshx_tros_ai_TROSAiBot.getComboAction(i,budget[2],budget[3],threatManuever,true,true)) {
					troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET = i;
					troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_CONSIDER_MASTER;
					return true;
				}
			}
		}
	}
	var i1 = 1;
	while(i1 < 9) {
		budget = troshx_tros_ai_TROSAiBot.getComboExchangeBudgetingWithInitiative(i1,cp,cp2,threatManuever);
		if(budget != null) {
			if(troshx_tros_ai_TROSAiBot.getComboAction(i1,budget[0],budget[1],threatManuever,true,false)) {
				var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				var newChoice1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_1;
				newChoice1.manuever = _this1.manuever;
				newChoice1.manueverCP = _this1.manueverCP;
				newChoice1.targetZone = _this1.targetZone;
				newChoice1.manueverType = _this1.manueverType;
				newChoice1.offhand = _this1.offhand;
				newChoice1.manueverTN = _this1.manueverTN;
				newChoice1.againstID = _this1.againstID;
				if(budget[3] == -1 || troshx_tros_ai_TROSAiBot.getComboAction(i1,budget[2],budget[3],threatManuever,true,true)) {
					troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATES[troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT] = i1;
					var index = troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT;
					var theChoice = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_1;
					var newChoice2 = index >= troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER.length?troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[index] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[index];
					newChoice2.manuever = theChoice.manuever;
					newChoice2.manueverCP = theChoice.manueverCP;
					newChoice2.targetZone = theChoice.targetZone;
					newChoice2.manueverType = theChoice.manueverType;
					newChoice2.offhand = theChoice.offhand;
					newChoice2.manueverTN = theChoice.manueverTN;
					newChoice2.againstID = theChoice.againstID;
					troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT++;
				}
			}
		}
		++i1;
	}
	if(troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT > 0) {
		var randIndex = Math.random() * troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT | 0;
		troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET = troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATES[randIndex];
		troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET = troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[randIndex];
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.setBestComboActionWithInitiativePlanTest = function(cp,cp2,threatManuever) {
	if(troshx_tros_ai_TROSAiBot.setBestComboActionWithInitiativePlan(cp,cp2,threatManuever)) {
		return true;
	} else if(troshx_tros_ai_TROSAiBot.tryBestPossibleAttackOrDefBoliao(cp,cp2,threatManuever,false)) {
		var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
		var newChoice = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET;
		newChoice.manuever = _this.manuever;
		newChoice.manueverCP = _this.manueverCP;
		newChoice.targetZone = _this.targetZone;
		newChoice.manueverType = _this.manueverType;
		newChoice.offhand = _this.offhand;
		newChoice.manueverTN = _this.manueverTN;
		newChoice.againstID = _this.againstID;
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.setBestComboActionWithoutInitiativePlan = function(cp,cp2,threatManuever) {
	troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT = 0;
	var i = 1;
	var tmp = threatManuever == null || threatManuever.manueverType != 2;
	while(i < 7) {
		if(troshx_tros_ai_TROSAiBot.getComboAction(-i,cp,cp2,threatManuever,false,false)) {
			var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
			var newChoice = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_1;
			newChoice.manuever = _this.manuever;
			newChoice.manueverCP = _this.manueverCP;
			newChoice.targetZone = _this.targetZone;
			newChoice.manueverType = _this.manueverType;
			newChoice.offhand = _this.offhand;
			newChoice.manueverTN = _this.manueverTN;
			newChoice.againstID = _this.againstID;
			troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATES[troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT] = -i;
			var index = troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT;
			var theChoice = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_1;
			var newChoice1 = index >= troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER.length?troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[index] = new troshx_util_AIManueverChoice():troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[index];
			newChoice1.manuever = theChoice.manuever;
			newChoice1.manueverCP = theChoice.manueverCP;
			newChoice1.targetZone = theChoice.targetZone;
			newChoice1.manueverType = theChoice.manueverType;
			newChoice1.offhand = theChoice.offhand;
			newChoice1.manueverTN = theChoice.manueverTN;
			newChoice1.againstID = theChoice.againstID;
			troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT++;
		}
		++i;
	}
	if(troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT > 0) {
		var randIndex = Math.random() * troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT | 0;
		troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET = troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATES[randIndex];
		troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET = troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER[randIndex];
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.setBestComboActionWithoutInitiativePlanTest = function(cp,cp2,threatManuever) {
	if(troshx_tros_ai_TROSAiBot.setBestComboActionWithoutInitiativePlan(cp,cp2,threatManuever)) {
		return true;
	} else if(troshx_tros_ai_TROSAiBot.tryBestPossibleDefenseBoliao(cp,cp2,threatManuever,false)) {
		var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
		var newChoice = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET;
		newChoice.manuever = _this.manuever;
		newChoice.manueverCP = _this.manueverCP;
		newChoice.targetZone = _this.targetZone;
		newChoice.manueverType = _this.manueverType;
		newChoice.offhand = _this.offhand;
		newChoice.manueverTN = _this.manueverTN;
		newChoice.againstID = _this.againstID;
		return true;
	}
	return false;
};
troshx_tros_ai_TROSAiBot.prototype = {
	opponents: null
	,opponentLen: null
	,cpBudget: null
	,plannedCombos: null
	,currentExchange: null
	,body: null
	,cp: null
	,perception: null
	,equipMasterhand: null
	,equipOffhand: null
	,mobility: null
	,id: null
	,fight_initiative: null
	,stance: null
	,manueverUsingHands: null
	,handsUsedUp: null
	,decidedStance: null
	,decidedOrientation: null
	,decidedManuevers: null
	,getDecidedManueverForSlot: function(slot) {
		if(this.decidedManuevers[slot] != null) {
			return this.decidedManuevers[slot].manuever;
		} else {
			return "";
		}
	}
	,getDecidedManueverCP: function(slot) {
		if(this.decidedManuevers[slot] != null) {
			return this.decidedManuevers[slot].manueverCP;
		} else {
			return 0;
		}
	}
	,getDecidedManueverTargetZone: function(slot) {
		if(this.decidedManuevers[slot] != null) {
			return this.decidedManuevers[slot].targetZone;
		} else {
			return 0;
		}
	}
	,getPredictedDTN: function() {
		var weapon;
		var dtn = 7;
		if((this.manueverUsingHands & 1) == 0) {
			weapon = troshx_tros_WeaponSheet.getWeaponByName(this.equipMasterhand);
		} else {
			weapon = null;
		}
		if(weapon != null && weapon.dtn < 7 && weapon.dtn > 0) {
			dtn = weapon.dtn;
		}
		if((this.manueverUsingHands & 2) == 0) {
			weapon = troshx_tros_WeaponSheet.getWeaponByName(this.equipOffhand);
		} else {
			weapon = null;
		}
		if(weapon != null && weapon.dtn < dtn && weapon.dtn > 0) {
			dtn = weapon.dtn;
		}
		return dtn;
	}
	,getPredictedATN: function() {
		var weapon;
		var atn = 10;
		weapon = troshx_tros_WeaponSheet.getWeaponByName(this.equipMasterhand);
		if(weapon != null) {
			if(weapon.atn < 10 && weapon.atn > 0) {
				atn = weapon.atn;
			}
			if(weapon.atn2 < atn && weapon.atn2 > 0) {
				atn = weapon.atn2;
			}
		}
		weapon = troshx_tros_WeaponSheet.getWeaponByName(this.equipOffhand);
		if(weapon != null) {
			if(weapon.atn < atn && weapon.atn > 0) {
				atn = weapon.atn;
			}
			if(weapon.atn2 < atn && weapon.atn2 > 0) {
				atn = weapon.atn2;
			}
		}
		return atn;
	}
	,getOffhandDTN: function() {
		var weapon = troshx_tros_WeaponSheet.getWeaponByName(this.equipOffhand);
		if(weapon != null) {
			return weapon.dtn;
		} else {
			return 0;
		}
	}
	,getShieldDTN: function() {
		var weapon = troshx_tros_WeaponSheet.getWeaponByName(this.equipOffhand);
		if(weapon != null && weapon.shield) {
			return weapon.dtn;
		} else {
			return 0;
		}
	}
	,getMasterDTN: function() {
		var weapon = troshx_tros_WeaponSheet.getWeaponByName(this.equipMasterhand);
		if(weapon != null) {
			return weapon.dtn;
		} else {
			return 0;
		}
	}
	,getHighestATNOrDTN: function() {
		var atn = this.getPredictedATN();
		var dtn = this.getPredictedDTN();
		if(atn > dtn) {
			return atn;
		} else {
			return dtn;
		}
	}
	,getDTNBetterMargin: function() {
		return this.getPredictedATN() - this.getPredictedDTN();
	}
	,isDualWeilding: function() {
		if(this.equipMasterhand != null && this.equipOffhand != null) {
			var weap = troshx_tros_WeaponSheet.getWeaponByName(this.equipOffhand);
			if(weap != null) {
				return weap.shield;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	,newExchange: function(newRound) {
		if(newRound == null) {
			newRound = false;
		}
		var _g1 = 0;
		var _g = this.decidedManuevers.length;
		while(_g1 < _g) {
			var d = this.decidedManuevers[_g1++];
			d.manuever = "";
			d.manueverCP = 0;
			d.targetZone = 0;
			d.manueverType = 0;
			d.offhand = false;
			d.againstID = 0;
			d.secondary = null;
		}
		if(newRound) {
			this.currentExchange = 1;
			var _g11 = 0;
			var _g2 = this.decidedManuevers.length;
			while(_g11 < _g2) this.plannedCombos[_g11++] = 0;
		} else {
			this.currentExchange = 2;
		}
	}
	,decideStance: function(enemies,target,targetedBy) {
	}
	,decideOrientation: function(enemies,target,targetedBy) {
	}
	,decideTarget: function(enemies) {
	}
	,preDeclareManuevers: function(target,targetedBy) {
		this.opponents[0] = target;
		var count = 1;
		var totalOpponentCP = 0;
		var _g1 = 0;
		var _g = targetedBy.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(targetedBy[i] != target) {
				this.opponents[count++] = targetedBy[i];
				totalOpponentCP += targetedBy[i].cp;
			}
		}
		this.opponentLen = count;
		var _g11 = this.opponentLen;
		var _g2 = this.opponents.length;
		while(_g11 < _g2) this.opponents[_g11++] = null;
		var cpLeft = this.cp;
		var _g12 = 0;
		var _g3 = this.opponentLen;
		while(_g12 < _g3) {
			var i1 = _g12++;
			var cpToAssign = Math.min(cpLeft,Math.ceil(this.opponents[i1].cp / totalOpponentCP * this.cp)) | 0;
			this.cpBudget[i1] = cpToAssign;
			cpLeft -= cpToAssign;
		}
	}
	,getRemainingCPLeftIfUnpaid: function() {
		var cpLeft = this.cp;
		var _g1 = 0;
		var _g = this.decidedManuevers.length;
		while(_g1 < _g) {
			var _this = this.decidedManuevers[_g1++];
			cpLeft -= _this.cost + _this.manueverCP;
		}
		return cpLeft;
	}
	,getTotalThreatCPAgainst: function(targetId) {
		var cpAccum = troshx_tros_ai_TROSAiBot.CP_ALREADY_PAID?this.cp:this.getRemainingCPLeftIfUnpaid();
		var choice = this.decidedManuevers[0];
		if(choice.againstID == targetId) {
			cpAccum += choice.cost + choice.manueverCP;
		}
		choice = this.decidedManuevers[1];
		if(choice.againstID == targetId) {
			cpAccum += choice.cost + choice.manueverCP;
		}
		return cpAccum;
	}
	,declareManueverAgainstOpponentId: function(oppId) {
		var index = this.getOpponentIndex(oppId);
		if(index < 0) {
			console.log("Exception couldn't find opponent by id:" + oppId);
			return false;
		}
		return this.declareManueverAgainstOpponent(index);
	}
	,getOpponentIndex: function(oppId) {
		var _g1 = 0;
		var _g = this.opponentLen;
		while(_g1 < _g) {
			var i = _g1++;
			if(this.opponents[i].id == oppId) {
				return i;
			}
		}
		return -1;
	}
	,declareManueverAgainstOpponent: function(index) {
		this.handsUsedUp = this.manueverUsingHands;
		troshx_tros_ai_TROSAiBot.B_EQUIP = (this.handsUsedUp & 1) == 0?this.equipMasterhand:null;
		troshx_tros_ai_TROSAiBot.D_EQUIP = (this.handsUsedUp & 2) == 0?this.equipOffhand:null;
		var cpAvailable = this.cpBudget[index];
		var opponent = this.opponents[index];
		troshx_tros_ai_TROSAiBot.CURRENT_OPPONENT = opponent;
		var threatManuever = null;
		var threatManuever2 = null;
		if(opponent.decidedManuevers[0] != null && opponent.decidedManuevers[0].againstID == this.id) {
			threatManuever = opponent.decidedManuevers[0];
		} else {
			var tmp = opponent.decidedManuevers[0] == null;
		}
		if(opponent.decidedManuevers[1] != null && opponent.decidedManuevers[1].againstID == this.id) {
			if(threatManuever != null) {
				threatManuever2 = opponent.decidedManuevers[1];
			} else {
				threatManuever = opponent.decidedManuevers[1];
			}
		}
		var opponentCP = this.getTotalThreatCPAgainst(this.id);
		if(this.currentExchange != 2) {
			if(this.get_initiative()) {
				if(troshx_tros_ai_TROSAiBot.setBestComboActionWithInitiativePlan(this.cp,opponentCP,threatManuever)) {
					this.plannedCombos[index] = troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET;
					var _this = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET;
					var newChoice = this.decidedManuevers[index];
					newChoice.manuever = _this.manuever;
					newChoice.manueverCP = _this.manueverCP;
					newChoice.targetZone = _this.targetZone;
					newChoice.manueverType = _this.manueverType;
					newChoice.offhand = _this.offhand;
					newChoice.manueverTN = _this.manueverTN;
					newChoice.againstID = _this.againstID;
					return true;
				}
			} else if(troshx_tros_ai_TROSAiBot.setBestComboActionWithoutInitiativePlan(this.cp,opponentCP,threatManuever)) {
				this.plannedCombos[index] = troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET;
				var _this1 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET;
				var newChoice1 = this.decidedManuevers[index];
				newChoice1.manuever = _this1.manuever;
				newChoice1.manueverCP = _this1.manueverCP;
				newChoice1.targetZone = _this1.targetZone;
				newChoice1.manueverType = _this1.manueverType;
				newChoice1.offhand = _this1.offhand;
				newChoice1.manueverTN = _this1.manueverTN;
				newChoice1.againstID = _this1.againstID;
				return true;
			}
		} else if(this.plannedCombos[index] != 0) {
			if(troshx_tros_ai_TROSAiBot.getComboAction(this.plannedCombos[index],this.cp,opponentCP,threatManuever,this.get_initiative(),true)) {
				var _this2 = troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE;
				var newChoice2 = this.decidedManuevers[index];
				newChoice2.manuever = _this2.manuever;
				newChoice2.manueverCP = _this2.manueverCP;
				newChoice2.targetZone = _this2.targetZone;
				newChoice2.manueverType = _this2.manueverType;
				newChoice2.offhand = _this2.offhand;
				newChoice2.manueverTN = _this2.manueverTN;
				newChoice2.againstID = _this2.againstID;
				this.decidedManuevers[index].manueverCP = cpAvailable;
				return true;
			}
		}
		if(this.get_initiative()) {
			return troshx_tros_ai_TROSAiBot.tryBestPossibleAttackOrDefBoliao(this.cp,opponentCP,threatManuever,this.currentExchange == 2);
		} else {
			return troshx_tros_ai_TROSAiBot.tryBestPossibleDefenseBoliao(this.cp,opponentCP,threatManuever,this.currentExchange == 2);
		}
	}
	,get_initiative: function() {
		return this.fight_initiative != 0;
	}
	,set_initiative: function(value) {
		return (this.fight_initiative = value?1:0) != 0;
	}
	,__class__: troshx_tros_ai_TROSAiBot
	,__properties__: {set_initiative:"set_initiative",get_initiative:"get_initiative"}
};
var troshx_tros_ai_TROSAiBotInkle = function() {
};
$hxClasses["troshx.tros.ai.TROSAiBotInkle"] = troshx_tros_ai_TROSAiBotInkle;
troshx_tros_ai_TROSAiBotInkle.__name__ = ["troshx","tros","ai","TROSAiBotInkle"];
troshx_tros_ai_TROSAiBotInkle.staticVarSetter = function(varName,newValue) {
	troshx_tros_ai_TROSAiBot[varName] = newValue;
};
troshx_tros_ai_TROSAiBotInkle.bindWatchesForInk = function(c,toStory,requireMeta) {
	if(requireMeta == null) {
		requireMeta = "watch";
	}
	var rtti = haxe_rtti_Rtti.getRtti(c);
	var meta;
	meta = haxe_rtti_Meta.getStatics(c);
	var _g_head;
	var tmp;
	tmp = rtti.statics;
	_g_head = tmp.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var fieldMeta = Reflect.field(meta,val.name);
		if(requireMeta == null || fieldMeta != null && Object.prototype.hasOwnProperty.call(fieldMeta,requireMeta)) {
			var tmp1 = val.type[1];
		}
	}
};
troshx_tros_ai_TROSAiBotInkle.prototype = {
	__class__: troshx_tros_ai_TROSAiBotInkle
};
var troshx_util_LibUtil = function() { };
$hxClasses["troshx.util.LibUtil"] = troshx_util_LibUtil;
troshx_util_LibUtil.__name__ = ["troshx","util","LibUtil"];
troshx_util_LibUtil.validInt = function(val) {
	if(val != null) {
		return !isNaN(val);
	} else {
		return false;
	}
};
troshx_util_LibUtil["as"] = function(obj,type) {
	if(js_Boot.__instanceof(obj,type)) {
		return obj;
	} else {
		return null;
	}
};
troshx_util_LibUtil.asNoInline = function(obj,type) {
	if(js_Boot.__instanceof(obj,type)) {
		return obj;
	} else {
		return null;
	}
};
troshx_util_LibUtil.tryParseFloat = function(val) {
	return parseFloat(val);
};
troshx_util_LibUtil.tryParseInt = function(val) {
	return Std.parseInt(val);
};
troshx_util_LibUtil.arrayToList = function(arr) {
	var list = new List();
	var _g = 0;
	while(_g < arr.length) {
		var val = arr[_g];
		++_g;
		list.add(val);
	}
	return list;
};
troshx_util_LibUtil.getArrayItemAtIndex = function(arr,index) {
	return arr[index];
};
troshx_util_LibUtil.getListItemAtIndex = function(list,index) {
	if(index < 0 || index >= list.length) {
		return null;
	}
	var iter_head = list.h;
	var _g1 = 0;
	while(_g1 < index) {
		++_g1;
		iter_head = iter_head.next;
	}
	return iter_head.item;
};
troshx_util_LibUtil.clearArray = function(arr) {
	arr.length = 0;
};
troshx_util_LibUtil.truncateArray = function(arr,fromIndex) {
	arr.length = fromIndex;
};
troshx_util_LibUtil.findForList = function(list,f) {
	var _g_head = list.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		if(f(val)) {
			return val;
		}
	}
	return null;
};
troshx_util_LibUtil.minI = function(a,b) {
	if(a < b) {
		return a;
	} else {
		return b;
	}
};
troshx_util_LibUtil.maxI = function(a,b) {
	if(a >= b) {
		return a;
	} else {
		return b;
	}
};
troshx_util_LibUtil.minI_ = function(a,b) {
	if(a < b) {
		return a;
	} else {
		return b;
	}
};
troshx_util_LibUtil.maxI_ = function(a,b) {
	if(a >= b) {
		return a;
	} else {
		return b;
	}
};
troshx_util_LibUtil.removeArrayItemAtIndex = function(arr,index) {
	arr.splice(index,1);
};
var troshx_util_PropertyChainHolder = $hx_exports["troshx"]["util"]["PropertyChainHolder"] = function() {
	Object.defineProperty(this,"value",{ get : $bind(this,this.get_value), set : $bind(this,this.set_value)});
};
$hxClasses["troshx.util.PropertyChainHolder"] = troshx_util_PropertyChainHolder;
troshx_util_PropertyChainHolder.__name__ = ["troshx","util","PropertyChainHolder"];
troshx_util_PropertyChainHolder.prototype = {
	_src: null
	,value: null
	,propertyChain: null
	,setupProperty: function(src,property) {
		this._src = src;
		if(property == null) {
			return;
		}
		if(typeof(property) == "string") {
			var str = property;
			this.propertyChain = str.split(".");
		} else {
			this.propertyChain = property;
		}
	}
	,getPropertyChainValue: function() {
		var len = this.propertyChain.length;
		var cur = this._src;
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var propToGet = this.propertyChain[_g1++];
			var tmp;
			var tmp1;
			if(cur == null) {
				tmp1 = null;
			} else {
				var tmp2;
				if(cur.__properties__) {
					tmp = cur.__properties__["get_" + propToGet];
					tmp2 = tmp;
				} else {
					tmp2 = false;
				}
				if(tmp2) {
					tmp1 = cur[tmp]();
				} else {
					tmp1 = cur[propToGet];
				}
			}
			cur = tmp1;
			if(cur == null) {
				return null;
			}
		}
		return cur;
	}
	,setPropertyChainValue: function(val) {
		if(this._src == null) {
			this._src = { };
		}
		var cur = this._src;
		var len = this.propertyChain.length;
		var propStack = [];
		var _g1 = 0;
		while(_g1 < len) {
			var i = _g1++;
			var propToSet = this.propertyChain[i];
			propStack.push(propToSet);
			cur = this.setPropertyOf(cur,propToSet,val,i >= len - 1,propStack);
			if(cur == null) {
				return null;
			}
		}
		return cur;
	}
	,deletePropertyChainValue: function(val) {
		if(this._src == null) {
			return null;
		}
		var cur = this._src;
		var len = this.propertyChain.length;
		var propStack = [];
		var _g1 = 0;
		while(_g1 < len) {
			var i = _g1++;
			var propToSet = this.propertyChain[i];
			propStack.push(propToSet);
			cur = this.deletePropertyOf(cur,propToSet,val,i >= len - 1,propStack);
			if(cur == null) {
				return null;
			}
		}
		return cur;
	}
	,setPropertyOf: function(obj,prop,val,leaf,propStack) {
		if(!leaf) {
			var tmp;
			var tmp1;
			if(obj == null) {
				tmp1 = null;
			} else {
				var tmp2;
				if(obj.__properties__) {
					tmp = obj.__properties__["get_" + prop];
					tmp2 = tmp;
				} else {
					tmp2 = false;
				}
				if(tmp2) {
					tmp1 = obj[tmp]();
				} else {
					tmp1 = obj[prop];
				}
			}
			val = tmp1;
			var reflectProp = val;
			if(reflectProp == null) {
				if(val == null) {
					return null;
				}
				reflectProp = { };
				var value = reflectProp;
				var tmp3;
				var tmp4;
				if(obj.__properties__) {
					tmp3 = obj.__properties__["set_" + prop];
					tmp4 = tmp3;
				} else {
					tmp4 = false;
				}
				if(tmp4) {
					obj[tmp3](value);
				} else {
					obj[prop] = value;
				}
			}
			val = reflectProp;
		}
		var tmp5;
		var tmp6;
		if(obj.__properties__) {
			tmp5 = obj.__properties__["set_" + prop];
			tmp6 = tmp5;
		} else {
			tmp6 = false;
		}
		if(tmp6) {
			obj[tmp5](val);
		} else {
			obj[prop] = val;
		}
		return val;
	}
	,deletePropertyOf: function(obj,prop,val,leaf,propStack) {
		if(!leaf) {
			var tmp;
			var tmp1;
			if(obj == null) {
				tmp1 = null;
			} else {
				var tmp2;
				if(obj.__properties__) {
					tmp = obj.__properties__["get_" + prop];
					tmp2 = tmp;
				} else {
					tmp2 = false;
				}
				if(tmp2) {
					tmp1 = obj[tmp]();
				} else {
					tmp1 = obj[prop];
				}
			}
			val = tmp1;
			if(val == null) {
				return null;
			}
			var tmp3;
			var tmp4;
			if(obj.__properties__) {
				tmp3 = obj.__properties__["set_" + prop];
				tmp4 = tmp3;
			} else {
				tmp4 = false;
			}
			if(tmp4) {
				obj[tmp3](val);
			} else {
				obj[prop] = val;
			}
			return val;
		}
		Reflect.deleteField(obj,prop);
		return val;
	}
	,getPropertyOf: function(obj,prop) {
		var tmp;
		var tmp1;
		if(obj == null) {
			tmp1 = null;
		} else {
			var tmp2;
			if(obj.__properties__) {
				tmp = obj.__properties__["get_" + prop];
				tmp2 = tmp;
			} else {
				tmp2 = false;
			}
			if(tmp2) {
				tmp1 = obj[tmp]();
			} else {
				tmp1 = obj[prop];
			}
		}
		return tmp1;
	}
	,get_value: function() {
		if(this.propertyChain != null && this._src != null) {
			return this.getPropertyChainValue();
		} else {
			return null;
		}
	}
	,set_value: function(v) {
		if(this.propertyChain != null) {
			return this.setPropertyChainValue(v);
		} else {
			return null;
		}
	}
	,__class__: troshx_util_PropertyChainHolder
	,__properties__: {set_value:"set_value",get_value:"get_value"}
};
var troshx_util_ReflectUtil = $hx_exports["troshx"]["util"]["ReflectUtil"] = function() { };
$hxClasses["troshx.util.ReflectUtil"] = troshx_util_ReflectUtil;
troshx_util_ReflectUtil.__name__ = ["troshx","util","ReflectUtil"];
troshx_util_ReflectUtil.setItemStaticMethodsTo = function(c,to) {
	return troshx_util_ReflectUtil.setItemMethodsTo(c,to,true);
};
troshx_util_ReflectUtil.setItemInstanceMethodsTo = function(c,to) {
	return troshx_util_ReflectUtil.setItemMethodsTo(c,to,false);
};
troshx_util_ReflectUtil.getMetaDataOfField = function(metaName,c,t,fieldName,isStatic) {
	if(isStatic == null) {
		isStatic = false;
	}
	var meta = isStatic?haxe_rtti_Meta.getStatics(c):haxe_rtti_Meta.getFields(c);
	var fieldMeta = Reflect.field(meta,fieldName);
	if(Object.prototype.hasOwnProperty.call(fieldMeta,metaName)) {
		return Reflect.field(fieldMeta,metaName);
	}
	return null;
};
troshx_util_ReflectUtil.getEnumStrMapUnderscored = function(prefix,c) {
	var to = new haxe_ds_IntMap();
	var reference = c;
	var _g_head = haxe_rtti_Rtti.getRtti(c).statics.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		if(val.type[1] == 7) {
			if(val.name.indexOf("_") >= 0 && val.name.split("_")[0] == prefix) {
				to.h[Reflect.field(reference,val.name)] = val.name;
			}
		}
	}
	return to;
};
troshx_util_ReflectUtil.getAllEnums = function(c) {
	var myMetaHash = { };
	var dyn = { };
	troshx_util_ReflectUtil.setItemFieldsTo(c,dyn,true,"enum");
	var meta = haxe_rtti_Meta.getStatics(c);
	var _g = 0;
	var _g1 = Reflect.fields(dyn);
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var prefix = Reflect.field(Reflect.field(meta,p),"enum");
		var daMap;
		if(!Object.prototype.hasOwnProperty.call(dyn,prefix)) {
			daMap = troshx_util_ReflectUtil.getEnumStrMapUnderscored(prefix,c);
			dyn[prefix] = daMap;
		} else {
			daMap = Reflect.field(dyn,prefix);
		}
		myMetaHash[p] = daMap;
	}
	dyn._meta = myMetaHash;
	return dyn;
};
troshx_util_ReflectUtil.setItemFieldsTo = function(c,to,isStatic,requireMeta,reference) {
	if(isStatic == null) {
		isStatic = false;
	}
	var rtti = haxe_rtti_Rtti.getRtti(c);
	if(reference == null) {
		if(isStatic) {
			reference = c;
		} else {
			reference = Type.createEmptyInstance(c);
		}
	}
	var meta = isStatic?haxe_rtti_Meta.getStatics(c):haxe_rtti_Meta.getFields(c);
	var _g_head = (isStatic?rtti.statics:rtti.fields).h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var fieldMeta = Reflect.field(meta,val.name);
		if(requireMeta == null || fieldMeta != null && Object.prototype.hasOwnProperty.call(fieldMeta,requireMeta)) {
			switch(val.type[1]) {
			case 2:
				to[val.name] = Reflect.field(reference,val.name);
				break;
			case 7:
				to[val.name] = Reflect.field(reference,val.name);
				break;
			default:
			}
		}
	}
	return to;
};
troshx_util_ReflectUtil.setItemMethodsTo = function(c,to,isStatic,requireMeta) {
	if(isStatic == null) {
		isStatic = false;
	}
	var rtti = haxe_rtti_Rtti.getRtti(c);
	var reference = isStatic?c:Type.createEmptyInstance(c);
	var meta = isStatic?haxe_rtti_Meta.getStatics(c):haxe_rtti_Meta.getFields(c);
	var _g_head = (isStatic?rtti.statics:rtti.fields).h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var fieldMeta = Reflect.field(meta,val.name);
		if(requireMeta == null || fieldMeta != null && Object.prototype.hasOwnProperty.call(fieldMeta,requireMeta)) {
			if(val.type[1] == 4) {
				to[val.name] = Reflect.field(reference,val.name);
			}
		}
	}
	return to;
};
var troshx_util_ReflectVueJSUtil = $hx_exports["troshx"]["util"]["ReflectVueJSUtil"] = function() {
	troshx_util_ReflectVueJSUtil.setupClasses([troshx_components_FightState,troshx_components_Bout,troshx_core_CharSheet,troshx_core_BodyChar,troshx_core_Weapon,troshx_core_Manuever]);
};
$hxClasses["troshx.util.ReflectVueJSUtil"] = troshx_util_ReflectVueJSUtil;
troshx_util_ReflectVueJSUtil.__name__ = ["troshx","util","ReflectVueJSUtil"];
troshx_util_ReflectVueJSUtil.setupClasses = function(arrOfClasses) {
	var _g1 = 0;
	var _g = arrOfClasses.length;
	while(_g1 < _g) {
		var i = _g1++;
		arrOfClasses[i].prototype.RefClassName = arrOfClasses[i].__name__.pop();
	}
};
troshx_util_ReflectVueJSUtil.getRefObjGetter = function(refClassName,prop) {
	return function() {   return this[prop] != null ? _Ref[refClassName][this[prop]] : null } ;
};
troshx_util_ReflectVueJSUtil.getRefObjSetter = function(refClassName,prop) {
	return function(val) {  if (val == null) { this[prop] = null; return; }; if (!_Ref[refClassName][val._refid]) { _Ref[refClassName][val._refid] = val }; if (_Ref[refClassName][val._refid] != val) throw new Error('ERROR non-unique id for referential instance!'+val); this[prop] = val._refid; }
};
troshx_util_ReflectVueJSUtil.prototype = {
	__class__: troshx_util_ReflectVueJSUtil
};
var troshx_util_StringHashId = function() { };
$hxClasses["troshx.util.StringHashId"] = troshx_util_StringHashId;
troshx_util_StringHashId.__name__ = ["troshx","util","StringHashId"];
troshx_util_StringHashId.get = function() {
	return "i" + troshx_util_StringHashId.COUNT++;
};
var troshx_util_TROSAI = $hx_exports["troshx"]["util"]["TROSAI"] = function() {
};
$hxClasses["troshx.util.TROSAI"] = troshx_util_TROSAI;
troshx_util_TROSAI.__name__ = ["troshx","util","TROSAI"];
troshx_util_TROSAI.factorial = function(val) {
	if(val == 0) {
		val = 1;
	}
	var v = val;
	while(--v > 1) val *= v;
	return val;
};
troshx_util_TROSAI.binomialCoef = function(n,r) {
	if(r > 0) {
		var val = n;
		if(n == 0) {
			val = 1;
		}
		var v = val;
		while(--v > 1) val *= v;
		var tmp = val;
		var val1 = r;
		if(r == 0) {
			val1 = 1;
		}
		var v1 = val1;
		while(--v1 > 1) val1 *= v1;
		var tmp1 = val1;
		var val2 = n - r;
		if(val2 == 0) {
			val2 = 1;
		}
		var v2 = val2;
		while(--v2 > 1) val2 *= v2;
		return tmp / (tmp1 * val2);
	} else {
		return 1;
	}
};
troshx_util_TROSAI.getTNSuccessProbForDie = function(tn) {
	if(tn < 11) {
		return (10 - tn + 1) / 10;
	} else {
		return (1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
	}
};
troshx_util_TROSAI.getXSuccessesProb = function(numDiceToRoll,tn,x) {
	var prob = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
	var tmp;
	if(x > 0) {
		var val = numDiceToRoll;
		if(numDiceToRoll == 0) {
			val = 1;
		}
		var v = val;
		while(--v > 1) val *= v;
		var tmp1 = val;
		var val1 = x;
		if(x == 0) {
			val1 = 1;
		}
		var v1 = val1;
		while(--v1 > 1) val1 *= v1;
		var tmp2 = val1;
		var val2 = numDiceToRoll - x;
		if(val2 == 0) {
			val2 = 1;
		}
		var v2 = val2;
		while(--v2 > 1) val2 *= v2;
		tmp = tmp1 / (tmp2 * val2);
	} else {
		tmp = 1;
	}
	return tmp * Math.pow(prob,x) * Math.pow(1 - prob,numDiceToRoll - x);
};
troshx_util_TROSAI.getAtLeastXSuccessesProb = function(numDiceToRoll,tn,x) {
	var accum = 0;
	while(x <= numDiceToRoll) {
		var prob = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
		var tmp;
		if(x > 0) {
			var val = numDiceToRoll;
			if(numDiceToRoll == 0) {
				val = 1;
			}
			var v = val;
			while(--v > 1) val *= v;
			var tmp1 = val;
			var val1 = x;
			if(val1 == 0) {
				val1 = 1;
			}
			var v1 = val1;
			while(--v1 > 1) val1 *= v1;
			var tmp2 = val1;
			var val2 = numDiceToRoll - x;
			if(val2 == 0) {
				val2 = 1;
			}
			var v2 = val2;
			while(--v2 > 1) val2 *= v2;
			tmp = tmp1 / (tmp2 * val2);
		} else {
			tmp = 1;
		}
		accum += tmp * Math.pow(prob,x) * Math.pow(1 - prob,numDiceToRoll - x);
		++x;
	}
	if(accum > 1) {
		accum = 1;
	}
	return accum;
};
troshx_util_TROSAI.probabilityAOrB = function(a,b) {
	return a + b - a * b;
};
troshx_util_TROSAI.probabilityOfArrayOr = function(arr) {
	var p = 0;
	if(arr.length == 0) {
		return 0;
	}
	p = arr[0];
	var _g1 = 1;
	var _g = arr.length;
	while(_g1 < _g) {
		var b = arr[_g1++];
		p = p + b - p * b;
	}
	return p;
};
troshx_util_TROSAI.getBelowOrEqualXSuccessesProb = function(numDiceToRoll,tn,x) {
	var accum = 0;
	while(x >= 0) {
		var prob = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
		var tmp;
		if(x > 0) {
			var val = numDiceToRoll;
			if(numDiceToRoll == 0) {
				val = 1;
			}
			var v = val;
			while(--v > 1) val *= v;
			var tmp1 = val;
			var val1 = x;
			if(val1 == 0) {
				val1 = 1;
			}
			var v1 = val1;
			while(--v1 > 1) val1 *= v1;
			var tmp2 = val1;
			var val2 = numDiceToRoll - x;
			if(val2 == 0) {
				val2 = 1;
			}
			var v2 = val2;
			while(--v2 > 1) val2 *= v2;
			tmp = tmp1 / (tmp2 * val2);
		} else {
			tmp = 1;
		}
		accum += tmp * Math.pow(prob,x) * Math.pow(1 - prob,numDiceToRoll - x);
		--x;
	}
	if(accum > 1) {
		accum = 1;
	}
	return accum;
};
troshx_util_TROSAI.getChanceToSucceedContest = function(numDice,tn,againstNumDice,againstTN,rs,requireAtLeast1TS) {
	if(requireAtLeast1TS == null) {
		requireAtLeast1TS = true;
	}
	if(rs == null) {
		rs = 1;
	}
	if(rs > numDice) {
		return 0;
	}
	var i = requireAtLeast1TS && rs < 1?1:rs;
	var p = 0;
	while(i <= numDice) {
		var k = i - rs;
		if(k > againstNumDice) {
			k = againstNumDice;
		}
		while(k >= 0) {
			var prob = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
			var tmp;
			if(i > 0) {
				var val = numDice;
				if(numDice == 0) {
					val = 1;
				}
				var v = val;
				while(--v > 1) val *= v;
				var tmp1 = val;
				var val1 = i;
				if(val1 == 0) {
					val1 = 1;
				}
				var v1 = val1;
				while(--v1 > 1) val1 *= v1;
				var tmp2 = val1;
				var val2 = numDice - i;
				if(val2 == 0) {
					val2 = 1;
				}
				var v2 = val2;
				while(--v2 > 1) val2 *= v2;
				tmp = tmp1 / (tmp2 * val2);
			} else {
				tmp = 1;
			}
			var tmp3 = tmp * Math.pow(prob,i) * Math.pow(1 - prob,numDice - i);
			var prob1 = againstTN < 11?(10 - againstTN + 1) / 10:(1 - (againstTN - Math.floor(againstTN / 10) * 10) / 10) * Math.pow(0.1,Math.floor(againstTN / 10));
			var tmp4;
			if(k > 0) {
				var val3 = againstNumDice;
				if(againstNumDice == 0) {
					val3 = 1;
				}
				var v3 = val3;
				while(--v3 > 1) val3 *= v3;
				var tmp5 = val3;
				var val4 = k;
				if(val4 == 0) {
					val4 = 1;
				}
				var v4 = val4;
				while(--v4 > 1) val4 *= v4;
				var tmp6 = val4;
				var val5 = againstNumDice - k;
				if(val5 == 0) {
					val5 = 1;
				}
				var v5 = val5;
				while(--v5 > 1) val5 *= v5;
				tmp4 = tmp5 / (tmp6 * val5);
			} else {
				tmp4 = 1;
			}
			p += tmp3 * (tmp4 * Math.pow(prob1,k) * Math.pow(1 - prob1,againstNumDice - k));
			--k;
		}
		++i;
	}
	return p;
};
troshx_util_TROSAI.getChanceToSucceed = function(numDice,tn,rs) {
	if(rs == null) {
		rs = 1;
	}
	if(rs > numDice) {
		return 0;
	}
	return troshx_util_TROSAI.getAtLeastXSuccessesProb(numDice,tn,rs);
};
troshx_util_TROSAI.getAllXSuccessesProb = function(numDice,tn) {
	var arr = [];
	var _g1 = 0;
	var _g = numDice + 1;
	while(_g1 < _g) {
		var i = _g1++;
		var prob = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
		var tmp;
		if(i > 0) {
			var val = numDice;
			if(numDice == 0) {
				val = 1;
			}
			var v = val;
			while(--v > 1) val *= v;
			var tmp1 = val;
			var val1 = i;
			if(i == 0) {
				val1 = 1;
			}
			var v1 = val1;
			while(--v1 > 1) val1 *= v1;
			var tmp2 = val1;
			var val2 = numDice - i;
			if(val2 == 0) {
				val2 = 1;
			}
			var v2 = val2;
			while(--v2 > 1) val2 *= v2;
			tmp = tmp1 / (tmp2 * val2);
		} else {
			tmp = 1;
		}
		arr.push(tmp * Math.pow(prob,i) * Math.pow(1 - prob,numDice - i));
	}
	return arr;
};
troshx_util_TROSAI.getTabulatedRollData = function(numDice,tn) {
	var arr = [];
	var accum = 0;
	var i = numDice;
	while(i >= 0) {
		var prob = tn < 11?(10 - tn + 1) / 10:(1 - (tn - Math.floor(tn / 10) * 10) / 10) * Math.pow(0.1,Math.floor(tn / 10));
		var tmp;
		if(i > 0) {
			var val = numDice;
			if(numDice == 0) {
				val = 1;
			}
			var v = val;
			while(--v > 1) val *= v;
			var tmp1 = val;
			var val1 = i;
			if(val1 == 0) {
				val1 = 1;
			}
			var v1 = val1;
			while(--v1 > 1) val1 *= v1;
			var tmp2 = val1;
			var val2 = numDice - i;
			if(val2 == 0) {
				val2 = 1;
			}
			var v2 = val2;
			while(--v2 > 1) val2 *= v2;
			tmp = tmp1 / (tmp2 * val2);
		} else {
			tmp = 1;
		}
		var v3 = tmp * Math.pow(prob,i) * Math.pow(1 - prob,numDice - i);
		accum += v3;
		arr.push({ x : i, gte : accum, eq : v3});
		--i;
	}
	arr.reverse();
	var _g1 = 0;
	var _g = arr.length - 1;
	while(_g1 < _g) {
		var i1 = _g1++;
		if(arr[i1 + 1].eq <= arr[i1].eq) {
			arr[i1].peak = 1;
			if(arr[i1 + 1].eq != arr[i1].eq) {
				break;
			}
		}
	}
	return arr;
};
troshx_util_TROSAI.maxPrecision = function(x,precision) {
	return troshx_util_TROSAI.roundTo(x,Math.pow(10,-precision));
};
troshx_util_TROSAI.roundTo = function(x,y) {
	return Math.round(x / y) * y;
};
troshx_util_TROSAI.displayAsPercentage = function(probability) {
	probability *= 100;
	if(probability < 1 && probability > 0) {
		return troshx_util_TROSAI.roundTo(probability,Math.pow(10,-2));
	} else {
		return Math.floor(probability);
	}
};
troshx_util_TROSAI.prototype = {
	__class__: troshx_util_TROSAI
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
$hxClasses.Math = Math;
String.prototype.__class__ = $hxClasses.String = String;
String.__name__ = ["String"];
$hxClasses.Array = Array;
Array.__name__ = ["Array"];
Date.prototype.__class__ = $hxClasses.Date = Date;
Date.__name__ = ["Date"];
var Int = $hxClasses.Int = { __name__ : ["Int"]};
var Dynamic = $hxClasses.Dynamic = { __name__ : ["Dynamic"]};
var Float = $hxClasses.Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses.Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {}
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
dat_gui_DatUtil.DEFAULT_FLOAT_STEP = 0;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	if(__map_reserved.lt != null) {
		h.setReserved("lt","<");
	} else {
		h.h["lt"] = "<";
	}
	if(__map_reserved.gt != null) {
		h.setReserved("gt",">");
	} else {
		h.h["gt"] = ">";
	}
	if(__map_reserved.amp != null) {
		h.setReserved("amp","&");
	} else {
		h.h["amp"] = "&";
	}
	if(__map_reserved.quot != null) {
		h.setReserved("quot","\"");
	} else {
		h.h["quot"] = "\"";
	}
	if(__map_reserved.apos != null) {
		h.setReserved("apos","'");
	} else {
		h.h["apos"] = "'";
	}
	$r = h;
	return $r;
}(this));
js_Boot.__toStr = { }.toString;
tjson_TJSON.OBJECT_REFERENCE_PREFIX = "@~obRef#";
troshx_components_FightState.__meta__ = { fields : { target : { ref : null}}};
troshx_components_FightState.GOT_INITIATIVE = 2;
troshx_components_FightState.CONTESTING_INITIATIVE = 1;
troshx_components_FightState.NO_INITIATIVE = 0;
troshx_components_FightState.REROLL_INITIATIVE = -1;
troshx_components_FightState.UNCERTAIN_INITATIVE = -10;
troshx_components_FightState.UNCERTAIN_INITIATIVE_RESOLVED = 10;
troshx_components_FightState.ORIENTATION_NONE = 0;
troshx_components_FightState.ORIENTATION_DEFENSIVE = 1;
troshx_components_FightState.ORIENTATION_CAUTIOUS = 2;
troshx_components_FightState.ORIENTATION_AGGRESSIVE = 3;
troshx_components_FightState.ORIENTATION_STRINGS = ["None","Defensive","Cautious","Aggressive"];
troshx_core_BodyChar.D_DESTROY_PART = 1;
troshx_core_BodyChar.D_DEATH = 2;
troshx_core_BodyChar.WOUND_TYPE_CUT = 1;
troshx_core_BodyChar.WOUND_TYPE_PIERCE = 2;
troshx_core_BodyChar.WOUND_TYPE_BLUNT_TRAUMA = 4;
troshx_core_BodyChar.WOUND_D_DESTROY = 1;
troshx_core_BodyChar.WOUND_D_DEATH = 2;
troshx_core_BoutMessage.TYPE_NONE = 0;
troshx_core_BoutMessage.TYPE_PLAYERS_TURN = 1;
troshx_core_BoutMessage.TYPE_RESOLVE_MANUEVER = 2;
troshx_core_GameRules.__meta__ = { statics : { FLEE_CAP : { inspect : [{ display : "selector"}], choices : ["FLEE_CAP"]}}};
troshx_core_GameRules.__rtti = "<class path=\"troshx.core.GameRules\" params=\"\">\n\t<FLEE_CAP_NONE public=\"1\" get=\"inline\" set=\"null\" expr=\"0\" line=\"13\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</FLEE_CAP_NONE>\n\t<FLEE_CAP_BY_MOBILITY_EXCHANGE1 public=\"1\" get=\"inline\" set=\"null\" expr=\"1\" line=\"14\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</FLEE_CAP_BY_MOBILITY_EXCHANGE1>\n\t<FLEE_CAP_BY_MOBILITY_ALL public=\"1\" get=\"inline\" set=\"null\" expr=\"2\" line=\"15\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</FLEE_CAP_BY_MOBILITY_ALL>\n\t<FLEE_CAP public=\"1\" expr=\"FLEE_CAP_NONE\" line=\"17\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>FLEE_CAP_NONE</e></m>\n\t\t\t<m n=\"inspect\"><e>{ display : \"selector\" }</e></m>\n\t\t\t<m n=\"choices\"><e>\"FLEE_CAP\"</e></m>\n\t\t</meta>\n\t</FLEE_CAP>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":expose\"/>\n\t\t<m n=\":rtti\"/>\n\t</meta>\n</class>";
troshx_core_GameRules.FLEE_CAP_NONE = 0;
troshx_core_GameRules.FLEE_CAP_BY_MOBILITY_EXCHANGE1 = 1;
troshx_core_GameRules.FLEE_CAP_BY_MOBILITY_ALL = 2;
troshx_core_GameRules.FLEE_CAP = 0;
troshx_core_Manuever.MANUEVER_HAND_NONE = 0;
troshx_core_Manuever.MANUEVER_HAND_MASTER = 1;
troshx_core_Manuever.MANUEVER_HAND_SECONDARY = 2;
troshx_core_Manuever.MANUEVER_HAND_BOTH = 3;
troshx_core_Manuever.MANUEVER_TYPE_MELEE = 0;
troshx_core_Manuever.MANUEVER_TYPE_RANGED = 1;
troshx_core_Manuever.DAMAGE_TYPE_NONE = 0;
troshx_core_Manuever.DAMAGE_TYPE_CUTTING = 1;
troshx_core_Manuever.DAMAGE_TYPE_PUNCTURING = 2;
troshx_core_Manuever.DAMAGE_TYPE_BLUDGEONING = 3;
troshx_core_Manuever.ATTACK_TYPE_STRIKE = 1;
troshx_core_Manuever.ATTACK_TYPE_THRUST = 2;
troshx_core_Manuever.DEFEND_TYPE_OFFHAND = 1;
troshx_core_Manuever.DEFEND_TYPE_MASTERHAND = 2;
troshx_core_Manuever.TYPE_NONE = 0;
troshx_core_Manuever.TYPE_DEFENSIVE = 1;
troshx_core_Manuever.TYPE_OFFENSIVE = 2;
troshx_core_Weapon.__rtti = "<class path=\"troshx.core.Weapon\" params=\"\">\n\t<ATTR_BASE_NONE public=\"1\" get=\"inline\" set=\"null\" expr=\"-1\" line=\"39\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-1</e></m></meta>\n\t</ATTR_BASE_NONE>\n\t<ATTR_BASE_STRENGTH public=\"1\" get=\"inline\" set=\"null\" expr=\"0\" line=\"40\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</ATTR_BASE_STRENGTH>\n\t<HOOK_STRIKE get=\"inline\" set=\"null\" expr=\"1\" line=\"42\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</HOOK_STRIKE>\n\t<HOOK_THRUST get=\"inline\" set=\"null\" expr=\"2\" line=\"43\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</HOOK_THRUST>\n\t<createDyn public=\"1\" set=\"method\" line=\"129\" static=\"1\"><f a=\"name:profGroups:properties\">\n\t<c path=\"String\"/>\n\t<c path=\"Array\"><c path=\"String\"/></c>\n\t<d/>\n\t<c path=\"troshx.core.Weapon\"/>\n</f></createDyn>\n\t<atn public=\"1\"><x path=\"Int\"/></atn>\n\t<atn2 public=\"1\"><x path=\"Int\"/></atn2>\n\t<dtn public=\"1\"><x path=\"Int\"/></dtn>\n\t<dntT public=\"1\"><x path=\"Int\"/></dntT>\n\t<dtn2 public=\"1\"><x path=\"Int\"/></dtn2>\n\t<damage public=\"1\"><x path=\"Int\"/></damage>\n\t<damage2 public=\"1\"><x path=\"Int\"/></damage2>\n\t<damage3 public=\"1\"><x path=\"Int\"/></damage3>\n\t<shield public=\"1\"><x path=\"Bool\"/></shield>\n\t<profeciencies public=\"1\"><c path=\"Array\"><c path=\"String\"/></c></profeciencies>\n\t<name public=\"1\"><c path=\"String\"/></name>\n\t<drawCutModifier public=\"1\"><x path=\"Int\"/></drawCutModifier>\n\t<attrBaseIndex public=\"1\"><x path=\"Int\"/></attrBaseIndex>\n\t<twoHanded public=\"1\"><x path=\"Bool\"/></twoHanded>\n\t<rangedWeapon public=\"1\"><x path=\"Bool\"/></rangedWeapon>\n\t<cpPenalty public=\"1\"><x path=\"Float\"/></cpPenalty>\n\t<movePenalty public=\"1\"><x path=\"Float\"/></movePenalty>\n\t<shieldLimit public=\"1\"><x path=\"Int\"/></shieldLimit>\n\t<blunt public=\"1\"><x path=\"Bool\"/></blunt>\n\t<range public=\"1\"><x path=\"Int\"/></range>\n\t<hooking public=\"1\"><x path=\"Int\"/></hooking>\n\t<getDamageTo public=\"1\" set=\"method\" line=\"46\"><f a=\"body:manuever:targetZone:margin:strength\">\n\t<c path=\"troshx.core.BodyChar\"/>\n\t<c path=\"troshx.core.Manuever\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getDamageTo>\n\t<getHookingATN public=\"1\" set=\"method\" line=\"65\">\n\t\t<f a=\"?tieBiasToThrust\" v=\"false\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ tieBiasToThrust : false }</e></m></meta>\n\t</getHookingATN>\n\t<getHookingATNType public=\"1\" set=\"method\" line=\"79\">\n\t\t<f a=\"?tieBiasToThrust\" v=\"false\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ tieBiasToThrust : false }</e></m></meta>\n\t</getHookingATNType>\n\t<getInlineTest public=\"1\" get=\"inline\" set=\"null\" line=\"87\"><f a=\"\"><x path=\"Float\"/></f></getInlineTest>\n\t<weaponListInlineTest public=\"1\"><c path=\"Array\"><c path=\"troshx.core.Weapon\"/></c></weaponListInlineTest>\n\t<getInlineTest2 public=\"1\" get=\"inline\" set=\"null\" line=\"97\">\n\t\t<f a=\"?val:?val2\" v=\"0:5\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ val2 : 5, val : 0 }</e></m></meta>\n\t</getInlineTest2>\n\t<new public=\"1\" set=\"method\" line=\"106\"><f a=\"name:profGroups\">\n\t<c path=\"String\"/>\n\t<c path=\"Array\"><c path=\"String\"/></c>\n\t<x path=\"Void\"/>\n</f></new>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":expose\"/>\n\t\t<m n=\":rtti\"/>\n\t</meta>\n</class>";
troshx_core_Weapon.ATTR_BASE_NONE = -1;
troshx_core_Weapon.ATTR_BASE_STRENGTH = 0;
troshx_core_Weapon.HOOK_STRIKE = 1;
troshx_core_Weapon.HOOK_THRUST = 2;
troshx_sos_BoutController.STEP_ORIENTATION_OR_RESOLVE = 0;
troshx_sos_BoutController.STEP_TARGET_SELECTION = 1;
troshx_sos_BoutController.STEP_DECLARATION = 2;
troshx_sos_BoutController.TOTAL_STEPS = 3;
troshx_tros_HumanoidBody.ZONE_I = 1;
troshx_tros_HumanoidBody.ZONE_II = 2;
troshx_tros_HumanoidBody.ZONE_III = 3;
troshx_tros_HumanoidBody.ZONE_IV = 4;
troshx_tros_HumanoidBody.ZONE_V = 5;
troshx_tros_HumanoidBody.ZONE_VI = 6;
troshx_tros_HumanoidBody.ZONE_VII = 7;
troshx_tros_HumanoidBody.ZONE_VIII = 8;
troshx_tros_HumanoidBody.ZONE_IX = 9;
troshx_tros_HumanoidBody.ZONE_X = 10;
troshx_tros_HumanoidBody.ZONE_XI = 11;
troshx_tros_HumanoidBody.ZONE_XII = 12;
troshx_tros_HumanoidBody.ZONE_XIII = 13;
troshx_tros_HumanoidBody.ZONE_XIV = 14;
troshx_tros_HumanoidBody.CENTER_OF_MASS = [3,2,5,6];
troshx_tros_HumanoidBody.CENTER_OF_MASS_T = [10,11,11,12];
troshx_tros_WeaponSheet.LIST = [troshx_core_Weapon.createDyn("Short Sword",["cutthrust","swordshield"],{ 'range' : 1, 'atn' : 7, 'atn2' : 5, 'dtn' : 7, 'damage' : -1, 'damage2' : 1}),troshx_core_Weapon.createDyn("Gladius",["swordshield"],{ 'range' : 1, 'atn' : 6, 'atn2' : 6, 'dtn' : 7, 'damage' : 0, 'damage2' : 1, 'drawCutModifier' : 0}),troshx_core_Weapon.createDyn("Light Mace",["mace"],{ 'range' : 1, 'atn' : 6, 'atn2' : 6, 'dtn' : 7, 'damage' : 1, 'damage2' : 0, 'drawCutModifier' : 0}),troshx_core_Weapon.createDyn("Blunted Sword",["swordshield","cutthrust"],{ 'range' : 2, 'atn' : 6, 'atn2' : 6, 'dtn' : 6, 'damage' : 0, 'damage2' : 0, 'drawCutModifier' : 0}),troshx_core_Weapon.createDyn("Arming Sword",["swordshield","cutthrust"],{ 'range' : 2, 'atn' : 6, 'atn2' : 7, 'dtn' : 6, 'damage' : 1, 'damage2' : 0, 'drawCutModifier' : 0}),troshx_core_Weapon.createDyn("Rapier",["rapier","caserapiers"],{ 'range' : 3, 'atn' : 7, 'atn2' : 5, 'dtn' : 8, 'dtnT' : 6, 'damage' : -3, 'damage2' : 2, 'drawCutModifier' : 1}),troshx_core_Weapon.createDyn("Hand Shield",["swordshield","massweaponshield"],{ 'shield' : true, 'dtn' : 7, 'dtn2' : 9}),troshx_core_Weapon.createDyn("Small Shield",["swordshield","massweaponshield"],{ 'shield' : true, 'dtn' : 6, 'dtn2' : 8}),troshx_core_Weapon.createDyn("Medium Shield",["swordshield","massweaponshield"],{ 'shield' : true, 'dtn' : 5, 'dtn2' : 7, 'cpPenalty' : 0.5, 'movePenalty' : 0.5}),troshx_core_Weapon.createDyn("Large Shield",["swordshield","massweaponshield"],{ 'shield' : true, 'dtn' : 5, 'dtn2' : 6, 'cpPenalty' : 0.5, 'movePenalty' : 1})];
troshx_tros_WeaponSheet.HASH = troshx_tros_WeaponSheet.createHashLookupViaName(troshx_tros_WeaponSheet.LIST);
troshx_util_AIManueverChoice.__meta__ = { fields : { manuever : { inspect : null}, manueverCP : { inspect : [{ min : 0}]}, manueverTN : { inspect : [{ min : 0}]}, targetZone : { inspect : [{ min : 0}]}, manueverType : { inspect : [{ display : "selector"}], choices : ["TYPE"]}, offhand : { inspect : null}, againstID : { inspect : null}, cost : { inspect : [{ min : 0}]}}};
troshx_util_AIManueverChoice.__rtti = "<class path=\"troshx.util.AIManueverChoice\" params=\"\" module=\"troshx.util.TROSAI\">\n\t<TYPE_ATTACKING public=\"1\" get=\"inline\" set=\"null\" expr=\"2\" line=\"240\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</TYPE_ATTACKING>\n\t<TYPE_DEFENDING public=\"1\" get=\"inline\" set=\"null\" expr=\"1\" line=\"241\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</TYPE_DEFENDING>\n\t<TARGET_WEAPON public=\"1\" get=\"inline\" set=\"null\" expr=\"0\" line=\"243\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</TARGET_WEAPON>\n\t<TARGET_SHIELD public=\"1\" get=\"inline\" set=\"null\" expr=\"1\" line=\"244\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</TARGET_SHIELD>\n\t<TARGET_OFFHAND public=\"1\" get=\"inline\" set=\"null\" expr=\"TARGET_SHIELD\" line=\"245\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>TARGET_SHIELD</e></m></meta>\n\t</TARGET_OFFHAND>\n\t<DO_NOTHING public=\"1\" expr=\"&quot;doNothing&quot;\" line=\"267\" static=\"1\">\n\t\t<c path=\"String\"/>\n\t\t<meta><m n=\":value\"><e>\"doNothing\"</e></m></meta>\n\t</DO_NOTHING>\n\t<DO_NOTHING_WAIT_FOR_DEFENSE public=\"1\" expr=\"&quot;waitForQuickDefense&quot;\" line=\"268\" static=\"1\">\n\t\t<c path=\"String\"/>\n\t\t<meta><m n=\":value\"><e>\"waitForQuickDefense\"</e></m></meta>\n\t</DO_NOTHING_WAIT_FOR_DEFENSE>\n\t<manuever public=\"1\">\n\t\t<c path=\"String\"/>\n\t\t<meta><m n=\"inspect\"/></meta>\n\t</manuever>\n\t<manueverCP public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"inspect\"><e>{ min : 0 }</e></m></meta>\n\t</manueverCP>\n\t<manueverTN public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"inspect\"><e>{ min : 0 }</e></m></meta>\n\t</manueverTN>\n\t<targetZone public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"inspect\"><e>{ min : 0 }</e></m></meta>\n\t</targetZone>\n\t<manueverType public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\"inspect\"><e>{ display : \"selector\" }</e></m>\n\t\t\t<m n=\"choices\"><e>\"TYPE\"</e></m>\n\t\t</meta>\n\t</manueverType>\n\t<offhand public=\"1\">\n\t\t<x path=\"Bool\"/>\n\t\t<meta><m n=\"inspect\"/></meta>\n\t</offhand>\n\t<againstID public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"inspect\"/></meta>\n\t</againstID>\n\t<cost public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"inspect\"><e>{ min : 0 }</e></m></meta>\n\t</cost>\n\t<getManueverCPSpent public=\"1\" get=\"inline\" set=\"null\" line=\"236\"><f a=\"\"><x path=\"Int\"/></f></getManueverCPSpent>\n\t<secondary public=\"1\"><c path=\"troshx.util.AIManueverChoice\"/></secondary>\n\t<nothing public=\"1\" get=\"inline\" set=\"null\" line=\"256\"><f a=\"\"><x path=\"Void\"/></f></nothing>\n\t<waitForQuickDefense public=\"1\" get=\"inline\" set=\"null\" line=\"269\"><f a=\"\"><x path=\"Void\"/></f></waitForQuickDefense>\n\t<setupSecondAttack public=\"1\" set=\"method\" line=\"275\">\n\t\t<f a=\"manuever:manueverCP:manueverTN:targetZone:cost:?offhand\" v=\":::::false\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Void\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ offhand : false }</e></m></meta>\n\t</setupSecondAttack>\n\t<setupSecondDefend public=\"1\" set=\"method\" line=\"280\">\n\t\t<f a=\"manuever:manueverCP:manueverTN:targetZone:cost:?offhand\" v=\":::::false\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Void\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ offhand : false }</e></m></meta>\n\t</setupSecondDefend>\n\t<copyTo public=\"1\" get=\"inline\" set=\"null\" line=\"285\">\n\t\t<f a=\"newChoice:?newAgainstID\" v=\":-1\">\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Void\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ newAgainstID : -1 }</e></m></meta>\n\t</copyTo>\n\t<setAttack public=\"1\" set=\"method\" line=\"296\">\n\t\t<f a=\"manuever:manueverCP:manueverTN:targetZone:cost:?offhand\" v=\":::::false\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Void\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ offhand : false }</e></m></meta>\n\t</setAttack>\n\t<setDefend public=\"1\" set=\"method\" line=\"308\">\n\t\t<f a=\"manuever:manueverCP:manueverTN:cost:?offhand\" v=\"::::false\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Void\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ offhand : false }</e></m></meta>\n\t</setDefend>\n\t<new public=\"1\" set=\"method\" line=\"249\"><f a=\"\"><x path=\"Void\"/></f></new>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":rtti\"/>\n\t\t<m n=\":expose\"/>\n\t</meta>\n</class>";
troshx_util_AIManueverChoice.TYPE_ATTACKING = 2;
troshx_util_AIManueverChoice.TYPE_DEFENDING = 1;
troshx_util_AIManueverChoice.TARGET_WEAPON = 0;
troshx_util_AIManueverChoice.TARGET_SHIELD = 1;
troshx_util_AIManueverChoice.TARGET_OFFHAND = 1;
troshx_util_AIManueverChoice.DO_NOTHING = "doNothing";
troshx_util_AIManueverChoice.DO_NOTHING_WAIT_FOR_DEFENSE = "waitForQuickDefense";
troshx_tros_ai_TROSAiBot.__meta__ = { statics : { AVAIL_bash : { inspect : [{ min : 0}], watch : null}, AVAIL_spike : { inspect : [{ min : 0}], watch : null}, AVAIL_cut : { inspect : [{ min : 0}], watch : null}, AVAIL_thrust : { inspect : [{ min : 0}], watch : null}, AVAIL_beat : { inspect : [{ min : 0}], watch : null}, AVAIL_bindstrike : { inspect : [{ min : 0}], watch : null}, AVAIL_hook : { inspect : [{ min : 0}], watch : null}, AVAIL_block : { inspect : [{ min : 0}], watch : null}, AVAIL_parry : { inspect : [{ min : 0}], watch : null}, AVAIL_duckweave : { inspect : [{ min : 0}], watch : null}, AVAIL_partialevasion : { inspect : [{ min : 0}], watch : null}, AVAIL_fullevasion : { inspect : [{ min : 0}], watch : null}, AVAIL_blockopenstrike : { inspect : [{ min : 0}], watch : null}, AVAIL_counter : { inspect : [{ min : 0}], watch : null}, AVAIL_rota : { inspect : [{ min : 0}], watch : null}, AVAIL_expulsion : { inspect : [{ min : 0}], watch : null}, AVAIL_disarm : { inspect : [{ min : 0}], watch : null}, AVAIL_StealInitiative : { inspect : [{ min : 0}], watch : null}, B_EQUIP : { settable : null}, B_IS_OFFHAND : { settable : null}, D_EQUIP : { settable : null}, WISH_TO_REGAIN_STANCE : { inspect : null}, CURRENTLY_AGGROED : { inspect : null}, CURRENT_OPPONENT : { inject : null}, P_THRESHOLD_FAVORABLE : { inspect : [{ min : 0, max : 1, display : "range", step : 0.01}]}, P_THRESHOLD_BORDERLINE : { inspect : [{ min : 0, max : 1, display : "range", step : 0.01}]}, P_RECKLESS : { inspect : [{ min : 0, max : 1, display : "range", step : 0.01}]}, B_BS_REQUIRED_DMG_DEFAULT : { inspect : [{ min : 1}]}, CAN_DESPERATE_ALPHASTRIKE : { inspect : null}, DESPERATE_ALPHASTRIKE_CHANCE : { inspect : [{ display : "range", min : 0, step : 0.01, max : 1}]}, B_COMBO_CANDIDATES : { 'enum' : ["COMBO"]}, getRegularAttackOrAdvantageMove : { inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : -1}},{ inspect : { min : 1}}]], 'return' : ["B_USE_ADVANTAGE"]}, getRegularAdvantageMove : { 'return' : ["B_CANDIDATES","B_CANDIDATE_COUNT","ATTACK_AGGR"], inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : -1}},{ inspect : { min : 1}}]]}, getRegularAttack : { 'return' : ["B_CANDIDATES","B_CANDIDATE_COUNT","ATTACK_AGGR"], inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : -1}},{ inspect : { min : 1}}]]}, getRegularDefense : { 'return' : ["B_CANDIDATES","B_CANDIDATE_COUNT"], inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}}]]}, MANUEVER_COMBO_SET : { 'enum' : ["COMBO"]}, checkCostViability : { 'return' : ["B_VIABLE_PROBABILITY"]}, checkCostViabilityBorderline : { 'return' : ["B_VIABLE_PROBABILITY"]}, checkCostAntiFavorability : { 'return' : ["B_VIABLE_PROBABILITY_GET"]}, checkCostAntiBorderline : { 'return' : ["B_VIABLE_PROBABILITY_GET"]}, getASuitableAttack : { 'return' : ["MANUEVER_CHOICE","B_VIABLE_PROBABILITY"], inspect : [[{ inspect : { min : 0, step : 0.01, max : 1, display : "range"}},{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 1}}]]}, getAForcefulInitiativeAttack : { 'return' : ["MANUEVER_CHOICE","B_VIABLE_PROBABILITY_GET"], inspect : [[{ inspect : { min : 0, step : 0.01, max : 1, display : "range"}},{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 1}}]]}, getASuitableDefense : { 'return' : ["MANUEVER_CHOICE","B_VIABLE_PROBABILITY"], inspect : [[{ inspect : { min : 0, step : 0.01, max : 1, display : "range"}},{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 1}}]]}, getFavorableAttack : { inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 1}},{ inspect : null},{ inspect : null, bitmask : "FLAG"},{ inspect : { min : 0, display : "range", step : 0.01, max : 1}}]], 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE","B_VIABLE_HEURISTIC"]}, getBorderlineAttack : { inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 1}},{ inspect : null},{ inspect : null, bitmask : "FLAG"},{ inspect : { min : 0, display : "range", step : 0.01, max : 1}}]], 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE","B_VIABLE_HEURISTIC"]}, getFavorableDefense : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE","B_VIABLE_HEURISTIC"]}, getBorderlineDefense : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE","B_VIABLE_HEURISTIC"], inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 1}},{ inspect : null},{ inspect : null, bitmask : "FLAG"},{ inspect : { min : 0, display : "range", step : 0.01, max : 1}}]]}, getBlockOpenAndStrike : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getRota : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getCounter : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getExpulsion : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getSpecialDefWithReturnAttack : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE","DEF_AGGR","B_MANUEVER_CHOICES","B_MANUEVER_CHOICE_COUNT"], inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 0}},{ inspect : { min : 1}},{ inspect : { min : 0, display : "range", step : 0.01, max : 1}}]]}, getDisarm : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getHook : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getBindStrike : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getBeat : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getAdvantageGainCPOffensiveMove : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"]}, getPredictedOpponentDTN : { inspect : null}, getPredictedOpponentATN : { inspect : null}, getComboExchangeBudgetingWithInitiative : { inspect : [[{ inspect : { display : "selector"}, choices : "COMBO"},{ inspect : { min : 0}},{ inspect : { min : 0}}]]}, getComboActionTest : { 'return' : ["B_VIABLE_PROBABILITY_GET","MANUEVER_CHOICE"], inspect : [[{ inspect : { display : "selector"}, choices : "COMBO"},{ inspect : { min : 0}},{ inspect : { min : 0}}]]}, setBestComboActionWithInitiativePlanTest : { 'return' : ["MANUEVER_COMBO_SET","MANUEVER_CHOICE_SET","B_COMBO_CANDIDATE_COUNT","B_COMBO_CANDIDATES"], inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}}]]}, setBestComboActionWithoutInitiativePlanTest : { 'return' : ["MANUEVER_COMBO_SET","MANUEVER_CHOICE_SET","B_COMBO_CANDIDATE_COUNT","B_COMBO_CANDIDATES"], inspect : [[{ inspect : { min : 0}},{ inspect : { min : 0}}]]}}, fields : { body : { inject : null}, cp : { bind : ["_cp"]}, perception : { bind : ["_perception"]}, equipMasterhand : { bind : ["_equipMasterhand"]}, equipOffhand : { bind : ["_equipOffhand"]}, mobility : { bind : ["_mobility"]}, id : { bind : ["_id"]}, fight_initiative : { bind : ["_fight_initiative"]}, stance : { bind : ["_fight_stance"]}, manueverUsingHands : { bind : ["_manueverUsingHands"]}}};
troshx_tros_ai_TROSAiBot.__rtti = "<class path=\"troshx.tros.ai.TROSAiBot\" params=\"\">\n\t<ENEMY_STEAL_COST expr=\"4\" line=\"45\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>4</e></m></meta>\n\t</ENEMY_STEAL_COST>\n\t<MIN_EXPOSED_AV expr=\"0\" line=\"46\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</MIN_EXPOSED_AV>\n\t<getTargetAlphaStrikeCPThreshold get=\"inline\" set=\"null\" line=\"47\" static=\"1\"><f a=\"\"><x path=\"Int\"/></f></getTargetAlphaStrikeCPThreshold>\n\t<setAlphaStrikeBudget get=\"inline\" set=\"null\" line=\"50\" static=\"1\"><f a=\"cp:cp2\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Void\"/>\n</f></setAlphaStrikeBudget>\n\t<AVAIL_bash public=\"1\" expr=\"0\" line=\"78\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_bash>\n\t<AVAIL_spike public=\"1\" expr=\"0\" line=\"79\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_spike>\n\t<AVAIL_cut public=\"1\" expr=\"0\" line=\"80\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_cut>\n\t<AVAIL_thrust public=\"1\" expr=\"0\" line=\"81\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_thrust>\n\t<AVAIL_beat public=\"1\" expr=\"0\" line=\"82\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_beat>\n\t<AVAIL_bindstrike public=\"1\" expr=\"0\" line=\"83\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_bindstrike>\n\t<AVAIL_hook public=\"1\" expr=\"0\" line=\"84\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_hook>\n\t<AVAIL_block public=\"1\" expr=\"0\" line=\"87\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_block>\n\t<AVAIL_parry public=\"1\" expr=\"0\" line=\"88\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_parry>\n\t<AVAIL_duckweave public=\"1\" expr=\"0\" line=\"89\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_duckweave>\n\t<AVAIL_partialevasion public=\"1\" expr=\"0\" line=\"90\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_partialevasion>\n\t<AVAIL_fullevasion public=\"1\" expr=\"0\" line=\"91\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_fullevasion>\n\t<AVAIL_blockopenstrike public=\"1\" expr=\"0\" line=\"92\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_blockopenstrike>\n\t<AVAIL_counter public=\"1\" expr=\"0\" line=\"93\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_counter>\n\t<AVAIL_rota public=\"1\" expr=\"0\" line=\"94\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_rota>\n\t<AVAIL_expulsion public=\"1\" expr=\"0\" line=\"95\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_expulsion>\n\t<AVAIL_disarm public=\"1\" expr=\"0\" line=\"96\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_disarm>\n\t<AVAIL_StealInitiative public=\"1\" expr=\"0\" line=\"97\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0 }</e></m>\n\t\t\t<m n=\"watch\"/>\n\t\t</meta>\n\t</AVAIL_StealInitiative>\n\t<setTypicalAVAILCostsForTesting set=\"method\" line=\"99\" static=\"1\"><f a=\"\"><x path=\"Void\"/></f></setTypicalAVAILCostsForTesting>\n\t<getCostOfAVAIL get=\"inline\" set=\"null\" line=\"121\" static=\"1\"><f a=\"avail\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getCostOfAVAIL>\n\t<getCostOfManuever set=\"method\" line=\"125\" static=\"1\"><f a=\"manuever\">\n\t<c path=\"String\"/>\n\t<x path=\"Int\"/>\n</f></getCostOfManuever>\n\t<B_EQUIP expr=\"&quot;&quot;\" line=\"155\" static=\"1\">\n\t\t<c path=\"String\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>\"\"</e></m>\n\t\t\t<m n=\"settable\"/>\n\t\t</meta>\n\t</B_EQUIP>\n\t<B_IS_OFFHAND expr=\"false\" line=\"156\" static=\"1\">\n\t\t<x path=\"Bool\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>false</e></m>\n\t\t\t<m n=\"settable\"/>\n\t\t</meta>\n\t</B_IS_OFFHAND>\n\t<D_EQUIP expr=\"&quot;&quot;\" line=\"157\" static=\"1\">\n\t\t<c path=\"String\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>\"\"</e></m>\n\t\t\t<m n=\"settable\"/>\n\t\t</meta>\n\t</D_EQUIP>\n\t<B_COMBO_EXCHANGE_BUDGET expr=\"new Vector&lt;Int&gt;(4)\" line=\"160\" static=\"1\">\n\t\t<x path=\"haxe.ds.Vector\"><x path=\"Int\"/></x>\n\t\t<meta><m n=\":value\"><e><![CDATA[new Vector<Int>(4)]]></e></m></meta>\n\t</B_COMBO_EXCHANGE_BUDGET>\n\t<BUDGET_EXCHANGE_1 get=\"inline\" set=\"null\" expr=\"0\" line=\"161\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</BUDGET_EXCHANGE_1>\n\t<BUDGET_EXCHANGE_1_ENEMY get=\"inline\" set=\"null\" expr=\"1\" line=\"162\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</BUDGET_EXCHANGE_1_ENEMY>\n\t<BUDGET_EXCHANGE_2 get=\"inline\" set=\"null\" expr=\"2\" line=\"163\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</BUDGET_EXCHANGE_2>\n\t<BUDGET_EXCHANGE_2_ENEMY get=\"inline\" set=\"null\" expr=\"3\" line=\"164\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>3</e></m></meta>\n\t</BUDGET_EXCHANGE_2_ENEMY>\n\t<WISH_TO_REGAIN_STANCE expr=\"false\" line=\"166\" static=\"1\">\n\t\t<x path=\"Bool\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>false</e></m>\n\t\t\t<m n=\"inspect\"/>\n\t\t</meta>\n\t</WISH_TO_REGAIN_STANCE>\n\t<CURRENTLY_AGGROED expr=\"false\" line=\"167\" static=\"1\">\n\t\t<x path=\"Bool\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>false</e></m>\n\t\t\t<m n=\"inspect\"/>\n\t\t</meta>\n\t</CURRENTLY_AGGROED>\n\t<CURRENT_OPPONENT static=\"1\">\n\t\t<c path=\"troshx.tros.ai.TROSAiBot\"/>\n\t\t<meta><m n=\"inject\"/></meta>\n\t</CURRENT_OPPONENT>\n\t<CP_ALREADY_PAID public=\"1\" expr=\"true\" line=\"171\" static=\"1\">\n\t\t<x path=\"Bool\"/>\n\t\t<meta><m n=\":value\"><e>true</e></m></meta>\n\t</CP_ALREADY_PAID>\n\t<COMBO_PureMeanStrikes get=\"inline\" set=\"null\" expr=\"1\" line=\"176\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</COMBO_PureMeanStrikes>\n\t<COMBO_HeavyFirstStrikes get=\"inline\" set=\"null\" expr=\"2\" line=\"177\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</COMBO_HeavyFirstStrikes>\n\t<COMBO_AlphaDisarm get=\"inline\" set=\"null\" expr=\"3\" line=\"178\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>3</e></m></meta>\n\t</COMBO_AlphaDisarm>\n\t<COMBO_AlphaHookStrike get=\"inline\" set=\"null\" expr=\"4\" line=\"179\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>4</e></m></meta>\n\t</COMBO_AlphaHookStrike>\n\t<COMBO_AlphaStrike get=\"inline\" set=\"null\" expr=\"5\" line=\"180\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>5</e></m></meta>\n\t</COMBO_AlphaStrike>\n\t<COMBO_FeintStrike get=\"inline\" set=\"null\" expr=\"6\" line=\"181\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>6</e></m></meta>\n\t</COMBO_FeintStrike>\n\t<COMBO_DoubleAttack get=\"inline\" set=\"null\" expr=\"7\" line=\"182\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>7</e></m></meta>\n\t</COMBO_DoubleAttack>\n\t<COMBO_SimulatenousBlockStrike get=\"inline\" set=\"null\" expr=\"8\" line=\"183\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>8</e></m></meta>\n\t</COMBO_SimulatenousBlockStrike>\n\t<COMBOS_LEN_INITIATIVE get=\"inline\" set=\"null\" expr=\"9\" line=\"184\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>9</e></m></meta>\n\t</COMBOS_LEN_INITIATIVE>\n\t<COMBO_CoupDeGrace get=\"inline\" set=\"null\" expr=\"9\" line=\"185\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>9</e></m></meta>\n\t</COMBO_CoupDeGrace>\n\t<COMBOS_LEN_INITIATIVE_FINAL get=\"inline\" set=\"null\" expr=\"10\" line=\"186\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>10</e></m></meta>\n\t</COMBOS_LEN_INITIATIVE_FINAL>\n\t<COMBO_DefensiveFirst get=\"inline\" set=\"null\" expr=\"-1\" line=\"189\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-1</e></m></meta>\n\t</COMBO_DefensiveFirst>\n\t<COMBO_DefensiveBorderline get=\"inline\" set=\"null\" expr=\"-2\" line=\"190\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-2</e></m></meta>\n\t</COMBO_DefensiveBorderline>\n\t<COMBO_SpecialDefFirst get=\"inline\" set=\"null\" expr=\"-3\" line=\"191\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-3</e></m></meta>\n\t</COMBO_SpecialDefFirst>\n\t<COMBO_AlphaInitiativeStealer get=\"inline\" set=\"null\" expr=\"-4\" line=\"192\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-4</e></m></meta>\n\t</COMBO_AlphaInitiativeStealer>\n\t<COMBO_AlphaDisarmDef get=\"inline\" set=\"null\" expr=\"-5\" line=\"193\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-5</e></m></meta>\n\t</COMBO_AlphaDisarmDef>\n\t<COMBO_SimulatenousBlockStrikeStealer get=\"inline\" set=\"null\" expr=\"-6\" line=\"194\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-6</e></m></meta>\n\t</COMBO_SimulatenousBlockStrikeStealer>\n\t<COMBOS_LEN_NO_INITAITIVE get=\"inline\" set=\"null\" expr=\"7\" line=\"195\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>7</e></m></meta>\n\t</COMBOS_LEN_NO_INITAITIVE>\n\t<P_THRESHOLD_FAVORABLE public=\"1\" expr=\"0.75\" line=\"198\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0.75</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0, max : 1, display : \"range\", step : 0.01 }</e></m>\n\t\t</meta>\n\t</P_THRESHOLD_FAVORABLE>\n\t<P_THRESHOLD_BORDERLINE public=\"1\" expr=\"0.5\" line=\"199\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0.5</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0, max : 1, display : \"range\", step : 0.01 }</e></m>\n\t\t</meta>\n\t</P_THRESHOLD_BORDERLINE>\n\t<P_RECKLESS public=\"1\" expr=\"0.2\" line=\"200\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0.2</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 0, max : 1, display : \"range\", step : 0.01 }</e></m>\n\t\t</meta>\n\t</P_RECKLESS>\n\t<P_THRESHOLD_ANTI_FAVORABLE public=\"1\" expr=\"0.75\" line=\"203\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta><m n=\":value\"><e>0.75</e></m></meta>\n\t</P_THRESHOLD_ANTI_FAVORABLE>\n\t<B_CANDIDATES expr=\"[]\" line=\"207\" static=\"1\">\n\t\t<c path=\"Array\"><c path=\"String\"/></c>\n\t\t<meta><m n=\":value\"><e>[]</e></m></meta>\n\t</B_CANDIDATES>\n\t<B_CANDIDATE_COUNT expr=\"0\" line=\"208\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</B_CANDIDATE_COUNT>\n\t<B_BS_REQUIRED expr=\"1\" line=\"209\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</B_BS_REQUIRED>\n\t<B_BS_REQUIRED_DEFAULT expr=\"1\" line=\"212\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</B_BS_REQUIRED_DEFAULT>\n\t<COUP_BS_MODIFIER get=\"inline\" set=\"null\" expr=\"1\" line=\"213\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</COUP_BS_MODIFIER>\n\t<B_BS_REQUIRED_DMG_DEFAULT expr=\"1\" line=\"214\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>1</e></m>\n\t\t\t<m n=\"inspect\"><e>{ min : 1 }</e></m>\n\t\t</meta>\n\t</B_BS_REQUIRED_DMG_DEFAULT>\n\t<PREFERED_HOOK_BS expr=\"2\" line=\"215\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</PREFERED_HOOK_BS>\n\t<PREFERED_DISARM_BS expr=\"2\" line=\"216\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</PREFERED_DISARM_BS>\n\t<PREFERED_DISARM_DEF_BS expr=\"2\" line=\"217\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</PREFERED_DISARM_DEF_BS>\n\t<CAN_DESPERATE_ALPHASTRIKE expr=\"false\" line=\"218\" static=\"1\">\n\t\t<x path=\"Bool\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>false</e></m>\n\t\t\t<m n=\"inspect\"/>\n\t\t</meta>\n\t</CAN_DESPERATE_ALPHASTRIKE>\n\t<DESPERATE_ALPHASTRIKE_CHANCE expr=\"0.5\" line=\"219\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0.5</e></m>\n\t\t\t<m n=\"inspect\"><e>{ display : \"range\", min : 0, step : 0.01, max : 1 }</e></m>\n\t\t</meta>\n\t</DESPERATE_ALPHASTRIKE_CHANCE>\n\t<B_VIABLE_PROBABILITY static=\"1\"><x path=\"Float\"/></B_VIABLE_PROBABILITY>\n\t<B_VIABLE_PROBABILITY_GET static=\"1\"><x path=\"Float\"/></B_VIABLE_PROBABILITY_GET>\n\t<B_VIABLE_HEURISTIC static=\"1\"><x path=\"Bool\"/></B_VIABLE_HEURISTIC>\n\t<B_MANUEVER_CHOICES expr=\"[]\" line=\"225\" static=\"1\">\n\t\t<c path=\"Array\"><c path=\"troshx.util.AIManueverChoice\"/></c>\n\t\t<meta><m n=\":value\"><e>[]</e></m></meta>\n\t</B_MANUEVER_CHOICES>\n\t<B_MANUEVER_CHOICE_PROBABILITIES expr=\"[]\" line=\"226\" static=\"1\">\n\t\t<c path=\"Array\"><x path=\"Float\"/></c>\n\t\t<meta><m n=\":value\"><e>[]</e></m></meta>\n\t</B_MANUEVER_CHOICE_PROBABILITIES>\n\t<B_MANUEVER_CHOICE_COUNT expr=\"0\" line=\"227\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</B_MANUEVER_CHOICE_COUNT>\n\t<B_COMBO_CANDIDATES expr=\"[]\" line=\"229\" static=\"1\">\n\t\t<c path=\"Array\"><x path=\"Int\"/></c>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>[]</e></m>\n\t\t\t<m n=\"enum\"><e>\"COMBO\"</e></m>\n\t\t</meta>\n\t</B_COMBO_CANDIDATES>\n\t<B_COMBO_CANDIDATE_MANUEVER expr=\"[]\" line=\"230\" static=\"1\">\n\t\t<c path=\"Array\"><c path=\"troshx.util.AIManueverChoice\"/></c>\n\t\t<meta><m n=\":value\"><e>[]</e></m></meta>\n\t</B_COMBO_CANDIDATE_MANUEVER>\n\t<B_COMBO_CANDIDATE_COUNT expr=\"0\" line=\"231\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</B_COMBO_CANDIDATE_COUNT>\n\t<BPROB_BASE get=\"inline\" set=\"null\" expr=\"1000\" line=\"233\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta><m n=\":value\"><e>1000</e></m></meta>\n\t</BPROB_BASE>\n\t<DMG_AGGR_BASE get=\"inline\" set=\"null\" expr=\"10\" line=\"234\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta><m n=\":value\"><e>10</e></m></meta>\n\t</DMG_AGGR_BASE>\n\t<IMPOSSIBLE_TN get=\"inline\" set=\"null\" expr=\"888\" line=\"235\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>888</e></m></meta>\n\t</IMPOSSIBLE_TN>\n\t<B_USE_ADVANTAGE public=\"1\" expr=\"false\" line=\"238\" static=\"1\">\n\t\t<x path=\"Bool\"/>\n\t\t<meta><m n=\":value\"><e>false</e></m></meta>\n\t</B_USE_ADVANTAGE>\n\t<getRegularAttackOrAdvantageMove public=\"1\" set=\"method\" line=\"250\" static=\"1\">\n\t\t<f a=\"availableCP:?roll:?againstRoll:?againstTN\" v=\":0:-1:1\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"String\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ againstTN : 1, againstRoll : -1, roll : 0 }</e></m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : -1 } }, { inspect : { min : 1 } }]</e></m>\n\t\t\t<m n=\"return\"><e>\"B_USE_ADVANTAGE\"</e></m>\n\t\t</meta>\n\t</getRegularAttackOrAdvantageMove>\n\t<getRegularAdvantageMove set=\"method\" line=\"272\" static=\"1\">\n\t\t<f a=\"availableCP:?roll:?againstRoll:?againstTN\" v=\":0:-1:1\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"String\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ againstTN : 1, againstRoll : -1, roll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_CANDIDATES\"</e>\n\t\t\t\t<e>\"B_CANDIDATE_COUNT\"</e>\n\t\t\t\t<e>\"ATTACK_AGGR\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : -1 } }, { inspect : { min : 1 } }]</e></m>\n\t\t</meta>\n\t</getRegularAdvantageMove>\n\t<mathMax get=\"inline\" set=\"null\" line=\"327\" static=\"1\"><f a=\"a:b\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></mathMax>\n\t<enforceDmgAggrIfFav set=\"method\" line=\"331\" static=\"1\"><f a=\"val\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n</f></enforceDmgAggrIfFav>\n\t<ATTACK_AGGR expr=\"0\" line=\"336\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</ATTACK_AGGR>\n\t<getRegularAttack set=\"method\" line=\"347\" static=\"1\">\n\t\t<f a=\"availableCP:?roll:?againstRoll:?againstTN\" v=\":0:-1:1\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"String\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ againstTN : 1, againstRoll : -1, roll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_CANDIDATES\"</e>\n\t\t\t\t<e>\"B_CANDIDATE_COUNT\"</e>\n\t\t\t\t<e>\"ATTACK_AGGR\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : -1 } }, { inspect : { min : 1 } }]</e></m>\n\t\t</meta>\n\t</getRegularAttack>\n\t<getRegularDefense public=\"1\" set=\"method\" line=\"452\" static=\"1\">\n\t\t<f a=\"availableCP:?roll:?enforceMustRegainInitiative\" v=\":0:false\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<c path=\"String\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ enforceMustRegainInitiative : false, roll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_CANDIDATES\"</e>\n\t\t\t\t<e>\"B_CANDIDATE_COUNT\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }]</e></m>\n\t\t</meta>\n\t</getRegularDefense>\n\t<getATNOfManuever set=\"method\" line=\"515\" static=\"1\"><f a=\"manuever\">\n\t<c path=\"String\"/>\n\t<x path=\"Int\"/>\n</f></getATNOfManuever>\n\t<isFleeingManuever get=\"inline\" set=\"null\" line=\"536\" static=\"1\"><f a=\"manueverName\">\n\t<c path=\"String\"/>\n\t<x path=\"Bool\"/>\n</f></isFleeingManuever>\n\t<getDTNOfManuever set=\"method\" line=\"540\" static=\"1\"><f a=\"manuever\">\n\t<c path=\"String\"/>\n\t<x path=\"Int\"/>\n</f></getDTNOfManuever>\n\t<getFollowupAtkManuever set=\"method\" line=\"564\" static=\"1\">\n\t\t<f a=\"favorable:lastManuever:availableCPWithBonus:againstCP:?customThreshold\" v=\"::::0\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ customThreshold : 0 }</e></m></meta>\n\t</getFollowupAtkManuever>\n\t<getTargetZoneAverageAVOffset public=\"1\" set=\"method\" line=\"573\" static=\"1\"><f a=\"tarZone:weaponName\">\n\t<x path=\"Int\"/>\n\t<c path=\"String\"/>\n\t<x path=\"Int\"/>\n</f></getTargetZoneAverageAVOffset>\n\t<getRegularTargetZone public=\"1\" set=\"method\" line=\"578\" static=\"1\"><f a=\"manuever:atn:cp\">\n\t<c path=\"String\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getRegularTargetZone>\n\t<MANUEVER_CHOICE expr=\"new AIManueverChoice()\" line=\"611\" static=\"1\">\n\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t<meta><m n=\":value\"><e>new AIManueverChoice()</e></m></meta>\n\t</MANUEVER_CHOICE>\n\t<MANUEVER_CHOICE_1 expr=\"new AIManueverChoice()\" line=\"612\" static=\"1\">\n\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t<meta><m n=\":value\"><e>new AIManueverChoice()</e></m></meta>\n\t</MANUEVER_CHOICE_1>\n\t<MANUEVER_CHOICE_SET expr=\"new AIManueverChoice()\" line=\"613\" static=\"1\">\n\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t<meta><m n=\":value\"><e>new AIManueverChoice()</e></m></meta>\n\t</MANUEVER_CHOICE_SET>\n\t<MANUEVER_COMBO_SET expr=\"0\" line=\"614\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"enum\"><e>\"COMBO\"</e></m>\n\t\t</meta>\n\t</MANUEVER_COMBO_SET>\n\t<checkCostViability set=\"method\" line=\"617\" static=\"1\">\n\t\t<f a=\"availableCP:tn:threshold:againstRoll:?againstTN:?useAllCP\" v=\"::::1:false\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ useAllCP : false, againstTN : 1 }</e></m>\n\t\t\t<m n=\"return\"><e>\"B_VIABLE_PROBABILITY\"</e></m>\n\t\t</meta>\n\t</checkCostViability>\n\t<checkCostViabilityWithBs set=\"method\" line=\"632\" static=\"1\">\n\t\t<f a=\"availableCP:tn:threshold:againstRoll:?againstTN:?useAllCP:?bs\" v=\"::::1:false:1\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ bs : 1, useAllCP : false, againstTN : 1 }</e></m></meta>\n\t</checkCostViabilityWithBs>\n\t<precisionPerc get=\"inline\" set=\"null\" line=\"640\" static=\"1\"><f a=\"val\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n</f></precisionPerc>\n\t<checkCostViabilityBorderline set=\"method\" line=\"645\" static=\"1\">\n\t\t<f a=\"availableCP:tn:threshold:againstRoll:?againstTN:?useAllCP\" v=\"::::1:false\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ useAllCP : false, againstTN : 1 }</e></m>\n\t\t\t<m n=\"return\"><e>\"B_VIABLE_PROBABILITY\"</e></m>\n\t\t</meta>\n\t</checkCostViabilityBorderline>\n\t<checkCostAntiFavorability set=\"method\" line=\"668\" static=\"1\">\n\t\t<f a=\"availableCP:tn:threshold:againstCP:?againstTN:?useAllCP:?offset:?requiredBS\" v=\"::::1:false:0:1\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ requiredBS : 1, offset : 0, useAllCP : false, againstTN : 1 }</e></m>\n\t\t\t<m n=\"return\"><e>\"B_VIABLE_PROBABILITY_GET\"</e></m>\n\t\t</meta>\n\t</checkCostAntiFavorability>\n\t<checkCostAntiBorderline set=\"method\" line=\"707\" static=\"1\">\n\t\t<f a=\"availableCP:tn:threshold:againstCP:?againstTN:?useAllCP:?offset\" v=\"::::1:false:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ offset : 0, useAllCP : false, againstTN : 1 }</e></m>\n\t\t\t<m n=\"return\"><e>\"B_VIABLE_PROBABILITY_GET\"</e></m>\n\t\t</meta>\n\t</checkCostAntiBorderline>\n\t<getCostOfAvail get=\"inline\" set=\"null\" line=\"741\" static=\"1\"><f a=\"avail\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getCostOfAvail>\n\t<getTheSuitableAttack set=\"method\" line=\"745\" static=\"1\">\n\t\t<f a=\"manuever:tn:tarZone:threshold:availableCP:?againstRoll:?againstTN:?favorable:?useAllCP\" v=\":::::0:1:true:false\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ useAllCP : false, favorable : true, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</getTheSuitableAttack>\n\t<getTheSuitableDefense set=\"method\" line=\"755\" static=\"1\">\n\t\t<f a=\"manuever:tn:threshold:availableCP:?againstRoll:?againstTN:?favorable:?useAllCP\" v=\"::::0:1:true:false\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ useAllCP : false, favorable : true, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</getTheSuitableDefense>\n\t<getTheForcefulInitiativeAttack set=\"method\" line=\"764\" static=\"1\">\n\t\t<f a=\"manuever:tn:tarZone:threshold:availableCP:?againstCP:?againstTN:?favorable:?useAllCP:?offset\" v=\":::::0:1:true:false:0\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ offset : 0, useAllCP : false, favorable : true, againstTN : 1, againstCP : 0 }</e></m></meta>\n\t</getTheForcefulInitiativeAttack>\n\t<getASuitableAttack public=\"1\" set=\"method\" line=\"775\" static=\"1\">\n\t\t<f a=\"threshold:availableCP:?againstRoll:?againstTN:?favorable:?useAllCP\" v=\"::0:1:true:false\">\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ useAllCP : false, favorable : true, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0, step : 0.01, max : 1, display : \"range\" } }, { inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 1 } }]</e></m>\n\t\t</meta>\n\t</getASuitableAttack>\n\t<getAForcefulInitiativeAttack public=\"1\" set=\"method\" line=\"793\" static=\"1\">\n\t\t<f a=\"threshold:availableCP:?againstCP:?againstTN:?favorable:?useAllCP:?offset\" v=\"::0:1:true:false:0\">\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ offset : 0, useAllCP : false, favorable : true, againstTN : 1, againstCP : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0, step : 0.01, max : 1, display : \"range\" } }, { inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 1 } }]</e></m>\n\t\t</meta>\n\t</getAForcefulInitiativeAttack>\n\t<getASuitableDefense public=\"1\" set=\"method\" line=\"813\" static=\"1\">\n\t\t<f a=\"threshold:availableCP:?againstRoll:?againstTN:?mustRegainInitiative:?favorable:?useAllCP\" v=\"::0:1:false:true:false\">\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ useAllCP : false, favorable : true, mustRegainInitiative : false, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0, step : 0.01, max : 1, display : \"range\" } }, { inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 1 } }]</e></m>\n\t\t</meta>\n\t</getASuitableDefense>\n\t<FLAG_GET_CHEAPEST public=\"1\" get=\"inline\" set=\"null\" expr=\"1\" line=\"824\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>1</e></m></meta>\n\t</FLAG_GET_CHEAPEST>\n\t<FLAG_USE_ALL_CP public=\"1\" get=\"inline\" set=\"null\" expr=\"2\" line=\"825\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>2</e></m></meta>\n\t</FLAG_USE_ALL_CP>\n\t<FLAG_BORDERLINE_DEF_SAFETY public=\"1\" get=\"inline\" set=\"null\" expr=\"4\" line=\"826\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>4</e></m></meta>\n\t</FLAG_BORDERLINE_DEF_SAFETY>\n\t<FLEE_TN public=\"1\" get=\"inline\" set=\"null\" expr=\"4\" line=\"828\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>4</e></m></meta>\n\t</FLEE_TN>\n\t<getFavorableAttack public=\"1\" get=\"inline\" set=\"null\" line=\"832\" static=\"1\">\n\t\t<f a=\"availableCP:?againstRoll:?againstTN:?heuristic:?flags:?customThreshold\" v=\":0:1:true:0:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ customThreshold : 0, flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 1 } }, { inspect : null }, { inspect : null, bitmask : \"FLAG\" }, { inspect : { min : 0, display : \"range\", step : 0.01, max : 1 } }]</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"B_VIABLE_HEURISTIC\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getFavorableAttack>\n\t<getBorderlineAttack public=\"1\" set=\"method\" line=\"840\" static=\"1\">\n\t\t<f a=\"availableCP:?againstRoll:?againstTN:?heuristic:?flags:?customThreshold\" v=\":0:1:true:0:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ customThreshold : 0, flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 1 } }, { inspect : null }, { inspect : null, bitmask : \"FLAG\" }, { inspect : { min : 0, display : \"range\", step : 0.01, max : 1 } }]</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"B_VIABLE_HEURISTIC\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getBorderlineAttack>\n\t<getFBAttack set=\"method\" line=\"845\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?heuristic:?flags:?customThreshold\" v=\"::0:1:true:0:0\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ customThreshold : 0, flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</getFBAttack>\n\t<getFBDefense set=\"method\" line=\"967\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?heuristic:?flags:?customThreshold\" v=\"::0:1:true:0:0\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ customThreshold : 0, flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</getFBDefense>\n\t<getFavorableDefense public=\"1\" get=\"inline\" set=\"null\" line=\"1106\" static=\"1\">\n\t\t<f a=\"availableCP:?againstRoll:?againstTN:?heuristic:?flags\" v=\":0:1:true:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"B_VIABLE_HEURISTIC\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getFavorableDefense>\n\t<getBorderlineDefense public=\"1\" get=\"inline\" set=\"null\" line=\"1112\" static=\"1\">\n\t\t<f a=\"availableCP:?againstRoll:?againstTN:?heuristic:?flags:?customThreshold\" v=\":0:1:true:0:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ customThreshold : 0, flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"B_VIABLE_HEURISTIC\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 1 } }, { inspect : null }, { inspect : null, bitmask : \"FLAG\" }, { inspect : { min : 0, display : \"range\", step : 0.01, max : 1 } }]</e></m>\n\t\t</meta>\n\t</getBorderlineDefense>\n\t<getFleeOrDefend set=\"method\" line=\"1117\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?heuristic:?flags:?customThreshold:?secondExchange\" v=\"::0:1:true:0:0:false\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ secondExchange : false, customThreshold : 0, flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</getFleeOrDefend>\n\t<minimalDefenseFirst public=\"1\" set=\"method\" line=\"1129\" static=\"1\">\n\t\t<f a=\"availableCP:?againstRoll:?againstTN:?enemyCPInReserve\" v=\":0:1:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ enemyCPInReserve : 0, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</minimalDefenseFirst>\n\t<minimalDefenseOnly get=\"inline\" set=\"null\" line=\"1141\" static=\"1\">\n\t\t<f a=\"availableCP:?againstRoll:?againstTN:?flags\" v=\":0:1:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ flags : 0, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</minimalDefenseOnly>\n\t<lastDitchFleeOrDefend set=\"method\" line=\"1147\" static=\"1\">\n\t\t<f a=\"availableCP:threatManuever:?secondExchange:?enemyCPInReserve\" v=\"::false:0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ enemyCPInReserve : 0, secondExchange : false }</e></m></meta>\n\t</lastDitchFleeOrDefend>\n\t<weightedChoiceBetween set=\"method\" line=\"1322\" static=\"1\"><f a=\"trueConditionProbability:falseConditionProbability\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n\t<x path=\"Bool\"/>\n</f></weightedChoiceBetween>\n\t<weightedChoiceBetween2 set=\"method\" line=\"1327\" static=\"1\"><f a=\"trueConditionProbability:falseConditionProbability:maxMarginOfDifference\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n\t<x path=\"Bool\"/>\n</f></weightedChoiceBetween2>\n\t<absDiffF get=\"inline\" set=\"null\" line=\"1331\" static=\"1\"><f a=\"val:val2\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n</f></absDiffF>\n\t<getDesperateFlee set=\"method\" line=\"1335\" static=\"1\"><f a=\"availableCP:secondExchange\">\n\t<x path=\"Int\"/>\n\t<x path=\"Bool\"/>\n\t<x path=\"Bool\"/>\n</f></getDesperateFlee>\n\t<getFlee set=\"method\" line=\"1345\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?heuristic:?flags:?customThreshold:?secondExchange\" v=\"::0:1:true:0:0:false\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ secondExchange : false, customThreshold : 0, flags : 0, heuristic : true, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</getFlee>\n\t<getCPMaxForFleeing get=\"inline\" set=\"null\" line=\"1369\" static=\"1\"><f a=\"availableCP:secondExchange\">\n\t<x path=\"Int\"/>\n\t<x path=\"Bool\"/>\n\t<x path=\"Int\"/>\n</f></getCPMaxForFleeing>\n\t<tryBestPossibleDefenseBoliao set=\"method\" line=\"1375\" static=\"1\"><f a=\"cp:cp2:threatManuever:secondExchange\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t<x path=\"Bool\"/>\n\t<x path=\"Bool\"/>\n</f></tryBestPossibleDefenseBoliao>\n\t<tryBestPossibleAttackBoliao set=\"method\" line=\"1382\" static=\"1\"><f a=\"cp:cp2:threatManuever:secondExchange\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t<x path=\"Bool\"/>\n\t<x path=\"Bool\"/>\n</f></tryBestPossibleAttackBoliao>\n\t<MOCK_RETURN_ATTACK expr=\"new AIManueverChoice()\" line=\"1400\" static=\"1\">\n\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t<meta><m n=\":value\"><e>new AIManueverChoice()</e></m></meta>\n\t</MOCK_RETURN_ATTACK>\n\t<tryBestPossibleAttackOrDefBoliao set=\"method\" line=\"1401\" static=\"1\"><f a=\"cp:cp2:threatManuever:secondExchange\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t<x path=\"Bool\"/>\n\t<x path=\"Bool\"/>\n</f></tryBestPossibleAttackOrDefBoliao>\n\t<tryBestPossibleDefWithInitiativeBoliao get=\"inline\" set=\"null\" line=\"1423\" static=\"1\"><f a=\"cp:cp2:threatManuever:secondExchange\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t<x path=\"Bool\"/>\n\t<x path=\"Bool\"/>\n</f></tryBestPossibleDefWithInitiativeBoliao>\n\t<addPossibleRegularManueverChoice get=\"inline\" set=\"null\" line=\"1439\" static=\"1\"><f a=\"index\">\n\t<x path=\"Int\"/>\n\t<x path=\"Void\"/>\n</f></addPossibleRegularManueverChoice>\n\t<getAdvantageManuever set=\"method\" line=\"1444\" static=\"1\">\n\t\t<f a=\"manueverName:favorable:availableCP:?againstRoll:?againstTN:?flags:?customThreshold:?preferedRS:?defensive:?alwaysUseOffhand\" v=\":::0:1:0:0:1:false:false\">\n\t\t\t<c path=\"String\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ alwaysUseOffhand : false, defensive : false, preferedRS : 1, customThreshold : 0, flags : 0, againstTN : 1, againstRoll : 0 }</e></m></meta>\n\t</getAdvantageManuever>\n\t<getBlockOpenAndStrike public=\"1\" set=\"method\" line=\"1473\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?flags:?customThreshold:?preferedRS\" v=\"::0:1:0:0:1\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferedRS : 1, customThreshold : 0, flags : 0, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getBlockOpenAndStrike>\n\t<getRota public=\"1\" get=\"inline\" set=\"null\" line=\"1478\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:againstRoll:againstTN:?flags:?customThreshold:?preferedRS\" v=\"::::0:0:1\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferedRS : 1, customThreshold : 0, flags : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getRota>\n\t<getCounter public=\"1\" get=\"inline\" set=\"null\" line=\"1483\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:againstRoll:againstTN:?flags:?customThreshold:?preferedRS\" v=\"::::0:0:1\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferedRS : 1, customThreshold : 0, flags : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getCounter>\n\t<getExpulsion public=\"1\" get=\"inline\" set=\"null\" line=\"1488\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:againstRoll:againstTN:?flags:?customThreshold:?preferedRS\" v=\"::::0:0:1\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferedRS : 1, customThreshold : 0, flags : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getExpulsion>\n\t<MAX_COUNTERING_AV get=\"inline\" set=\"null\" expr=\"8\" line=\"1493\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>8</e></m></meta>\n\t</MAX_COUNTERING_AV>\n\t<DEF_AGGR expr=\"0\" line=\"1496\" static=\"1\">\n\t\t<x path=\"Float\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</DEF_AGGR>\n\t<getSpecialDefWithReturnAttack public=\"1\" set=\"method\" line=\"1500\" static=\"1\">\n\t\t<f a=\"availableCP:againstCP:againstRoll:againstTN:?customThreshold:?secondExchange\" v=\"::::0:false\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ secondExchange : false, customThreshold : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t\t<e>\"DEF_AGGR\"</e>\n\t\t\t\t<e>\"B_MANUEVER_CHOICES\"</e>\n\t\t\t\t<e>\"B_MANUEVER_CHOICE_COUNT\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 0 } }, { inspect : { min : 1 } }, { inspect : { min : 0, display : \"range\", step : 0.01, max : 1 } }]</e></m>\n\t\t</meta>\n\t</getSpecialDefWithReturnAttack>\n\t<getAverageOpponentCounterAV set=\"method\" line=\"1643\" static=\"1\"><f a=\"\"><x path=\"Int\"/></f></getAverageOpponentCounterAV>\n\t<maxI get=\"inline\" set=\"null\" line=\"1650\" static=\"1\"><f a=\"val:val2\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></maxI>\n\t<getDisarm public=\"1\" set=\"method\" line=\"1658\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?flags:?customThreshold:?preferedRS:?defensive:?disarmOffhand\" v=\"::0:1:0:0:1:false:false\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ disarmOffhand : false, defensive : false, preferedRS : 1, customThreshold : 0, flags : 0, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getDisarm>\n\t<getHook public=\"1\" get=\"inline\" set=\"null\" line=\"1664\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?flags:?customThreshold:?preferedRS\" v=\"::0:1:0:0:1\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferedRS : 1, customThreshold : 0, flags : 0, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getHook>\n\t<getBindStrike public=\"1\" get=\"inline\" set=\"null\" line=\"1669\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:againstCP:?againstRoll:?againstTN:?flags:?customThreshold:?preferedRS\" v=\":::0:1:0:0:1\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferedRS : 1, customThreshold : 0, flags : 0, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getBindStrike>\n\t<getBeat public=\"1\" set=\"method\" line=\"1674\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?flags:?customThreshold:?preferedRS:?preferTargetMaster\" v=\"::0:1:0:0:1:0\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferTargetMaster : 0, preferedRS : 1, customThreshold : 0, flags : 0, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getBeat>\n\t<getAdvantageGainCPOffensiveMove public=\"1\" set=\"method\" line=\"1691\" static=\"1\">\n\t\t<f a=\"favorable:availableCP:?againstRoll:?againstTN:?flags:?customThreshold:?preferedRS:?preferTargetMaster\" v=\"::0:1:0:0:1:0\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ preferTargetMaster : 0, preferedRS : 1, customThreshold : 0, flags : 0, againstTN : 1, againstRoll : 0 }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t</meta>\n\t</getAdvantageGainCPOffensiveMove>\n\t<getPredictedOpponentDTN public=\"1\" get=\"inline\" set=\"null\" line=\"1721\" static=\"1\">\n\t\t<f a=\"\"><x path=\"Int\"/></f>\n\t\t<meta><m n=\"inspect\"/></meta>\n\t</getPredictedOpponentDTN>\n\t<getPredictedOpponentATN public=\"1\" get=\"inline\" set=\"null\" line=\"1726\" static=\"1\">\n\t\t<f a=\"\"><x path=\"Int\"/></f>\n\t\t<meta><m n=\"inspect\"/></meta>\n\t</getPredictedOpponentATN>\n\t<fluctuateLower get=\"inline\" set=\"null\" line=\"1804\" static=\"1\"><f a=\"val:lowerBy\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n</f></fluctuateLower>\n\t<getComboExchangeBudgetingWithInitiative set=\"method\" line=\"1813\" static=\"1\">\n\t\t<f a=\"combo:cp:cp2:?threatManuever\" v=\":::null\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"haxe.ds.Vector\"><x path=\"Int\"/></x>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ threatManuever : null }</e></m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { display : \"selector\" }, choices : \"COMBO\" }, { inspect : { min : 0 } }, { inspect : { min : 0 } }]</e></m>\n\t\t</meta>\n\t</getComboExchangeBudgetingWithInitiative>\n\t<tryFavoredElseBorderlineAttacks get=\"inline\" set=\"null\" line=\"1902\" static=\"1\"><f a=\"cp:cp2:dtn:heuristic:flags\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Bool\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Bool\"/>\n</f></tryFavoredElseBorderlineAttacks>\n\t<getComboAction set=\"method\" line=\"1917\" static=\"1\">\n\t\t<f a=\"combo:cp:cp2:?threatManuever:?hasInitiative:?secondExchange\" v=\":::null:true:false\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ secondExchange : false, hasInitiative : true, threatManuever : null }</e></m></meta>\n\t</getComboAction>\n\t<getComboActionTest set=\"method\" line=\"2061\" static=\"1\">\n\t\t<f a=\"combo:cp:cp2:?threatManuever:?hasInitiative:?secondExchange\" v=\":::null:true:false\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ secondExchange : false, hasInitiative : true, threatManuever : null }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"B_VIABLE_PROBABILITY_GET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { display : \"selector\" }, choices : \"COMBO\" }, { inspect : { min : 0 } }, { inspect : { min : 0 } }]</e></m>\n\t\t</meta>\n\t</getComboActionTest>\n\t<getCheapestBorderlineAtkCost set=\"method\" line=\"2068\" static=\"1\">\n\t\t<f a=\"cp:againstCP:dtn:?customThreshold\" v=\":::0\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ customThreshold : 0 }</e></m></meta>\n\t</getCheapestBorderlineAtkCost>\n\t<getCoupThreshold get=\"inline\" set=\"null\" line=\"2088\" static=\"1\"><f a=\"cp2\">\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></getCoupThreshold>\n\t<addPossibleComboManueverChoice get=\"inline\" set=\"null\" line=\"2094\" static=\"1\"><f a=\"index:theChoice\">\n\t<x path=\"Int\"/>\n\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t<x path=\"Void\"/>\n</f></addPossibleComboManueverChoice>\n\t<BUDGET_SKIP get=\"inline\" set=\"null\" expr=\"-1\" line=\"2100\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>-1</e></m></meta>\n\t</BUDGET_SKIP>\n\t<MANUEVER_CHOICE_CONSIDER_MASTER expr=\"new AIManueverChoice()\" line=\"2101\" static=\"1\">\n\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t<meta><m n=\":value\"><e>new AIManueverChoice()</e></m></meta>\n\t</MANUEVER_CHOICE_CONSIDER_MASTER>\n\t<setBestComboActionWithInitiativePlan set=\"method\" line=\"2113\" static=\"1\">\n\t\t<f a=\"cp:cp2:?threatManuever\" v=\"::null\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ threatManuever : null }</e></m></meta>\n\t</setBestComboActionWithInitiativePlan>\n\t<setBestComboActionWithInitiativePlanTest set=\"method\" line=\"2192\" static=\"1\">\n\t\t<f a=\"cp:cp2:?threatManuever\" v=\"::null\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>{ threatManuever : null }</e></m>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"MANUEVER_COMBO_SET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE_SET\"</e>\n\t\t\t\t<e>\"B_COMBO_CANDIDATE_COUNT\"</e>\n\t\t\t\t<e>\"B_COMBO_CANDIDATES\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }]</e></m>\n\t\t</meta>\n\t</setBestComboActionWithInitiativePlanTest>\n\t<setBestComboActionWithoutInitiativePlan public=\"1\" set=\"method\" line=\"2212\" static=\"1\"><f a=\"cp:cp2:threatManuever\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t<x path=\"Bool\"/>\n</f></setBestComboActionWithoutInitiativePlan>\n\t<setBestComboActionWithoutInitiativePlanTest public=\"1\" set=\"method\" line=\"2260\" static=\"1\">\n\t\t<f a=\"cp:cp2:threatManuever\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<c path=\"troshx.util.AIManueverChoice\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t</f>\n\t\t<meta>\n\t\t\t<m n=\"return\">\n\t\t\t\t<e>\"MANUEVER_COMBO_SET\"</e>\n\t\t\t\t<e>\"MANUEVER_CHOICE_SET\"</e>\n\t\t\t\t<e>\"B_COMBO_CANDIDATE_COUNT\"</e>\n\t\t\t\t<e>\"B_COMBO_CANDIDATES\"</e>\n\t\t\t</m>\n\t\t\t<m n=\"inspect\"><e>[{ inspect : { min : 0 } }, { inspect : { min : 0 } }]</e></m>\n\t\t</meta>\n\t</setBestComboActionWithoutInitiativePlanTest>\n\t<opponents expr=\"[]\" line=\"21\">\n\t\t<c path=\"Array\"><c path=\"troshx.tros.ai.TROSAiBot\"/></c>\n\t\t<meta><m n=\":value\"><e>[]</e></m></meta>\n\t</opponents>\n\t<opponentLen expr=\"0\" line=\"22\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</opponentLen>\n\t<cpBudget expr=\"[]\" line=\"23\">\n\t\t<c path=\"Array\"><x path=\"Int\"/></c>\n\t\t<meta><m n=\":value\"><e>[]</e></m></meta>\n\t</cpBudget>\n\t<plannedCombos expr=\"[0, 0, 0, 0]\" line=\"25\">\n\t\t<c path=\"Array\"><x path=\"Int\"/></c>\n\t\t<meta><m n=\":value\"><e>[0, 0, 0, 0]</e></m></meta>\n\t</plannedCombos>\n\t<currentExchange expr=\"0\" line=\"27\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</currentExchange>\n\t<body public=\"1\">\n\t\t<c path=\"troshx.core.BodyChar\"/>\n\t\t<meta><m n=\"inject\"/></meta>\n\t</body>\n\t<cp public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"bind\"><e>\"_cp\"</e></m></meta>\n\t</cp>\n\t<perception public=\"1\" expr=\"4\" line=\"33\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>4</e></m>\n\t\t\t<m n=\"bind\"><e>\"_perception\"</e></m>\n\t\t</meta>\n\t</perception>\n\t<equipMasterhand public=\"1\">\n\t\t<c path=\"String\"/>\n\t\t<meta><m n=\"bind\"><e>\"_equipMasterhand\"</e></m></meta>\n\t</equipMasterhand>\n\t<equipOffhand public=\"1\">\n\t\t<c path=\"String\"/>\n\t\t<meta><m n=\"bind\"><e>\"_equipOffhand\"</e></m></meta>\n\t</equipOffhand>\n\t<mobility public=\"1\" expr=\"6\" line=\"36\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>6</e></m>\n\t\t\t<m n=\"bind\"><e>\"_mobility\"</e></m>\n\t\t</meta>\n\t</mobility>\n\t<id public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"bind\"><e>\"_id\"</e></m></meta>\n\t</id>\n\t<fight_initiative public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"bind\"><e>\"_fight_initiative\"</e></m></meta>\n\t</fight_initiative>\n\t<stance public=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\"bind\"><e>\"_fight_stance\"</e></m></meta>\n\t</stance>\n\t<manueverUsingHands public=\"1\" expr=\"0\" line=\"43\">\n\t\t<x path=\"Int\"/>\n\t\t<meta>\n\t\t\t<m n=\":value\"><e>0</e></m>\n\t\t\t<m n=\"bind\"><e>\"_manueverUsingHands\"</e></m>\n\t\t</meta>\n\t</manueverUsingHands>\n\t<handsUsedUp expr=\"0\" line=\"59\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0</e></m></meta>\n\t</handsUsedUp>\n\t<decidedStance public=\"1\"><x path=\"Int\"/></decidedStance>\n\t<decidedOrientation public=\"1\"><x path=\"Int\"/></decidedOrientation>\n\t<decidedManuevers public=\"1\" expr=\"[new AIManueverChoice(), new AIManueverChoice(), new AIManueverChoice(), new AIManueverChoice()]\" line=\"63\">\n\t\t<c path=\"Array\"><c path=\"troshx.util.AIManueverChoice\"/></c>\n\t\t<meta><m n=\":value\"><e>[new AIManueverChoice(), new AIManueverChoice(), new AIManueverChoice(), new AIManueverChoice()]</e></m></meta>\n\t</decidedManuevers>\n\t<getDecidedManueverForSlot public=\"1\" set=\"method\" line=\"67\"><f a=\"slot\">\n\t<x path=\"Int\"/>\n\t<c path=\"String\"/>\n</f></getDecidedManueverForSlot>\n\t<getDecidedManueverCP public=\"1\" set=\"method\" line=\"70\"><f a=\"slot\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getDecidedManueverCP>\n\t<getDecidedManueverTargetZone public=\"1\" set=\"method\" line=\"73\"><f a=\"slot\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getDecidedManueverTargetZone>\n\t<getPredictedDTN set=\"method\" line=\"1730\"><f a=\"\"><x path=\"Int\"/></f></getPredictedDTN>\n\t<getPredictedATN set=\"method\" line=\"1750\"><f a=\"\"><x path=\"Int\"/></f></getPredictedATN>\n\t<getOffhandDTN get=\"inline\" set=\"null\" line=\"1779\"><f a=\"\"><x path=\"Int\"/></f></getOffhandDTN>\n\t<getShieldDTN get=\"inline\" set=\"null\" line=\"1784\"><f a=\"\"><x path=\"Int\"/></f></getShieldDTN>\n\t<getMasterDTN get=\"inline\" set=\"null\" line=\"1788\"><f a=\"\"><x path=\"Int\"/></f></getMasterDTN>\n\t<getHighestATNOrDTN set=\"method\" line=\"1794\"><f a=\"\"><x path=\"Int\"/></f></getHighestATNOrDTN>\n\t<getDTNBetterMargin get=\"inline\" set=\"null\" line=\"1800\"><f a=\"\"><x path=\"Int\"/></f></getDTNBetterMargin>\n\t<isDualWeilding get=\"inline\" set=\"null\" line=\"2083\"><f a=\"\"><x path=\"Bool\"/></f></isDualWeilding>\n\t<newExchange public=\"1\" set=\"method\" line=\"2281\">\n\t\t<f a=\"?newRound\" v=\"false\">\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Void\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ newRound : false }</e></m></meta>\n\t</newExchange>\n\t<decideStance public=\"1\" set=\"method\" line=\"2299\"><f a=\"enemies:target:targetedBy\">\n\t<c path=\"Array\"><c path=\"troshx.tros.ai.TROSAiBot\"/></c>\n\t<c path=\"troshx.tros.ai.TROSAiBot\"/>\n\t<c path=\"Array\"><c path=\"troshx.tros.ai.TROSAiBot\"/></c>\n\t<x path=\"Void\"/>\n</f></decideStance>\n\t<decideOrientation public=\"1\" set=\"method\" line=\"2303\"><f a=\"enemies:target:targetedBy\">\n\t<c path=\"Array\"><c path=\"troshx.tros.ai.TROSAiBot\"/></c>\n\t<c path=\"troshx.tros.ai.TROSAiBot\"/>\n\t<c path=\"Array\"><c path=\"troshx.tros.ai.TROSAiBot\"/></c>\n\t<x path=\"Void\"/>\n</f></decideOrientation>\n\t<decideTarget public=\"1\" set=\"method\" line=\"2307\"><f a=\"enemies\">\n\t<c path=\"Array\"><c path=\"troshx.tros.ai.TROSAiBot\"/></c>\n\t<x path=\"Void\"/>\n</f></decideTarget>\n\t<preDeclareManuevers public=\"1\" set=\"method\" line=\"2314\"><f a=\"target:targetedBy\">\n\t<c path=\"troshx.tros.ai.TROSAiBot\"/>\n\t<c path=\"Array\"><c path=\"troshx.tros.ai.TROSAiBot\"/></c>\n\t<x path=\"Void\"/>\n</f></preDeclareManuevers>\n\t<getRemainingCPLeftIfUnpaid public=\"1\" set=\"method\" line=\"2342\"><f a=\"\"><x path=\"Int\"/></f></getRemainingCPLeftIfUnpaid>\n\t<getTotalThreatCPAgainst public=\"1\" set=\"method\" line=\"2351\"><f a=\"targetId\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getTotalThreatCPAgainst>\n\t<declareManueverAgainstOpponentId public=\"1\" set=\"method\" line=\"2380\"><f a=\"oppId\">\n\t<x path=\"Int\"/>\n\t<x path=\"Bool\"/>\n</f></declareManueverAgainstOpponentId>\n\t<getOpponentIndex public=\"1\" set=\"method\" line=\"2389\"><f a=\"oppId\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n</f></getOpponentIndex>\n\t<declareManueverAgainstOpponent public=\"1\" set=\"method\" line=\"2396\"><f a=\"index\">\n\t<x path=\"Int\"/>\n\t<x path=\"Bool\"/>\n</f></declareManueverAgainstOpponent>\n\t<get_initiative set=\"method\" line=\"2478\"><f a=\"\"><x path=\"Bool\"/></f></get_initiative>\n\t<set_initiative set=\"method\" line=\"2483\"><f a=\"value\">\n\t<x path=\"Bool\"/>\n\t<x path=\"Bool\"/>\n</f></set_initiative>\n\t<initiative public=\"1\" get=\"accessor\" set=\"accessor\"><x path=\"Bool\"/></initiative>\n\t<new public=\"1\" set=\"method\" line=\"2273\"><f a=\"\"><x path=\"Void\"/></f></new>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":expose\"/>\n\t\t<m n=\":rtti\"/>\n\t</meta>\n</class>";
troshx_tros_ai_TROSAiBot.ENEMY_STEAL_COST = 4;
troshx_tros_ai_TROSAiBot.MIN_EXPOSED_AV = 0;
troshx_tros_ai_TROSAiBot.AVAIL_bash = 0;
troshx_tros_ai_TROSAiBot.AVAIL_spike = 0;
troshx_tros_ai_TROSAiBot.AVAIL_cut = 0;
troshx_tros_ai_TROSAiBot.AVAIL_thrust = 0;
troshx_tros_ai_TROSAiBot.AVAIL_beat = 0;
troshx_tros_ai_TROSAiBot.AVAIL_bindstrike = 0;
troshx_tros_ai_TROSAiBot.AVAIL_hook = 0;
troshx_tros_ai_TROSAiBot.AVAIL_block = 0;
troshx_tros_ai_TROSAiBot.AVAIL_parry = 0;
troshx_tros_ai_TROSAiBot.AVAIL_duckweave = 0;
troshx_tros_ai_TROSAiBot.AVAIL_partialevasion = 0;
troshx_tros_ai_TROSAiBot.AVAIL_fullevasion = 0;
troshx_tros_ai_TROSAiBot.AVAIL_blockopenstrike = 0;
troshx_tros_ai_TROSAiBot.AVAIL_counter = 0;
troshx_tros_ai_TROSAiBot.AVAIL_rota = 0;
troshx_tros_ai_TROSAiBot.AVAIL_expulsion = 0;
troshx_tros_ai_TROSAiBot.AVAIL_disarm = 0;
troshx_tros_ai_TROSAiBot.AVAIL_StealInitiative = 0;
troshx_tros_ai_TROSAiBot.B_EQUIP = "";
troshx_tros_ai_TROSAiBot.B_IS_OFFHAND = false;
troshx_tros_ai_TROSAiBot.D_EQUIP = "";
troshx_tros_ai_TROSAiBot.B_COMBO_EXCHANGE_BUDGET = new Array(4);
troshx_tros_ai_TROSAiBot.BUDGET_EXCHANGE_1 = 0;
troshx_tros_ai_TROSAiBot.BUDGET_EXCHANGE_1_ENEMY = 1;
troshx_tros_ai_TROSAiBot.BUDGET_EXCHANGE_2 = 2;
troshx_tros_ai_TROSAiBot.BUDGET_EXCHANGE_2_ENEMY = 3;
troshx_tros_ai_TROSAiBot.WISH_TO_REGAIN_STANCE = false;
troshx_tros_ai_TROSAiBot.CURRENTLY_AGGROED = false;
troshx_tros_ai_TROSAiBot.CP_ALREADY_PAID = true;
troshx_tros_ai_TROSAiBot.COMBO_PureMeanStrikes = 1;
troshx_tros_ai_TROSAiBot.COMBO_HeavyFirstStrikes = 2;
troshx_tros_ai_TROSAiBot.COMBO_AlphaDisarm = 3;
troshx_tros_ai_TROSAiBot.COMBO_AlphaHookStrike = 4;
troshx_tros_ai_TROSAiBot.COMBO_AlphaStrike = 5;
troshx_tros_ai_TROSAiBot.COMBO_FeintStrike = 6;
troshx_tros_ai_TROSAiBot.COMBO_DoubleAttack = 7;
troshx_tros_ai_TROSAiBot.COMBO_SimulatenousBlockStrike = 8;
troshx_tros_ai_TROSAiBot.COMBOS_LEN_INITIATIVE = 9;
troshx_tros_ai_TROSAiBot.COMBO_CoupDeGrace = 9;
troshx_tros_ai_TROSAiBot.COMBOS_LEN_INITIATIVE_FINAL = 10;
troshx_tros_ai_TROSAiBot.COMBO_DefensiveFirst = -1;
troshx_tros_ai_TROSAiBot.COMBO_DefensiveBorderline = -2;
troshx_tros_ai_TROSAiBot.COMBO_SpecialDefFirst = -3;
troshx_tros_ai_TROSAiBot.COMBO_AlphaInitiativeStealer = -4;
troshx_tros_ai_TROSAiBot.COMBO_AlphaDisarmDef = -5;
troshx_tros_ai_TROSAiBot.COMBO_SimulatenousBlockStrikeStealer = -6;
troshx_tros_ai_TROSAiBot.COMBOS_LEN_NO_INITAITIVE = 7;
troshx_tros_ai_TROSAiBot.P_THRESHOLD_FAVORABLE = 0.75;
troshx_tros_ai_TROSAiBot.P_THRESHOLD_BORDERLINE = 0.5;
troshx_tros_ai_TROSAiBot.P_RECKLESS = 0.2;
troshx_tros_ai_TROSAiBot.P_THRESHOLD_ANTI_FAVORABLE = 0.75;
troshx_tros_ai_TROSAiBot.B_CANDIDATES = [];
troshx_tros_ai_TROSAiBot.B_CANDIDATE_COUNT = 0;
troshx_tros_ai_TROSAiBot.B_BS_REQUIRED = 1;
troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DEFAULT = 1;
troshx_tros_ai_TROSAiBot.COUP_BS_MODIFIER = 1;
troshx_tros_ai_TROSAiBot.B_BS_REQUIRED_DMG_DEFAULT = 1;
troshx_tros_ai_TROSAiBot.PREFERED_HOOK_BS = 2;
troshx_tros_ai_TROSAiBot.PREFERED_DISARM_BS = 2;
troshx_tros_ai_TROSAiBot.PREFERED_DISARM_DEF_BS = 2;
troshx_tros_ai_TROSAiBot.CAN_DESPERATE_ALPHASTRIKE = false;
troshx_tros_ai_TROSAiBot.DESPERATE_ALPHASTRIKE_CHANCE = 0.5;
troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICES = [];
troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_PROBABILITIES = [];
troshx_tros_ai_TROSAiBot.B_MANUEVER_CHOICE_COUNT = 0;
troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATES = [];
troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_MANUEVER = [];
troshx_tros_ai_TROSAiBot.B_COMBO_CANDIDATE_COUNT = 0;
troshx_tros_ai_TROSAiBot.BPROB_BASE = 1000;
troshx_tros_ai_TROSAiBot.DMG_AGGR_BASE = 10;
troshx_tros_ai_TROSAiBot.IMPOSSIBLE_TN = 888;
troshx_tros_ai_TROSAiBot.B_USE_ADVANTAGE = false;
troshx_tros_ai_TROSAiBot.ATTACK_AGGR = 0;
troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE = new troshx_util_AIManueverChoice();
troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_1 = new troshx_util_AIManueverChoice();
troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_SET = new troshx_util_AIManueverChoice();
troshx_tros_ai_TROSAiBot.MANUEVER_COMBO_SET = 0;
troshx_tros_ai_TROSAiBot.FLAG_GET_CHEAPEST = 1;
troshx_tros_ai_TROSAiBot.FLAG_USE_ALL_CP = 2;
troshx_tros_ai_TROSAiBot.FLAG_BORDERLINE_DEF_SAFETY = 4;
troshx_tros_ai_TROSAiBot.FLEE_TN = 4;
troshx_tros_ai_TROSAiBot.MOCK_RETURN_ATTACK = new troshx_util_AIManueverChoice();
troshx_tros_ai_TROSAiBot.MAX_COUNTERING_AV = 8;
troshx_tros_ai_TROSAiBot.DEF_AGGR = 0;
troshx_tros_ai_TROSAiBot.BUDGET_SKIP = -1;
troshx_tros_ai_TROSAiBot.MANUEVER_CHOICE_CONSIDER_MASTER = new troshx_util_AIManueverChoice();
troshx_util_StringHashId.COUNT = 0;
troshx_util_TROSAI.__rtti = "<class path=\"troshx.util.TROSAI\" params=\"\">\n\t<factorial public=\"1\" get=\"inline\" set=\"null\" line=\"26\" static=\"1\"><f a=\"val\">\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></factorial>\n\t<binomialCoef public=\"1\" get=\"inline\" set=\"null\" line=\"40\" static=\"1\"><f a=\"n:r\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></binomialCoef>\n\t<getTNSuccessProbForDie public=\"1\" get=\"inline\" set=\"null\" line=\"50\" static=\"1\"><f a=\"tn\">\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></getTNSuccessProbForDie>\n\t<getXSuccessesProb public=\"1\" get=\"inline\" set=\"null\" line=\"54\" static=\"1\"><f a=\"numDiceToRoll:tn:x\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></getXSuccessesProb>\n\t<getAtLeastXSuccessesProb public=\"1\" set=\"method\" line=\"59\" static=\"1\"><f a=\"numDiceToRoll:tn:x\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></getAtLeastXSuccessesProb>\n\t<probabilityAOrB public=\"1\" get=\"inline\" set=\"null\" line=\"69\" static=\"1\"><f a=\"a:b\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n</f></probabilityAOrB>\n\t<probabilityOfArrayOr public=\"1\" get=\"inline\" set=\"null\" line=\"73\" static=\"1\"><f a=\"arr\">\n\t<c path=\"Array\"><x path=\"Float\"/></c>\n\t<x path=\"Float\"/>\n</f></probabilityOfArrayOr>\n\t<getBelowOrEqualXSuccessesProb public=\"1\" set=\"method\" line=\"83\" static=\"1\"><f a=\"numDiceToRoll:tn:x\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></getBelowOrEqualXSuccessesProb>\n\t<getChanceToSucceedContest public=\"1\" set=\"method\" line=\"105\" static=\"1\">\n\t\t<f a=\"numDice:tn:againstNumDice:againstTN:?rs:?requireAtLeast1TS\" v=\"::::1:true\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Bool\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ requireAtLeast1TS : true, rs : 1 }</e></m></meta>\n\t</getChanceToSucceedContest>\n\t<getChanceToSucceed public=\"1\" set=\"method\" line=\"142\" static=\"1\">\n\t\t<f a=\"numDice:tn:?rs\" v=\"::1\">\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Int\"/>\n\t\t\t<x path=\"Float\"/>\n\t\t</f>\n\t\t<meta><m n=\":value\"><e>{ rs : 1 }</e></m></meta>\n\t</getChanceToSucceed>\n\t<getAllXSuccessesProb public=\"1\" set=\"method\" line=\"149\" static=\"1\"><f a=\"numDice:tn\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<c path=\"Array\"><x path=\"Float\"/></c>\n</f></getAllXSuccessesProb>\n\t<getTabulatedRollData public=\"1\" set=\"method\" line=\"157\" static=\"1\"><f a=\"numDice:tn\">\n\t<x path=\"Int\"/>\n\t<x path=\"Int\"/>\n\t<c path=\"Array\"><d/></c>\n</f></getTabulatedRollData>\n\t<maxPrecision public=\"1\" get=\"inline\" set=\"null\" line=\"180\" static=\"1\"><f a=\"x:precision\">\n\t<x path=\"Float\"/>\n\t<x path=\"Int\"/>\n\t<x path=\"Float\"/>\n</f></maxPrecision>\n\t<roundTo public=\"1\" set=\"method\" line=\"184\" static=\"1\"><f a=\"x:y\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n</f></roundTo>\n\t<INT32_MIN public=\"1\" get=\"inline\" set=\"null\" expr=\"0x80000000\" line=\"208\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0x80000000</e></m></meta>\n\t</INT32_MIN>\n\t<INT32_MAX public=\"1\" get=\"inline\" set=\"null\" expr=\"0x7fffffff\" line=\"214\" static=\"1\">\n\t\t<x path=\"Int\"/>\n\t\t<meta><m n=\":value\"><e>0x7fffffff</e></m></meta>\n\t</INT32_MAX>\n\t<displayAsPercentage public=\"1\" get=\"inline\" set=\"null\" line=\"217\" static=\"1\"><f a=\"probability\">\n\t<x path=\"Float\"/>\n\t<x path=\"Float\"/>\n</f></displayAsPercentage>\n\t<new public=\"1\" set=\"method\" line=\"16\"><f a=\"\"><x path=\"Void\"/></f></new>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":expose\"/>\n\t\t<m n=\":rtti\"/>\n\t</meta>\n</class>";
troshx_util_TROSAI.INT32_MIN = -2147483648;
troshx_util_TROSAI.INT32_MAX = 2147483647;
Main.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
